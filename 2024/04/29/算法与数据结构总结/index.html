<!DOCTYPE html><html lang="en" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>milklatte'blog | milklatte'blog</title><meta name="author" content="milklatte"><meta name="copyright" content="milklatte"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="算法与数据结构总结篇0.刷题进度2023-7-23   1.数组专题总结(二分，滑动窗口，前缀和，差分)1.1 二分查找方法论 — 二分模版选用&#x3D;&#x3D;左闭右闭&#x3D;&#x3D;二分查找两种情况： 1.&#x3D;&#x3D;查找某一个位置&#x3D;&#x3D; 情况1：能找到target，则mid即为结果 情况2：未找到target，则存在一个插入位置，while循环退出后，下标分布情况为，right  left(target插入位置)，则应该在le">
<meta property="og:type" content="article">
<meta property="og:title" content="milklatte&#39;blog">
<meta property="og:url" content="http://example.com/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="milklatte&#39;blog">
<meta property="og:description" content="算法与数据结构总结篇0.刷题进度2023-7-23   1.数组专题总结(二分，滑动窗口，前缀和，差分)1.1 二分查找方法论 — 二分模版选用&#x3D;&#x3D;左闭右闭&#x3D;&#x3D;二分查找两种情况： 1.&#x3D;&#x3D;查找某一个位置&#x3D;&#x3D; 情况1：能找到target，则mid即为结果 情况2：未找到target，则存在一个插入位置，while循环退出后，下标分布情况为，right  left(target插入位置)，则应该在le">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/avatar.png">
<meta property="article:published_time" content="2024-04-29T07:17:39.047Z">
<meta property="article:modified_time" content="2024-04-13T13:45:32.418Z">
<meta property="article:author" content="milklatte">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Error',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'milklatte\'blog',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-13 21:45:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.2"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/def_img.png')"><nav id="nav"><span id="blog-info"><a href="/" title="milklatte'blog"><span class="site-name">milklatte'blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Untitled</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-04-29T07:17:39.047Z" title="Created 2024-04-29 15:17:39">2024-04-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2024-04-13T13:45:32.418Z" title="Updated 2024-04-13 21:45:32">2024-04-13</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="算法与数据结构总结篇"><a href="#算法与数据结构总结篇" class="headerlink" title="算法与数据结构总结篇"></a>算法与数据结构总结篇</h1><h2 id="0-刷题进度"><a href="#0-刷题进度" class="headerlink" title="0.刷题进度"></a>0.刷题进度</h2><p><strong>2023-7-23</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230723133101766.png" alt="image-20230723133101766" style="zoom:50%;" align="left">

<h2 id="1-数组专题总结-二分，滑动窗口，前缀和，差分"><a href="#1-数组专题总结-二分，滑动窗口，前缀和，差分" class="headerlink" title="1.数组专题总结(二分，滑动窗口，前缀和，差分)"></a>1.数组专题总结(二分，滑动窗口，前缀和，差分)</h2><h3 id="1-1-二分查找"><a href="#1-1-二分查找" class="headerlink" title="1.1 二分查找"></a>1.1 二分查找</h3><h4 id="方法论-—-二分模版选用-左闭右闭"><a href="#方法论-—-二分模版选用-左闭右闭" class="headerlink" title="方法论 — 二分模版选用==左闭右闭=="></a>方法论 — 二分模版选用==左闭右闭==</h4><p>二分查找两种情况：</p>
<p>1.==查找某一个位置==</p>
<p>情况1：能找到target，则mid即为结果</p>
<p>情况2：未找到target，则存在一个插入位置，while循环退出后，下标分布情况为，<code>right  left(target插入位置)</code>，则应该在left位置插入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.查找范围</p>
<p>情况1：查找左边界</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchLeftRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid - <span class="number">1</span>;<span class="comment">// 取等时右边界继续左移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[left];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>while退出后下标分布情况为，</p>
<blockquote>
<p>num1 num2 … right left(第一个target)…num<del>k</del> num<del>k+1</del></p>
</blockquote>
<p>即左边界为left，小于左边界的第一个值为left-1 (或right)</p>
<p>情况2：查找右边界，while退出后，为：<code>right(最后一个target) left</code>，即右边界为right，大于右边界的第一个值为right+1(或left)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRightRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid + <span class="number">1</span>;<span class="comment">// 取等时左边界继续右移</span></span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];<span class="comment">//right处即为右边界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="704-二分查找-基本二分"><a href="#704-二分查找-基本二分" class="headerlink" title="704.二分查找_==基本二分=="></a>704.二分查找_==基本二分==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230723141444140.png" alt="image-20230723141444140" style="zoom: 67%;" align="left">

<p>方法</p>
<blockquote>
<p>左闭右闭：我们定义target是在一个在左闭右闭的区间内，即**[left,right]**</p>
<p>区间的定义决定类的二分法的代码如何编写，因为定义target在[left,right]区间，可得到以下两点：</p>
<ol>
<li>while(left &lt;= right) 要使用&lt;=,因为left == right是有意义的</li>
<li>if(nums[middle] &gt; target) right 要赋值为 middle-1， 因为当前的nums[middle]一定不是target，所有下一轮的左区间的结束位置下标为middle-1</li>
</ol>
<p>即 左闭右闭，&lt;=有意义，左+1右-1</p>
<p>查找时：while结束时，若没有查找到，此时大小排序为==nums[end] &lt; target &lt; nums[begin]==,若需要插入则位置为begin 或 end+1</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; <span class="comment">// 注意</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="34-在排序数组中查找元素的第一个和最后一个位置-查找左右边界"><a href="#34-在排序数组中查找元素的第一个和最后一个位置-查找左右边界" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置_==查找左右边界=="></a>34. 在排序数组中查找元素的第一个和最后一个位置_==查找左右边界==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230723141951838.png" alt="image-20230723141951838" style="zoom: 80%;" align="left">



<p>方法</p>
<blockquote>
<p>套用前面总结的查找边界的模版即可，但是需要注意==边界情况==：</p>
<ul>
<li>情况一：target 在数组范围的右边或者左边(包括数组为空的情况)，例如数组{3, 4, 5}，target为2或者数组{3, 4, 5},target为6，此时应该返回{-1, -1}</li>
<li>情况二：target 在数组范围中，且数组中不存在target，例如数组{3,6,7},target为5，此时应该返回{-1, -1}</li>
<li>情况三：target 在数组范围中，且数组中存在target，例如数组{3,6,7},target为6，此时应该返回{-1, -1}</li>
</ul>
<p>查找分类：</p>
<ul>
<li>寻找左边界：由于最后的下标分布情况一定是 right left，而只有right是往左移动，所以选择right变化的部分取等，if(nums[mid] &gt;= target) right = mid - 1;</li>
<li>右边界同理：left往右移动，选择left变化的部分取等，if(nums[mid] &lt;= target) left = mid + 1;</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">     <span class="comment">//情况一：数组为空或者target在数组左边或右边</span></span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span> || target &lt; nums[<span class="number">0</span>] || target &gt; nums[nums.length - <span class="number">1</span>]) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找左边界，往左移动的只有right</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left +(right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 使用right检验边界情况</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= target) right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到左边界，则数组不存在target</span></span><br><span class="line">    <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    res[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line">    left = <span class="number">0</span>;</span><br><span class="line">    right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt;= target) left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在左边界，则右边界一定存在</span></span><br><span class="line">    res[<span class="number">1</span>] = right;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="153-寻找旋转排序数组中的最小值-在不重复旋转数组查找最小值"><a href="#153-寻找旋转排序数组中的最小值-在不重复旋转数组查找最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值_==在不重复旋转数组查找最小值=="></a>153. 寻找旋转排序数组中的最小值_==在不重复旋转数组查找最小值==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230723142715289.png" alt="image-20230723142715289" style="zoom:80%;" align="left">



<p>思路</p>
<p>对于不重复的递增数组，旋转部分元素后，数组会分为左右两段，左半段 &gt;= nums[0], 右半段 &lt; nums[0]</p>
<blockquote>
<p>1  2  3  4  5 -&gt; 3  4  5  |  1  2</p>
</blockquote>
<p>考虑最小值的位置，最小值大于旋转后数组的左半段，大于旋转数组的右半段，我们可以把旋转数组的nums[0]视为target来进行二分查找，在<strong>下标移动时我们把取等的情况归入left变化</strong>，while循环弹出后left位置即为最小值位置</p>
<p>注意：旋转数组可能进行了无效旋转，数组仍为原数组，此时left会移动到下标为n的位置</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers[mid] &gt;= numbers[<span class="number">0</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left == n ? numbers[<span class="number">0</span>] : numbers[left];</span><br></pre></td></tr></table></figure>



<h4 id="154-寻找旋转排序数组中的最小值-在存在重复元素的旋转数组查找最小值"><a href="#154-寻找旋转排序数组中的最小值-在存在重复元素的旋转数组查找最小值" class="headerlink" title="154. 寻找旋转排序数组中的最小值_==在存在重复元素的旋转数组查找最小值=="></a>154. 寻找旋转排序数组中的最小值_==在存在重复元素的旋转数组查找最小值==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230723144023912.png" alt="image-20230723144023912" style="zoom:80%;" align="left">



<p>思路</p>
<p>接上题思路，对于有重复元素的数组，例如 </p>
<blockquote>
<p>0 1 2 2 2 -&gt;  2 2 0 1 2</p>
</blockquote>
<p>在使用nums[0]作为target的时候，需要满足左半段 &gt;= nums[0], 右半段 &lt; nums[0]。</p>
<p>但是由于存在重复元素，其右段可能不满足 &lt; num[0], 所以我们需要通过左移右端点的值来恢复二分性 </p>
<blockquote>
<p>2 2 0 1 2 -&gt; 2 2 0 1(新的右端点) 2</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 恢复二分性： 2 2 0 1 2 -&gt; 2 2 0 1</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; numbers[right] == numbers[<span class="number">0</span>]) right--;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(numbers[mid] &gt;= numbers[<span class="number">0</span>]) left = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> left == n ? numbers[<span class="number">0</span>] : numbers[left];</span><br></pre></td></tr></table></figure>



<h4 id="33-搜索旋转排序数组-在旋转数组查找target"><a href="#33-搜索旋转排序数组-在旋转数组查找target" class="headerlink" title="33.搜索旋转排序数组_==在旋转数组查找target=="></a>33.搜索旋转排序数组_==在旋转数组查找target==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230723153849915.png" alt="image-20230723153849915" style="zoom: 80%;" align="left">



<p>思路</p>
<p>将有序数组旋转部分元素后，数组会划分为两部分有序数组</p>
<p>当我们选取mid后，只存在两种情况：</p>
<p>[left, mid]有序，则[mid,right]无序</p>
<p>[left, mid]无序， 则[mid, right]有序</p>
<p>解决上述题目需要结合两个条件：</p>
<ol>
<li>只有在顺序区间内才可以通过区间两端的数值判断target是否在其中。</li>
<li>判断顺序区间还是乱序区间，只需要对比 左端点 和 右端点 是否是顺序对即可，左端点 &lt;= 右端点，顺序区间，否则乱序区间。</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="comment">// [left, mid]有序，[mid, right]无序</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= nums[left])&#123;</span><br><span class="line">            <span class="keyword">if</span>(target &gt;= nums[left] &amp;&amp; target &lt; nums[mid])&#123;</span><br><span class="line">                <span class="comment">// target在有序区间[left, mid]中间，则修改右端点</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// target在无序区间[mid, right]中间，则修改左端点</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// [left, mid]无序，[mid, right]有序</span></span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                <span class="comment">// target在有序区间[mid, right]中间，则修改左端点</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// target在无序区间[left, mid]中间，则修改右端点</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-寻找两个有序数组的中位数-二分查找寻找第K个数"><a href="#4-寻找两个有序数组的中位数-二分查找寻找第K个数" class="headerlink" title="4.寻找两个有序数组的中位数_==二分查找寻找第K个数=="></a>4.寻找两个有序数组的中位数_==二分查找寻找第K个数==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724110314833.png" alt="image-20230724110314833" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>求两个有序数组的中位数，而且限制了时间复杂度为O(log (m+n))，看到这个时间复杂度，自然而然的想到了应该使用==二分查找==来求解。</p>
<p>分类讨论：回顾一下中位数的定义，如果某个有序数组长度是奇数，那么其中位数就是最中间那个，如果是偶数，那么就是最中间两个数字的平均值。这里对于两个有序数组也是一样的，假设两个有序数组的长度分别为 m 和 n，由于两个数组长度之和 m+n 的奇偶不确定，因此需要分情况来讨论，对于奇数的情况，直接找到最中间的数即可，偶数的话需要求最中间两个数的平均值。为了简化代码，不分情况讨论，我们使用一个小trick，我们<strong>分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这对奇偶数均适用。</strong>假如 m+n 为奇数的话，那么其实 (m+n+1) / 2 和 (m+n+2) / 2 的值相等，相当于两个相同的数字相加再除以2，还是其本身。</p>
<p>上面定义的第 <code>(m+n+1) / 2</code> 个，和第 <code>(m+n+2) / 2</code> 个就是我们要找的中位数，可以转换思路理解为要查找第 k 个元素(k 即为第 (m+n+1) / 2 个，和第 (m+n+2) / 2 个)。接下来可以定义一个函数在两个有序数组中查找逻辑上二者合并之后的第 K 个元素。</p>
<p>下面重点来看如何实现找到第 K 个元素。首先，我们使用两个变量 i 和 j 分别来标记数组 nums1 和 nums2 的起始位置。然后先来处理一些边界问题，比如当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组了，那么实际上就变成了在另一个数组中找数字，直接就可以找出来了。还有就是如果 K=1的话，那么我们只要比较 nums1 和 nums2 的起始位置 i和j 上的数字然后取较小值就可以了。</p>
<p>难点就在于一般的情况怎么处理？因为我们需要在两个有序数组中找到第 K 个元素，为了加快搜索的速度，我们要使用二分法，对 K 二分，意思是我们需要分别在 nums1 和 nums2 中查找<code>第 K/2(即nums1[i + k / 2 - 1]) 个元素</code>，注意这里由于两个数组的长度不定，所以有可能某个数组没有第 K/2 个数字，所以我们需要先检查一下，数组中到底存不存在第 K/2 个数字，如果存在就取出来，否则就赋值上一个==整型最大值==。有没有可能两个数组都不存在第 K/2个 数字呢，这道题里是不可能的，因为我们的 K 不是任意给的，而是给的 m+n 的中间值，所以必定至少会有一个数组是存在第 K/2 个数字的。最后就是二分法的核心啦，比较这两个数组的第 K/2 小的数字 midVal1 和 midVal2 的大小，**如果第一个数组的第 K/2个数字小的话，那么说明我们要找的数字肯定不在 nums1 中的前 K/2 个数字，所以我们可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的 K 也自减去 K/2 **，调用递归。反之，我们淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减去 K/2，调用递归即可。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="comment">// m + n 为奇数时，left和right取得都是同一个位置，为偶数的，取得是中间的两个位置。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (m + n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> (m + n + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, left) + findKth(nums1, <span class="number">0</span>, nums2, <span class="number">0</span>, right)) / <span class="number">2.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i: nums1的起始位置 j: nums2的起始位置</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKth</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> i, <span class="type">int</span>[] nums2, <span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( i &gt;= nums1.length) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];<span class="comment">//nums1为空数组</span></span><br><span class="line">    <span class="keyword">if</span>( j &gt;= nums2.length) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];<span class="comment">//nums2为空数组</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(nums1[i], nums2[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">midVal1</span> <span class="operator">=</span> (i + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums1.length) ? nums1[i + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">midVal2</span> <span class="operator">=</span> (j + k / <span class="number">2</span> - <span class="number">1</span> &lt; nums2.length) ? nums2[j + k / <span class="number">2</span> - <span class="number">1</span>] : Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span>(midVal1 &lt; midVal2)&#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, i + k / <span class="number">2</span>, nums2, j , k - k / <span class="number">2</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findKth(nums1, i, nums2, j + k / <span class="number">2</span> , k - k / <span class="number">2</span>);</span><br><span class="line">    &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="162-寻找峰值"><a href="#162-寻找峰值" class="headerlink" title="162.寻找峰值"></a>162.寻找峰值</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724151301490.png" alt="image-20230724151301490" style="zoom: 67%;" align="left">



<p><strong>思路</strong></p>
<p>由于题目假设 <code>nums[-1] = nums[n] = -∞</code>。所以，我们可以从 0 开始往后遍历元素，如果某个元素大于其后面的元素，则该元素就是峰值元素。但是它是 O(n)，不符合题意。</p>
<p>O(logN) 一般考虑二分搜索。根据题目要求可以得到如下规律：</p>
<p>规律一：如果nums[i] &gt; nums[i+1]，则在i之前(包括i)一定存在峰值元素</p>
<p>规律二：如果nums[i] &lt; nums[i+1]，则在i+1之后一定存在峰值元素</p>
<p>为什么有以上规律？考虑具有==极大值==的连续函数。包含极大值的那一半一定有极大值。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123; <span class="comment">// 由于后面right会取到mid，则此处只能用 &lt;, 否则会死循环</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; nums[mid + <span class="number">1</span>]) right = mid; <span class="comment">// mid &gt; mid + 1，则mid处也可能为极大值，需要包含在范围内</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;<span class="comment">// mid &lt; mid + 1，则mid处不可能为极大值</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-双指针"><a href="#1-2-双指针" class="headerlink" title="1.2 双指针"></a>1.2 双指针</h3><h4 id="双指针—-快慢指针"><a href="#双指针—-快慢指针" class="headerlink" title="双指针—==快慢指针=="></a>双指针—==快慢指针==</h4><p><strong>快慢指针法</strong>：通过一个快指针和一个慢指针实现在一个循环下完成两个循环的操作</p>
<ul>
<li>快指针：负责完全遍历数组，同时查找符合要求的元素</li>
<li>慢指针：负责记录快指针查找到的元素</li>
</ul>
<h4 id="27-移除元素-单目标头部开始双指针"><a href="#27-移除元素-单目标头部开始双指针" class="headerlink" title="27.移除元素_==单目标头部开始双指针=="></a>27.移除元素_==单目标头部开始双指针==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724152158637.png" alt="image-20230724152158637" style="zoom:67%;" align="left">

<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeElement</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != val)&#123;</span><br><span class="line">                nums[slow] = nums[i];</span><br><span class="line">                slow++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="844-比较含退格的字符串-多目标尾部开始双指针"><a href="#844-比较含退格的字符串-多目标尾部开始双指针" class="headerlink" title="844.比较含退格的字符串_==多目标尾部开始双指针=="></a>844.比较含退格的字符串_==多目标尾部开始双指针==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724162006197.png" alt="image-20230724162006197" style="zoom:67%;" align="left">

<p><strong>思路</strong></p>
<p><strong>方法：双指针</strong></p>
<p><strong>引子</strong>：每个退格符#会消去其前面一个字符，我们正序遍历数组时，遍历到某个字符时并不知道其是否应该被消去，只有遍历到其后续元素为 # 时才知道结果。所以我们应该转换思路，逆序遍历数组，先得到 # ，然后遍历到正常字符时，根据 # 的数量就可得知字符此时是否需要被删除。</p>
<p><strong>具体思路</strong>：一个字符是否会被删掉，只取决于该字符后面的退格符，而与该字符前面的退格符无关。因此当我们逆序地遍历字符串，就可以立即确定当前字符是否会被删掉。</p>
<p>具体地，我们定义 skip 表示当前待删除的字符的数量。每次我们遍历到一个字符：</p>
<ul>
<li>若该字符为退格符，则我们需要多删除一个普通字符，我们让 skip 加 1；</li>
<li>若该字符为普通字符：</li>
<li>若 skip 为 0，则说明当前字符不需要删去，可以拿去比较</li>
<li>若 skip 不为 0，则说明当前字符需要删去，我们让 skip 减 1，且当前字符不能拿去比较</li>
</ul>
<p>这样，我们定义两个指针，分别指向两字符串的末尾。每次我们让两指针逆序地遍历两字符串，直到两字符串能够各自确定一个字符，然后将这两个字符进行比较。重复这一过程直到找到的两个字符不相等，或遍历完字符串为止。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">backspaceCompare</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] str_s = s.toCharArray();</span><br><span class="line">    <span class="type">char</span>[] str_t = t.toCharArray();</span><br><span class="line">    <span class="comment">//字符串数组s与t的下标，逆序开始</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index_s</span> <span class="operator">=</span> str_s.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index_t</span> <span class="operator">=</span> str_t.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//s与t的待替换字符数量</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">skip_s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">skip_t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index_s &gt;=<span class="number">0</span> || index_t &gt;=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span> (index_s &gt;=<span class="number">0</span>)&#123;<span class="comment">//找到s数组第一个可比较字符</span></span><br><span class="line">            <span class="keyword">if</span>(str_s[index_s] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; skip_s==<span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//当前字符 != #，且skip == 0，找到可比较字符，退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(str_s[index_s--] == <span class="string">&#x27;#&#x27;</span>)&#123;<span class="comment">//当前字符为#，skip+1</span></span><br><span class="line">                skip_s++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//当前字符不为#，但是skip！= 0，当前字符不能拿去比较，skip-1</span></span><br><span class="line">                skip_s --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (index_t &gt;= <span class="number">0</span>)&#123;<span class="comment">//找到t数组第一个可比较字符</span></span><br><span class="line">            <span class="keyword">if</span>(str_t[index_t] != <span class="string">&#x27;#&#x27;</span> &amp;&amp; skip_t==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(str_t[index_t--] == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                skip_t++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                skip_t --;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index_s == -<span class="number">1</span> || index_t == -<span class="number">1</span>) <span class="keyword">break</span>;<span class="comment">//若有一个字符数组已经遍历完，则退出循环</span></span><br><span class="line">        <span class="keyword">if</span>(str_s[index_s--] != str_t[index_t--])&#123;<span class="comment">//两个数组当前的可比较字符不同，直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(index_s == -<span class="number">1</span> &amp;&amp; index_t == -<span class="number">1</span>)&#123;<span class="comment">//两个数组都遍历完则说两个数组字符相同</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="977-有序数组的平方-首尾双指针"><a href="#977-有序数组的平方-首尾双指针" class="headerlink" title="977.有序数组的平方_==首尾双指针=="></a>977.有序数组的平方_==首尾双指针==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724164451313.png" alt="image-20230724164451313" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<p>方法：双指针+归并排序</p>
<p>思路：由于数组非递减且存在负数，则可将数组的数值情况分为两种情况</p>
<ol>
<li><p>全为正数或全为负数，此种情况直接取平方然后加入结果数组即可</p>
</li>
<li><p>正数负数同时存在，由于负数的平方有可能大于正数的平方，则需要找到平方值最小的值，此时我们可以</p>
<p>找到数组内部的最后一个负数，然后将数组分为两部分，正数部分和负数部分，然后使用归并排序即可</p>
</li>
</ol>
<p>tips：同时存在正负数时需要先遍历数组查找最后一个负数，然后开始归并查找新数组的元素。其实也可以不进行查找，我们可以选择逆序寻找新数组的元素，则可以直接从首尾开始归并。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortedSquares(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">// 从尾部开始查找元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt;= <span class="number">0</span> &amp;&amp; left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> nums[left] * nums[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums[right] * nums[right];</span><br><span class="line">            <span class="keyword">if</span>(a &lt; b)&#123;</span><br><span class="line">                res[index--] = b;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res[index--] = a;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-盛水最多的容器"><a href="#11-盛水最多的容器" class="headerlink" title="11.盛水最多的容器"></a>11.盛水最多的容器</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731101409345.png" alt="image-20230731101409345" style="zoom: 67%;" align="left">

<p><strong>思路</strong></p>
<p>一开始两个指针一个指向开头一个指向结尾，此时容器的底是最大的，接下来随着指针向内移动，会造成容器的底变小，在这种情况下想要让容器盛水变多，就只有在容器的高上下功夫。 那我们该如何决策哪个指针移动呢？</p>
<p>我们能够发现不管是左指针向右移动一位，还是右指针向左移动一位，容器的底都是一样的，都比原来减少了 1。这种情况下我们想要让指针移动后的容器面积增大，就要使移动后的容器的高尽量大，所以我们选择指针所指的高较小的那个指针进行移动，这样我们就保留了容器较高的那条边，放弃了较小的那条边，以获得有更高的边的机会。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> (right - left) * Math.min(height[left], height[right]);</span><br><span class="line">        max = Math.max(max, temp);</span><br><span class="line">        <span class="keyword">if</span>(height[left] &lt; height[right]) left++;</span><br><span class="line">        <span class="keyword">else</span> right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-2-滑动窗口-注意结果判断的边界情况"><a href="#1-2-滑动窗口-注意结果判断的边界情况" class="headerlink" title="1.2 滑动窗口_==注意结果判断的边界情况=="></a>1.2 滑动窗口_==注意结果判断的边界情况==</h3><h4 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    <span class="comment">// 增大窗口</span></span><br><span class="line">    window.add(nums[i]);</span><br><span class="line">    <span class="keyword">while</span>(window needs shrink)&#123;</span><br><span class="line">        <span class="comment">// 缩小窗口</span></span><br><span class="line">        window.remove(nums[left]);</span><br><span class="line">        left++;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209.长度最小的子数组"></a>209.长度最小的子数组</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724165931410.png" alt="image-20230724165931410" style="zoom: 80%;" align="left">

<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minCount</span> <span class="operator">=</span> Integer.MAX_VALUE ;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前窗口所有值之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//窗口起始指针位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;<span class="comment">//i为窗口终止位置</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span> (sum &gt;= target)&#123;<span class="comment">//窗口值大于target时，窗口需要缩小</span></span><br><span class="line">            <span class="comment">//窗口值判断为什么放在此处？</span></span><br><span class="line">            <span class="comment">//因为此时是满足&gt;target的时刻，放在sum值变化的地方不一定满足&gt;target</span></span><br><span class="line">            <span class="keyword">if</span>((i - left + <span class="number">1</span>) &lt;= minCount)&#123;<span class="comment">//记录最小的窗口值</span></span><br><span class="line">                minCount = i-left + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum -= nums[left++];<span class="comment">//通过起始指针前移来缩小窗口</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCount != Integer.MAX_VALUE?minCount:<span class="number">0</span>;<span class="comment">//若minCount值与初始值一样，说明不存在可行的窗口值</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1658-将-x-减到-0-的最小操作数"><a href="#1658-将-x-减到-0-的最小操作数" class="headerlink" title="1658.将 x 减到 0 的最小操作数"></a>1658.将 x 减到 0 的最小操作数</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230724172700117.png" alt="image-20230724172700117" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>问题转换：从数组两侧中移除和为 x 的元素，可以知道最后结果是数组中间连续的某部分元素。我们求出数组的元素和为 sum， 则连续部分的元素和一定为 sum - x。求数组连续部分和时可以想到使用滑动窗口。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minOperations</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 求出数组元素和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="comment">// 和 &lt; x，则一定无解</span></span><br><span class="line">    <span class="keyword">if</span>(sum &lt; x) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 和 == x，则移除所有元素即可</span></span><br><span class="line">    <span class="keyword">if</span>(sum == x) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 连续部分和为 target</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum - x;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 扩大窗口</span></span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; sum &gt; target)&#123;</span><br><span class="line">            <span class="comment">// 缩小窗口</span></span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == target) res = Math.max(res, i - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res == -<span class="number">1</span> ? -<span class="number">1</span> : n - res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239.滑动窗口最大值"></a>239.滑动窗口最大值</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230725104849473.png" alt="image-20230725104849473" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>滑动窗口+单调队列(可以保存值或者下标)</p>
<p>维持一个长度为 k 的滑动窗口，同时创建单调递减的单调队列，队列内保存数组元素的下标，队头元素即为当前范围内最大的数的下标，窗口缩减时，如果要缩减出窗口的left值与单调队列的队头元素相同，则窗口缩减的同时，该队头元素也需要弹出，因为该元素不在窗口内，不能进行选取。</p>
<p>示例</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]</p>
<p>解释过程中队列中都是具体的值，方便理解，具体见代码。<br>初始状态：L=R=0,队列:{}<br>i=0,nums[0]=1。队列为空,直接加入。队列：{1}<br>i=1,nums[1]=3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：{1(元素3的下标，为了便于观察，后面示例直接使用元素值来代替)}<br>i=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：{3,-1}。此时窗口已经形成，L=0,R=2，result=[3]<br>i=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]<br>i=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：{5}。此时L=2,R=4，有效。result=[3,3,5]<br>i=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：{5,3}。此时L=3,R=5，有效。result=[3,3,5,5]<br>i=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：{6}。此时L=4,R=6，有效。result=[3,3,5,5,6]<br>i=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：{7}。此时L=5,R=7，有效。result=[3,3,5,5,6,7]</p>
<blockquote>
<p>tips</p>
<ul>
<li>单调队列也可以存值，题解中存的是下标。</li>
<li>如果存值的话，每次只有新元素 <code>大于</code> 队列尾部的元素时，才去移除队列尾部的元素</li>
<li>窗口左侧移出去的元素如果等于队列头部的元素，则<code>removeFirst</code>。</li>
</ul>
<p>举个例子： <code>&quot;543321&quot; ，k=3</code></p>
<ul>
<li>队列存<code>值</code>的情况下，如果不将两个3都加入，当第一个3被移出时，会导致321的最大值变为2，因为3已经被移出了，因此存值的话，需要新的元素大于队列尾部元素再去移除队列尾部的元素。</li>
<li>队列存<code>下标</code>的情况下，就可以只存一个3（存第二个），因为通过下标就能判断出移出的是第一个3还是第二个3。</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列存下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">// 双向队列</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 结果数组下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 为了保持双向队列单调递减，当当前元素大于队尾元素时，弹出队尾元素</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()])&#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果队头的元素下标在不在窗口范围内，需要弹出</span></span><br><span class="line">	<span class="keyword">if</span>(!stack.isEmpty() &amp;&amp; i - stack.peekFirst() &gt;= k) stack.pollFirst();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;<span class="comment">// 窗口内的值已经到达上限，取最大值的同时还需要缩减窗口</span></span><br><span class="line">            <span class="comment">// 取当前窗口内的最大值</span></span><br><span class="line">            res[index++] = nums[queue.peekFirst()];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 队列存值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[i] &gt; queue.peekLast())&#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">            res[index++] = queue.peekFirst();</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == queue.peekFirst()) queue.pollFirst();</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="904-水果成篮"><a href="#904-水果成篮" class="headerlink" title="904.水果成篮"></a>904.水果成篮</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230725142354923.png" alt="image-20230725142354923" style="zoom:67%;" align="left">



<p>思路</p>
<p>题目本质: 求最多包含两个（k=2）不同字符的滑窗窗口大小<br> 方法:最大滑动窗口<br> 本算法思想概述如下：</p>
<ol>
<li>扩大窗口时，使用map保存窗口中数字(水果种类)出现的次数.</li>
<li>如果map的元素个数超过了2，则开始收缩窗口</li>
<li>==关键步骤==：直到窗口中左边开始的某个数字的个数被减少到0. 此时将该数字从map中remove，map的元素个数小于等于2，可以退出收缩流程</li>
<li>窗口缩减完符合题目要求后，可以尝试获取结果。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map存水果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">    <span class="comment">//hashmap的key为水果种类，value为出现个数</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span><span class="number">0</span>;i &lt; fruits.length;i++)&#123;<span class="comment">//i为右边界</span></span><br><span class="line">        map.put(fruits[i],map.getOrDefault(fruits[i],<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">while</span>(map.size() &gt;= <span class="number">3</span>)&#123;<span class="comment">//当不满足题目条件时开始缩紧窗口</span></span><br><span class="line">            map.put(fruits[left],map.get(fruits[left])-<span class="number">1</span>);</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">if</span>(map.get(fruits[left]) == <span class="number">0</span>) map.remove(fruits[left]);</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="comment">//当条件再次满足要求时结束缩紧过程</span></span><br><span class="line">        result = Math.max(result, count);<span class="comment">//更新结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组存水果</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalFruit</span><span class="params">(<span class="type">int</span>[] fruits)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> fruits.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">10</span>];<span class="comment">// 已经取下的水果的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 水果种类</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        f[fruits[i]]++;</span><br><span class="line">        <span class="keyword">if</span>(f[fruits[i]] == <span class="number">1</span>) total++;<span class="comment">// 水果个数刚好等于1，则种类多了一种</span></span><br><span class="line">        <span class="keyword">while</span>(total&gt; <span class="number">2</span>)&#123;<span class="comment">// 多于2种，则需要移除一种</span></span><br><span class="line">            f[fruits[left]]--;</span><br><span class="line">            <span class="keyword">if</span>(f[fruits[left]] == <span class="number">0</span>) total--;<span class="comment">// 当前水果已经完全移除，则种类数需要-1</span></span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = Math.max(res, i - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76.最小覆盖子串"></a>76.最小覆盖子串</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230725142920445.png" alt="image-20230725142920445" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<p>方法：<strong>最小滑动窗口</strong><br>思路：这道题要求我们返回 字符串 s 中包含字符串 t 的全部字符的最小窗口，我们利用滑动窗口的思想解决这个问题。<br>   因此我们需要两个哈希表，hs 哈希表维护的是 s 字符串中滑动窗口中各个字符出现多少次，ht 哈希表维护的是 t 字符串各个字符出现多少次。<br>   如果 hs 哈希表中包含 ht 哈希表中的所有字符，并且对应的个数都不小于 ht 哈希表中各个字符的个数，那么说明当前的窗口是可行的，可行中的长度最短的滑动窗口就是答案<br>步骤：</p>
<ol>
<li><p>遍历 t 字符串，用 ht 哈希表记录 t 字符串各个字符出现的次数。</p>
</li>
<li><p>定义两个指针 j 和 i，j 指针用于收缩窗口，i 指针用于延伸窗口，则区间 [j, i] 表示当前滑动窗口。首先让 i 和 j 指针都指向字符串 s 开头，然后枚举整个字符串 s ，枚举过程中，不断增加 i 使滑动窗口增大，相当于向右扩展滑动窗口。</p>
</li>
<li><p>每次向右扩展滑动窗口一步，将 s[i] 加入滑动窗口中，而新加入了 s[i]，相当于滑动窗口维护的字符数加一，即 hs[s[i]]++。</p>
</li>
<li><p>对于新加入的字符 s[i],如果 hs[s[i]] &lt;= ht[s[i]]，说明当前新加入的字符 s[i] 是必需的，且还未到达字符串 t 所要求的数量。我们还需要事先定义一个 cnt 变量， cnt 维护的是 s 字符串 [j, i] 区间中满足 t 字符串的元素的个数，记录相对应字符的总数。新加入的字符 s[i] 必需，则 cnt++。</p>
<blockquote>
<p>注意：只有hs中的字符小于ht中的个数时，才cnt++，即t中只有2个B时，s中若遍历到第三个B，不执行cnt++。即只增加有效字符个数。</p>
</blockquote>
</li>
<li><p>我们向右扩展滑动窗口的同时也不能忘记收缩滑动窗口。因此当hs[s[j]] &gt; ht[s[j]时，说明hs哈希表中s[j]的数量多于ht哈希表中s[j]的数量，此时我们就需要向右收缩滑动窗口，j++并使hs[s[j]]–，即hs[s[j++]]–。</p>
</li>
<li><p>当cnt == t.size时，说明此时滑动窗口包含符串 t 的全部字符。我们重复上述过程找到最小窗口即为答案。</p>
</li>
</ol>
<p>时间复杂度分析： 两个指针都严格递增，最多移动 n 次，所以总时间复杂度是 O(n)。</p>
<p>==优化==</p>
<blockquote>
<p>==降低时间复杂度==</p>
<p>当元素只有小写字母时，可以考虑使用 int[26] 大小的数组记录元素，操作数使用 元素 - ‘a’即可得到对应的映射值</p>
<p>当元素包含大小写字母时，可以考虑使用 int[128] 大小的数组元素记录元素，因为ASCII码的范围为128，操作时无需 - ‘a’</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存 t 中各元素个数</span></span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 窗口中保存 s 中各元素个数</span></span><br><span class="line">    <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 计算 t 中各元素个数，窗口是否缩减取决于该数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">        need[t.charAt(i)]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 已经满足 t 中元素的个数，如果count == t.length()，则可以取一次值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>, len = s.length() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);    </span><br><span class="line">        <span class="comment">// t 中包含该元素且 窗口内该元素还不满足需要的个数，则count+1</span></span><br><span class="line">        <span class="keyword">if</span>(need[c] &gt; <span class="number">0</span> &amp;&amp; window[c] &lt; need[c]) count++;</span><br><span class="line">        window[c]++;</span><br><span class="line">        <span class="comment">// 左边界缩减的条件：t中没有左边界这个元素或者左边界这个元素个数已经溢出，则缩减窗口进行删减</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; (need[s.charAt(left)] == <span class="number">0</span> || window[s.charAt(left)] &gt; need[s.charAt(left)]))&#123;</span><br><span class="line">            window[s.charAt(left)]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// count个数已经满足条件，可以取一次值</span></span><br><span class="line">        <span class="keyword">if</span>(count == t.length() &amp;&amp; i - left &lt; len)&#123;</span><br><span class="line">            begin = left;</span><br><span class="line">            len = i - left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 由于需要取最小窗口，则取完值后直接选择缩减窗口，由于左边界一定是 t 中的元素，删减掉该元素可以破坏当前解从而使窗口继续右移寻找新的解</span></span><br><span class="line">        <span class="keyword">if</span>(count == t.length())&#123;</span><br><span class="line">            window[s.charAt(left)]--;</span><br><span class="line">            left++;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len == s.length() + <span class="number">1</span> ? <span class="string">&quot;&quot;</span> : s.substring(begin, begin + len + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="comment">// 统计t中各元素个数</span></span><br><span class="line">    <span class="type">int</span>[] tArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 统计s中各元素个数</span></span><br><span class="line">    <span class="type">int</span>[] sArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];</span><br><span class="line">    <span class="comment">// 待匹配的t中元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="comment">// 计算t中各元素个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) tArr[t.charAt(i)]++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minLen</span> <span class="operator">=</span> s.length() + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">        <span class="comment">// 计算t中各元素个数</span></span><br><span class="line">        <span class="comment">// 注意：直接先加元素再检查count，则无需写上个解法里面的强行缩减左端点破坏当前解</span></span><br><span class="line">        sArr[c]++;</span><br><span class="line">        <span class="comment">// 未达到匹配字符c的个数上限，则当前元素可以抵消掉一个</span></span><br><span class="line">        <span class="keyword">if</span>(sArr[c] &lt;= tArr[c]) count--;</span><br><span class="line">        <span class="comment">// 窗口缩小：窗口左端点的元素，不属于t或者s中该元素个数多于需要的个数，则可以移出窗口</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; (tArr[s.charAt(left)] == <span class="number">0</span> || sArr[s.charAt(left)] &gt; tArr[s.charAt(left)]))&#123;</span><br><span class="line">            sArr[s.charAt(left)]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前刚好匹配到所有需要的元素且长度为当前解中最小，则可以更新解</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span> &amp;&amp; (i - left + <span class="number">1</span>) &lt; minLen)&#123;</span><br><span class="line">            res = s.substring(left, i + <span class="number">1</span>);</span><br><span class="line">            minLen = i-left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="567-字符串排列"><a href="#567-字符串排列" class="headerlink" title="567.字符串排列"></a>567.字符串排列</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230726102239300.png" alt="image-20230726102239300" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>算法思路类似上题，上题解的判断条件是有效字符的 count 刚好等于 t 的长度，由于只需要包含即可，所以选择的字符串长度可能大于 t 的长度。本题是找字符串的排列，则从 s2中 选择的字符串需要是 s1 的重排列，则需要<strong>有效字符和全部字符都需要等于 s1 的长度</strong>。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] need = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s1.length(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> s1.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        need[offset]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">countValid</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 有效字符个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">countWindow</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 窗口内元素个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length(); i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> s2.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(need[offset] &gt; <span class="number">0</span> &amp;&amp; window[offset] &lt; need[offset]) countValid++;</span><br><span class="line">        window[offset]++;</span><br><span class="line">        countWindow++;</span><br><span class="line">	<span class="comment">// 左边界缩减的条件：s1中没有左边界这个元素或者左边界这个元素个数已经溢出，则缩减窗口进行删减</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= i &amp;&amp; (need[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span> || window[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>] &gt; need[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>]))&#123;</span><br><span class="line">            window[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            countWindow--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 有效字符个数与全部字符个数都等于 s1 时找到一组排列</span></span><br><span class="line">        <span class="keyword">if</span>(countValid == s1.length() &amp;&amp; countWindow == s1.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 进入到此处，说明当前的情况是有效字符相等但是全部字符个数大于 s1，则缩减左边界继续右移求解</span></span><br><span class="line">        <span class="keyword">if</span>(countValid == s1.length())&#123;</span><br><span class="line">            window[s2.charAt(left) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            countValid--;</span><br><span class="line">            left++;</span><br><span class="line">            countWindow--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-3-1-前缀和-求任意区间的区间和"><a href="#1-3-1-前缀和-求任意区间的区间和" class="headerlink" title="1.3 - 1 前缀和_求任意区间的区间和"></a>1.3 - 1 前缀和_求任意区间的区间和</h3><h4 id="方法论-—-数组前缀和"><a href="#方法论-—-数组前缀和" class="headerlink" title="方法论 — 数组前缀和"></a>方法论 — 数组前缀和</h4><p>定义前缀和 s[0] = 0,  $s[i+1] = \sum_{j=0}^i nums[j] $<br> 例如 <code>nums=[1,2,-1,2]</code>，对应的前缀和数组为 <code>s=[0,1,3,2,4]</code><br> 通过前缀和，我们可以把子数组的和转化为两个前缀和的差值,即<br> $$\sum_{j=left}^{right}nums[j]=\sum_{j=0}^{right}nums[j]-\sum_{j=0}^{left-1}nums[j]=s[right+1]-s[left]$$</p>
<p> 例如：nums的子数组<code>[2,-1,2]</code>的和就可以用<code>s[4] - s[1] = 4-1 = 3</code>得出</p>
<p>为方便计算，使用左闭右开区间<code>[left,right)</code>表示子数组，此时子数组的和为<code>s[right]-s[left]</code>，子数组长度为<code>right - left</code></p>
<h4 id="1590-使数组和能被p整除-前缀和-哈希求两数之和-取余"><a href="#1590-使数组和能被p整除-前缀和-哈希求两数之和-取余" class="headerlink" title="1590.使数组和能被p整除_前缀和+哈希求两数之和+取余"></a>1590.使数组和能被p整除_前缀和+哈希求两数之和+取余</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727160829072.png" alt="image-20230727160829072" style="zoom:67%;" align="left">



<p><strong>思路 — 前缀和 + 哈希表(同两数之和用法)</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727161001712.png" alt="image-20230727161001712" style="zoom: 80%;">

<p>我们使用前缀和数组来计算区间和，我们记一个前缀和区间为[a, b]</p>
<p>则有 (sum - (b - a)) % p = 0，结合上述知识点：</p>
<p>sum % p - b % p + a %p= 0</p>
<p>(b - sum) % p = a % p</p>
<p>(b - sum + p) % p = a % p</p>
<p>我们在计算前缀和时可以直接对得到的值进行 %p 处理</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 计算前缀和，同时进行取模处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) preSum[i] = (preSum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>]) % p;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> preSum[n];</span><br><span class="line">    <span class="comment">// 如果数组和能够整除 p，则不需要去除元素</span></span><br><span class="line">    <span class="keyword">if</span>(sum ==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 记录遍历过的前缀和</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="comment">// 我们从前往后遍历前缀和数组，存入 i 的前缀和时，其前面位置的前缀和都已经存入，可以计算区间和</span></span><br><span class="line">        map.put(preSum[i], i);</span><br><span class="line">        <span class="comment">// 寻找前面存入的前缀和的值是否满足条件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (preSum[i] - sum + p) % p;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(a))&#123;</span><br><span class="line">            <span class="comment">// 更新最短数组长度</span></span><br><span class="line">            res = Math.min(res, i - map.get(a));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == n ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1139-最大的以1为边界的正方形-—-二维前缀和-二位数组对每行每列求前缀和"><a href="#1139-最大的以1为边界的正方形-—-二维前缀和-二位数组对每行每列求前缀和" class="headerlink" title="1139.最大的以1为边界的正方形 — ==二维前缀和==(二位数组对每行每列求前缀和)"></a>1139.最大的以1为边界的正方形 — ==二维前缀和==(二位数组对每行每列求前缀和)</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727174554748.png" alt="image-20230727174554748" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<p>计算每行前缀和<code>rs[cLen] [rLen + 1]</code>与每列前缀和<code>cs[rLen] [rLen + 1]</code></p>
<p>每行前缀和计算方式与普通数组前缀和一样，<code>preRow[i][j + 1] = preRow[i][j] + grid[i][j]</code></p>
<p>每列前缀和计算时列和行位置相反，需要注意：<code>preCol[j][i + 1] = preCol[j][i] + grid[i][j]</code></p>
<p>计算时可以枚举正方形边长d和左上角坐标(i, j)，如果前缀和的差为d，则可知为连续的1</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728110849199.png" alt="image-20230728110849199"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] preRow = <span class="keyword">new</span> <span class="title class_">int</span>[m][n + <span class="number">1</span>];<span class="comment">// 每行前缀和</span></span><br><span class="line">        <span class="type">int</span>[][] preCol = <span class="keyword">new</span> <span class="title class_">int</span>[n][m + <span class="number">1</span>];<span class="comment">// 每列前缀和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                preRow[i][j + <span class="number">1</span>] = preRow[i][j] + grid[i][j];</span><br><span class="line">                preCol[j][i + <span class="number">1</span>] = preCol[j][i] + grid[i][j];<span class="comment">// 注意每列前缀和的计算方式</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> Math.max(m, n); d &gt; <span class="number">0</span>; d--)&#123;<span class="comment">// 从大到小枚举正方形边长d，可以节省计算下标差的过程</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m - d; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n - d; j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(preRow[i][j + d] - preRow[i][j] == d &amp;&amp; <span class="comment">// 正方形上边有连续d个1</span></span><br><span class="line">                    preRow[i + d - <span class="number">1</span>][j + d] - preRow[i + d - <span class="number">1</span>][j] == d &amp;&amp; <span class="comment">// 正方形下边连续 d 个 1</span></span><br><span class="line">                    preCol[j][i + d] - preCol[j][i] == d &amp;&amp; <span class="comment">// 正方形左边连续 d 个 1</span></span><br><span class="line">                    preCol[j + d - <span class="number">1</span>][i + d] - preCol[j + d - <span class="number">1</span>][i] == d)&#123;<span class="comment">// 正方形右边连续 d 个 1</span></span><br><span class="line">                        <span class="keyword">return</span> d * d;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="304-二维区域和检索-—-矩阵前缀和-原点到当前位置的子矩阵和"><a href="#304-二维区域和检索-—-矩阵前缀和-原点到当前位置的子矩阵和" class="headerlink" title="304.二维区域和检索 — ==矩阵前缀和==(原点到当前位置的子矩阵和)"></a>304.二维区域和检索 — ==矩阵前缀和==(原点到当前位置的子矩阵和)</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727171747918.png" alt="image-20230727171747918" style="zoom: 80%;" align="left">

<p><strong>思路</strong></p>
<p>任意子矩阵的元素和都可以转化为期周边几个大矩阵的元素和的运算</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727173410056.png" alt="image-20230727173410056" style="zoom: 80%;" align="left">

<p>上述四个大矩阵有一个共同点，其左上角都是(0, 0)原点</p>
<p>因此可以维护一个二维<code>preSum</code>数组,用于记录以原点为顶点的矩阵元素和</p>
<p><code>preSum[i][j] =preSum[i-1][j] + preSum[i][j-1] + matrix[i - 1][j - 1] - preSum[i-1][j-1] </code></p>
<p>从而计算子矩阵[x1, y1, x2, y2]的元素和时，可以使用</p>
<p><code> preSum[x2+1][y2+1] - preSum[x1][y2+1] - preSum[x2+1][y1] + preSum[x1][y1]</code></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] prefixSum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        prefixSum = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                prefixSum[i][j] = prefixSum[i - <span class="number">1</span>][j] + prefixSum[i][j - <span class="number">1</span>] + matrix[i - <span class="number">1</span>][j - <span class="number">1</span>] - prefixSum[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefixSum[row2 + <span class="number">1</span>][col2 + <span class="number">1</span>] - prefixSum[row1][col2 + <span class="number">1</span>] - prefixSum[row2 + <span class="number">1</span>][col1] + prefixSum[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="528-按权重随机选择-—-前缀和-二分查找"><a href="#528-按权重随机选择-—-前缀和-二分查找" class="headerlink" title="528.按权重随机选择 — 前缀和+ 二分查找"></a>528.按权重随机选择 — 前缀和+ 二分查找</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728145443904.png" alt="image-20230728145443904"></p>
<p><strong>思路</strong></p>
<p>假设输入的权重数组是 <code>w = [1,3,2,1]</code>，我们想让概率符合权重，那么可以抽象一下，根据权重画出这么一条彩色的线段：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728145639552.png" alt="image-20230728145639552" style="zoom: 67%;" align="left">

<p>如果在线段上面随机丢一个石子，石子落在哪个颜色上，就选择该颜色对应的权重索引，那么每个索引被选中的概率是不是就是和权重相关联了？</p>
<p><strong>所以，再仔细看看这条彩色的线段像什么？这不就是 前缀和数组</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728145749438.png" alt="image-20230728145749438" style="zoom:67%;" align="left">

<p>那么接下来，如何模拟在线段上扔石子？</p>
<p>当然是随机数，比如上述前缀和数组 <code>preSum</code>，取值范围是 <code>[1, 7]</code>，那么我生成一个在这个区间的随机数 <code>target = 5</code>，就好像在这条线段中随机扔了一颗石子：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728145818110.png" alt="image-20230728145818110" style="zoom:67%;" align="left">

<p>但是，<code>preSum</code> 中并没有 5 这个元素，我们应该选择比 5 大的最小元素，也就是 6，即 <code>preSum</code> 数组的索引 3：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728145903371.png" alt="image-20230728145903371" style="zoom:67%;" align="left">



<p>**如何快速寻找数组中大于等于目标值的最小元素？==二分查找==**。</p>
<p>思路总结：</p>
<p>1、根据权重数组 <code>w</code> 生成前缀和数组 <code>preSum</code>。</p>
<p>2、生成一个取值在 <code>1 ~ preSum[n - 1]</code> 之内的随机数，用二分搜索算法寻找大于等于这个随机数的最小元素索引。</p>
<p>3、最后对这个索引减一（<strong>因为前缀和数组有一位索引偏移</strong>），就可以作为权重数组的索引，即最终答案</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230728150121679.png" alt="image-20230728150121679" style="zoom:67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preSum;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Solution</span><span class="params">(<span class="type">int</span>[] w)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;</span><br><span class="line">        <span class="comment">// 构建前缀和数组，偏移一位留给 preSum[0]</span></span><br><span class="line">        preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// preSum[i] = sum(w[0..i-1])</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= w.length; i++)&#123;</span><br><span class="line">            preSum[i] = preSum[i - <span class="number">1</span>] + w[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pickIndex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> preSum.length;</span><br><span class="line">        <span class="comment">// Java 的 nextInt(n) 方法在 [0, n) 中生成一个随机整数</span></span><br><span class="line">        <span class="comment">// 再 +1 就是在闭区间 [1, preSum[n - 1]] 中随机选择一个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> random.nextInt(preSum[n - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 在preSum中二分搜索查找 &gt;= target的第一个数</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(preSum[mid] &gt;= target) right = mid - <span class="number">1</span>; <span class="comment">// 关键</span></span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到结果是前缀数组preSum的left，其对应原数组left-1位置的元素所在的前缀和</span></span><br><span class="line">        <span class="keyword">return</span> left - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-2-树状数组-—-求可变数组的区间和"><a href="#1-3-2-树状数组-—-求可变数组的区间和" class="headerlink" title="1.3 - 2 树状数组 — 求可变数组的区间和"></a>1.3 - 2 树状数组 — 求可变数组的区间和</h3><p><strong>307.区间和检索-数组可修改</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231113203854714.png" alt="image-20231113203854714" style="zoom:50%;" align="left">



<p><strong>树状数组介绍</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&vd_source=851bf07ef96955328c75d8f49aaac017">五分钟丝滑动画讲解 | 树状数组_哔哩哔哩_bilibili</a></p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/range-sum-query-mutable/solutions/1393053/-by-hu-ge-8-t4rn/?envType=daily-question&envId=2023-11-13">307. 区域和检索 - 数组可修改 - 力扣（LeetCode）</a></p>
<p>大概思路：将原数组划分为2的幂个数的区间，添加或修改元素时使用 x += lowBit(x) 找到x所在的向上一个区间来修改该元素的区间和的值，求和时使用 x -= lowBit(x) 找到 x 所在区间的后一个区间</p>
<p>插入或修改的查找过程如下：</p>
<p>1.插入n1，通过 x += lowBit(x) 找到四个区域包含该值，从而进行修改</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231113205348223.png" alt="image-20231113205348223" style="zoom:33%;" align="left">

<p>2.插入n2，n3同理</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231113205454697.png" alt="image-20231113205454697" style="zoom:33%;" align="left">



<p>查询树状数组区间的过程如下：可以通过此过程进行求区间和</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231113205707248.png" alt="image-20231113205707248" style="zoom: 50%;" align="left">



<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 累加和</span></span><br><span class="line"><span class="type">int</span>[] sums;</span><br><span class="line"><span class="comment">// 更新后数组</span></span><br><span class="line"><span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">// 原数组长度+1, +1的原因是计算lowbit时,使用下标0会进入死循环</span></span><br><span class="line">    <span class="built_in">this</span>.sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化累加和数组</span></span><br><span class="line">        insert(i, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 插入数字,初始化</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// 下标+1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; sums.length) &#123;</span><br><span class="line">        <span class="comment">// 将包含 x 位置的区间全部加上对应的值</span></span><br><span class="line">        sums[x] = sums[x] + val;</span><br><span class="line">        <span class="comment">// 找到下一个包含该区间的值</span></span><br><span class="line">        x += lowBit(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 计算lowBit</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">lowBit</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新数组以及累加和</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &lt; sums.length) &#123;</span><br><span class="line">        <span class="comment">// 减去之前nums[index]的值, 加上新的值</span></span><br><span class="line">        sums[x] = sums[x] - nums[index] + val;</span><br><span class="line">        x += lowBit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    nums[index] = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> query(right + <span class="number">1</span>) - query(left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 查询树状数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">query</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 例如查询 x = 7，查找到的区间分别为 nums[7](只包含7位置的数), nums[6](包含5,6位置的数),nums[4](包含1,2,3,4位置的数)</span></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">        s += sums[x];</span><br><span class="line">        x -= lowBit(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-3-3-线段树"><a href="#1-3-3-线段树" class="headerlink" title="1.3-3 线段树"></a>1.3-3 线段树</h3><h3 id="1-3-总结"><a href="#1-3-总结" class="headerlink" title="1.3 - 总结"></a>1.3 - 总结</h3><p>针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：</p>
<p>1.数组<strong>不变</strong>，求区间和：「前缀和」、「树状数组」、「线段树」<br>2.多次修改<strong>某个数</strong>（单点），求区间和：「树状数组」、「线段树」<br>3.多次修改某个区间，输出最终结果：「差分」<br>4.多次修改<strong>某个区间</strong>，求区间和：「线段树」、「树状数组」（看修改区间范围大小）<br>5.多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）</p>
<p>这样看来，「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？</p>
<p>答案并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。</p>
<p>因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。</p>
<p><strong>总结一下，我们应该按这样的优先级进行考虑：</strong></p>
<p>1.简单求区间和，用「前缀和」<br>2.多次将某个区间变成同一个数，用「线段树」<br>3.其他情况，用「树状数组」</p>
<h3 id="1-4-差分-—-对数组连续区间同时进行增减"><a href="#1-4-差分-—-对数组连续区间同时进行增减" class="headerlink" title="1.4 差分 — 对数组连续区间同时进行增减"></a>1.4 差分 — 对数组连续区间同时进行增减</h3><h4 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h4><blockquote>
<p>差分数组的主要适用场景是<strong>频繁对原始数组的某个区间的元素进行增减</strong>。</p>
</blockquote>
<p>比如说，输入一个数组 <code>nums</code>，要求给区间 <code>nums[2..6]</code> 全部加 1，再给 <code>nums[3..9]</code> 全部减 3，再给 <code>nums[0..4]</code> 全部加 2，再给…，最后问 <code>nums</code> 数组的值是什么？</p>
<p>这里就需要差分数组的技巧，类似前缀和技巧构造的 <code>prefix</code> 数组，我们先对 <code>nums</code> 数组构造一个 <code>diff</code> 差分数组，**<code>diff[i]</code> 就是 <code>nums[i]</code> 和 <code>nums[i-1]</code> 之差**：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造差分数组</span></span><br><span class="line"><span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">    diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730141847620.png" alt="image-20230730141847620" style="zoom:50%;" align="left">

<p>由差分数组反推出原始数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[diff.length];</span><br><span class="line"><span class="comment">// 根据差分数组构造结果数组</span></span><br><span class="line">res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">    res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>差分数组的主要功能：<strong>要对区间nums[i, j]的元素全部加3，则只需要时 diff[i] += 3, diff[j + 1] -= 3，然后使用差分数组反推出原始数组即可。</strong></p>
<p>原理很简单，回想 <code>diff</code> 数组反推 <code>nums</code> 数组的过程，<code>diff[i] += 3</code> 意味着给 <code>nums[i..n]</code> 所有的元素都加了 3，然后 <code>diff[j+1] -= 3</code> 又意味着对于 <code>nums[j+1..n]</code> 所有元素再减 3，那综合起来，是不是就是对 <code>nums[i..j]</code> 中的所有元素都加 3。</p>
<h4 id="航班预定统计-—-差分数组的应用"><a href="#航班预定统计-—-差分数组的应用" class="headerlink" title="航班预定统计 — 差分数组的应用"></a>航班预定统计 — 差分数组的应用</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730143300649.png" alt="image-20230730143300649" style="zoom: 80%;" align="left">

<p><strong>思路</strong></p>
<p>注意到一个==预订记录==实际上代表了一个==区间的增量==。我们的任务是将这些增量叠加得到答案。因此，我们可以使用差分解决本题。</p>
<p>差分数组对应的概念是前缀和数组，对于数组 [1,2,2,4|，其差分数组为 [1,1,0,2]，差分数组的第 i 个数即为原数组的第 i-1 个元素和第 i 个元素的差值，也就是说我们对差分数组求前缀和即可得到原数组。</p>
<p>差分数组的性质是，<strong>当我们希望对原数组的某一个区间 [1,r] 施加一个增量 inc 时，差分数组 d 对应的改变是: d[l]] 增加inc，d[r+1] 减少 inc</strong>。这样对于区间的修改就变为对于两个位置的修改。并且这种修改是可以叠加的，即当我们多次对原数组的不同区间施加不同的增量，我们只要按规则修改差分数组即可。<br>在本题中，我们可以遍历给定的预定记录数组，每次 O(1) 地完成对差分数组的修改即可。当我们完成了差分数组的修改，只需要最后求出差分数组的前缀和即可得到目标数组。</p>
<p>注意本题中日期从 1 开始，因此我们需要相应的调整数组下标对应关系，对于预定记录<code>booking= [l, r, inc]</code>，我们需要让 <code>d[l-1] 增加 inc，dr 减少 inc</code>。特别地，当 r 为 n 时，我们无需修改 d[r]，因为这个位置溢出了下标范围。如果求前缀和时考虑该位置，那么该位置对应的前缀和值必定为 0。读者们可以自行思考原因，以加深对差分数组的理解。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// 构造差分数组</span></span><br><span class="line">    <span class="type">int</span>[] diff = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; bookings.length; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> bookings[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> bookings[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> bookings[i][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 航班编号从 1 开始，所以first 需要-1.同理 last + 1 变成 last</span></span><br><span class="line">        diff[first - <span class="number">1</span>] += num;</span><br><span class="line">        <span class="keyword">if</span>(last &lt; n) diff[last] -= num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 根据差分数组恢复原始数组</span></span><br><span class="line">    <span class="comment">// 差分数组的前缀和就是原始数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        res[i] = diff[i] + res[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="1-5-零散"><a href="#1-5-零散" class="headerlink" title="1.5 零散"></a>1.5 零散</h3><h4 id="915-分割数组"><a href="#915-分割数组" class="headerlink" title="915.分割数组"></a>915.分割数组</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727165410531.png" alt="image-20230727165410531" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<p>方法一：两次遍历：正序最大值+倒序最小值</p>
<blockquote>
<p>划分后的两个子数组要满足题目条件，需要保证 数组正序最大值 &lt;= 数组倒序最小值。<br>因此，我们可以先预处理数组的倒序最小值，记录在<code>min = new int[nums.length]</code>数组中<br>然后再从前往后遍历数组，维护数组前缀的最大值max，当第一次遍历到某个位置时，如果该位置的<code>max&lt;=min[i+1]</code>，那么当前位置就是划分的分界点，因为题目要求left长度尽可能小。<br>时间复杂度 O*(<em>n)，空间复杂度 O</em>(*n)。其中 <em>n</em> 为数组 <code>nums</code> 的长度。</p>
</blockquote>
<p>方法二：一次遍历</p>
<blockquote>
<p>定义三个变量</p>
<ul>
<li>leftPos：分割点</li>
<li>leftMax：左边数组目前的最大值</li>
<li>curMax：当前遍历所有元素里的最大值</li>
</ul>
<p>思路</p>
<ul>
<li>数组遍历过程中，每次都记录下标从[0~i]之间的最大值，记录在curMAx中</li>
<li>如果当前遇到的nums[i] &lt; leftMax，说明我们需要将i位置及其之前的所有元素全部划分进左边数组，此外还需要更新leftMax = curMax</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两次遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partitionDisjoint</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] min = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    min[n-<span class="number">1</span>] = nums[n-<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//预处理后缀最小值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">2</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">        min[i] = Math.min(nums[i],min[i+<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,  max = <span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="comment">//每次遍历一个都远，都记录到当前元素为止的前缀最大值</span></span><br><span class="line">        max = Math.max(max,nums[i]);</span><br><span class="line">        <span class="comment">//如果i位置的前缀最大值，恰好小于等于i+1位置的后缀最小值，则说明截止到i位置的左边部分全部小于剩下元素组成的右边部分，且此时left数组最小</span></span><br><span class="line">        <span class="keyword">if</span>(max &lt;= min[i+<span class="number">1</span>]) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">p2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">//已划分到left数组内部的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//left数组与right分割点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftPos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前遍历部分的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n-<span class="number">1</span>; ++i)&#123;</span><br><span class="line">        <span class="comment">//遍历到i时能取到的最大值</span></span><br><span class="line">        curMax = Math.max(curMax,nums[i]);</span><br><span class="line">        <span class="comment">//如果遇到比左边数组最大值要小的数，则需要将其加进left数组</span></span><br><span class="line">        <span class="keyword">if</span>(nums[i] &lt; leftMax)&#123;</span><br><span class="line">            <span class="comment">//由于要将i及其之前的元素都加入left，则leftMax也需要更新。</span></span><br><span class="line">            leftMax = curMax;</span><br><span class="line">            leftPos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> leftPos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="31-下一个排列-—-数组字典序的下一个排列"><a href="#31-下一个排列-—-数组字典序的下一个排列" class="headerlink" title="31.下一个排列 — 数组字典序的下一个排列"></a>31.下一个排列 — 数组字典序的下一个排列</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730150415377.png" alt="image-20230730150415377"></p>
<p><strong>思路</strong></p>
<p>对于一个字典序的下一个排列，我们从**右往左查找第一个 相邻升序 的元素对(i, j)**，满足<code>A[i] &lt; A[j]</code>。</p>
<p>因为对于A[i]来说，后面有大于自己的A[j]，则其一定可以通过交换A[i] 与 A[j]来得到下一个更大的序列。</p>
<p>此外，因为元素对(i, j)是从右往左找到的第一个升序对，则可得到**[j, end)一定是降序的**。</p>
<p>我们==记A[i]为我们的较小数==。</p>
<p>然后<strong>从右往左查找第一个最小的大于A[i]的数</strong>，记为我们的==较大数A[k]==。我们==交换A[i]和A[k]==。</p>
<p>可以证明<strong>此时的[j, end)仍然是降序</strong>。因为k位置是最小的大于A[i]的数，交换后，其前面仍然都是大于A[i]的数，其后面仍然是小于A[i]的数。</p>
<p><strong>为了得到字典序，我们需要使[j,end)位置保持升序，由于已知为降序，直接使用双指针依次移动来交换首尾元素即可</strong></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">nextPermutation</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 较小数的下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">small</span> <span class="operator">=</span> -<span class="number">1</span>; </span><br><span class="line">    <span class="comment">// 从右往左找到第一个升序对，记录较小数的小标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i - <span class="number">1</span>])&#123;</span><br><span class="line">            small = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果较小数下标没有改变，则说明整个数组为降序，没有升序对，直接翻转即可</span></span><br><span class="line">    <span class="keyword">if</span>(small != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">large</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="comment">// 由于[j, end)必定为降序，我们从后往前找到第一个大于较小数的数即可</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt; small; i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[small])&#123;</span><br><span class="line">                large = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换较小数与较大数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[small];</span><br><span class="line">        nums[small] = nums[large];</span><br><span class="line">        nums[large] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 翻转后面的降序数组，得到字典序数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> small + <span class="number">1</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = num;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="41-缺失的第一个正数-—-原地哈希"><a href="#41-缺失的第一个正数-—-原地哈希" class="headerlink" title="41.缺失的第一个正数 — 原地哈希"></a>41.缺失的第一个正数 — 原地哈希</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730151626182.png" alt="image-20230730151626182"></p>
<p><strong>思路</strong></p>
<p>由于题目要求我们「只能使用常数级别的空间」，而要找的数一定在 [1, N + 1] 左闭右闭（这里 N 是数组的长度）这个区间里。因此，我们可以就把原始的数组当做哈希表来使用。事实上，哈希表其实本身也是一个数组；</p>
<p>我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1；<br>那么，我们可以采取这样的思路：就把 1 这个数放到下标为 0 的位置，2 这个数放到下标为1 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。<br>这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730154822062.png" alt="image-20230730154822062"></p>
<p>时间复杂度：O(N)</p>
<p>说明：while 循环不会每一次都把数组里面的所有元素都遍历一次。如果有一些元素在这一次的循环中被交换到了它们应该在的位置，那么在后续的遍历中，由于它们已经在正确的位置上了，代码再执行到它们的时候，就会被跳过。</p>
<p>最极端的一种情况是，在第 1 个位置经过这个 while 就把所有的元素都看了一遍，这个所有的元素都被放置在它们应该在的位置，那么 for 循环后面的部分的 while 的循环体都不会被执行。</p>
<p>平均下来，每个数只需要看一次就可以了，while循环体被执行很多次的情况不会每次都发生。这样的复杂度分析的方法叫做均摊复杂度分析。</p>
<p>最后再遍历了一次数组，最坏情况下要把数组里的所有的数都看一遍，因此时间复杂度是O(N)。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 当前元素值在 [1, len + 1) 范围内，且其不在应该在的位置</span></span><br><span class="line">        <span class="keyword">while</span>(nums[i] &lt;= len &amp;&amp; nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">            nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第一个不在对应位置的元素返回</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>) <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有元素都符合要求，则说明缺失的正数为 n + 1</span></span><br><span class="line">    <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="442-数组中重复的元素-—-原地哈希"><a href="#442-数组中重复的元素-—-原地哈希" class="headerlink" title="442.数组中重复的元素 — 原地哈希"></a>442.数组中重复的元素 — 原地哈希</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730161043671.png" alt="image-20230730161043671" style="zoom:67%;" align="left">

<p><strong>思路</strong></p>
<p>根据上题的原地哈希的思路，由于给定的 n 个数都在 [1, n] 的范围内，如果有数字出现了两次，就意味着 [1, n] 中有数字没有出现过。因此，我们可以尝试将每一个数放在对应的位置。由于数组的下标范围是 [0,n-1]，我们需要将数 i 放在数组中下标为 i-1 的位置:</p>
<ul>
<li>如果 i 恰好出现了一次，那么将 i 放在数组中下标为 i-1 的位置即可;</li>
<li>如果 i 出现了两次，那么我们希望其中的一个 i 放在数组下标中为 i-1 的位置，另一个 i 放置在任意<br>「不冲突」的位置 j。也就是说，数 j+1 没有在数组中出现过。</li>
</ul>
<p>这样一来，如果我们按照上述的规则放置每一个数，那么我们只需要对数组进行一次遍历。当遍历到位置 i 时，如果nums[i] ≠ i + 1，说明 nums[i] 出现了两次(另一次出现在位置 numi] - 1 )，我们就可以将 num[i] 放入答案。<br>放置的方法也很直观: 我们对数组进行一次遍历。当遍历到位置 i 时，我们知道 nums[i] 应该被放在位置 nums[i]-1。因此我们交换 num[i] 和 nums[nums[i]-1] 即回，直到待交换的两个元素相等为止。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">            nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="448-找到数组中所有消失的数字-—-原地哈希"><a href="#448-找到数组中所有消失的数字-—-原地哈希" class="headerlink" title="448.找到数组中所有消失的数字 — 原地哈希"></a>448.找到数组中所有消失的数字 — 原地哈希</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230730161411271.png" alt="image-20230730161411271"></p>
<p><strong>思路</strong></p>
<p>根据上一题的思路，num[i] != i + 1的位置处都说明，i+1这个数字没有出现，且nums[i]处的元素都是在数组中重复出现的元素。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findDisappearedNumbers</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[nums[i] - <span class="number">1</span>] != nums[i])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">                nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">                nums[i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i + <span class="number">1</span>) res.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="43-字符串相乘"><a href="#43-字符串相乘" class="headerlink" title="43.字符串相乘"></a>43.字符串相乘</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731104258761.png" alt="image-20230731104258761"></p>
<p><strong>思路</strong></p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731105727825.png" alt="image-20230731105727825"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">multiply</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num1.equals(<span class="string">&quot;0&quot;</span>) || num2.equals(<span class="string">&quot;0&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> num1.length(), n2 = num2.length();</span><br><span class="line">    <span class="type">int</span>[] sumArr = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + n2];</span><br><span class="line">    <span class="comment">//注意：先全部计算 i + j + 1 的值，再去解决进位的问题，因为一个位置可能被多次进位，所以最后统一处理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n1 - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n2 - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a1</span> <span class="operator">=</span> num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a2</span> <span class="operator">=</span> num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a1 * a2;</span><br><span class="line">            sumArr[i + j + <span class="number">1</span>] += sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 统一处理进位问题</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n1 + n2 - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 每个位置都需要加上后面一位的进位</span></span><br><span class="line">        sumArr[i - <span class="number">1</span>] += sumArr[i] / <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 取完进位后，需要取余得到个位</span></span><br><span class="line">        sumArr[i] %= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n1 + n2; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; sumArr[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        sb.append(sumArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="581-最短无序连续子数组"><a href="#581-最短无序连续子数组" class="headerlink" title="581.最短无序连续子数组"></a>581.最短无序连续子数组</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803193348636.png" alt="image-20230803193348636" style="zoom: 80%;" align="left">



<p>思路 — 两轮遍历分别查找左右边界</p>
<p>先考虑左边界，从右往左遍历数组，同时记录已经遍历元素里的 min ，假设遍历到的 nums[i] &gt; min 则说明其后面存在比自己小的数，则从 i 开始到后面某一为止的元素都需要重新排序，此时取 left = i。如果不存在需要排序的元素，则nums[i] 不可能大于 min，因为每次遍历nums[i]都会取一次min，如果数组保持升序，则遍历时 nums[i]永远与当前min相等。因为是从右往左，最后得到的left一定是覆盖所以需要重排序元素的左边界</p>
<p>考虑右边界同理，从左往右遍历数组，同时记录已遍历元素的 max， 发现存在 nums[i] &lt; max,则说明其前面存在小于当前nums[i]的数，此时取 right = i。因为是从左往右，最后得到的right一定是覆盖索引需要重排序元素的右边界。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findUnsortedSubarray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> n - <span class="number">1</span>;<span class="comment">// 目标数组左边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 目标数组右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 从右边开始遍历，找到目标数组的左边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            min = Math.min(min, nums[i]);<span class="comment">//找到i~n-1之间的最小值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; min) left = i;<span class="comment">// 如果i处的值大于该最小值，则i处的值要参与排序</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从左边开始遍历，找到目标数组的右边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            max = Math.max(max, nums[i]);<span class="comment">// 找到0~i之间的最大值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; max) right = i;<span class="comment">// 如果i+1处的值小于该最大值，则i+1的值要参与排序</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left &gt;= right ? <span class="number">0</span> : right - left + <span class="number">1</span>;    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h2 id="2-链表专题总结"><a href="#2-链表专题总结" class="headerlink" title="2.链表专题总结"></a>2.链表专题总结</h2><h3 id="2-1-理论知识"><a href="#2-1-理论知识" class="headerlink" title="2.1 理论知识"></a>2.1 理论知识</h3><p>Java 集合可分为 Collection 和 Map 两种体系 </p>
<ul>
<li>Collection接口：单列数据，定义了存取一组对象的方法的集合<ul>
<li>List：元素有序、可重复的集合</li>
<li>Set：元素无序、不可重复的集合 </li>
</ul>
</li>
<li>Map接口：双列数据，保存具有映射关系“key-value对”的集合</li>
</ul>
<p>Collection接口继承关系如下：</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731111709311.png" alt="image-20230731111709311"></p>
<p><strong>Collection 接口：</strong></p>
<ul>
<li>Collection 接口是 List、Set 和 Queue 接口的父接口，该接口里定义的方法 既可用于操作 Set 集合，也可用于操作 List 和 Queue 集合。 </li>
<li>JDK不提供此接口的任何直接实现，而是提供更具体的子接口(如：Set和List) 实现。 </li>
<li>在 Java5 之前，Java 集合会丢失容器中所有对象的数据类型，把所有对象都 当成 Object 类型处理；从 JDK 5.0 增加了泛型以后，Java 集合可以记住容 器中对象的数据类型。</li>
</ul>
<p>Collection接口提供的方法：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731111827708.png" alt="image-20230731111827708" style="zoom:50%;" align="left">

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731111847236.png" alt="image-20230731111847236" style="zoom:50%;" align="left">



<p><strong>List接口：ArrayList是List接口的主要实现类</strong></p>
<p>List除了从Collection集合继承的方法外，List 集合里添加了一些根据索引来 操作集合元素的方法。</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731112050985.png" alt="image-20230731112050985"></p>
<p><strong>LinkedList</strong>：双向链表，内部没有声明数组，而是定义了 Node 类型的 first 和 last， 用于记录首末元素。同时，定义内部类 Node，作为LinkedList 中保存数据的基本结构。Node 除了保存数据，还定义了两个变量： prev变量记录前一个元素的位置 next变量记录下一个元素的位置</p>
<p><strong>LinkedList 常用作队列的实现之一，另外一种实现是ArrayDeque</strong></p>
<p><strong>LinkedList 接口新增方法：</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731112220147.png" alt="image-20230731112220147" style="zoom: 67%;" align="left">



<p>链表的几种类型</p>
<p>1.单链表</p>
<p>一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。链接的入口节点称为链表的头结点也就是head。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731112523466.png" alt="image-20230731112523466" style="zoom:67%;" align="left">



<p>2.双链表</p>
<p>每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。双链表 既可以向前查询也可以向后查询。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731112609783.png" alt="image-20230731112609783" style="zoom:67%;" align="left">



<p>3.循环链表</p>
<p>循环链表，顾名思义，就是链表首尾相连。循环链表可以用来解决约瑟夫环问题。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230731112658621.png" alt="image-20230731112658621" style="zoom:67%;" align="left">



<p>2.2 基本题型</p>
<h3 id="203-移除链表元素-—-虚拟头节点dummy"><a href="#203-移除链表元素-—-虚拟头节点dummy" class="headerlink" title="203.移除链表元素 — 虚拟头节点dummy"></a>203.移除链表元素 — 虚拟头节点dummy</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801121937902.png" alt="image-20230801121937902" style="zoom:67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入虚拟头结点使所有节点统一操作</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span>(dummy.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dummy.next.val == val)&#123;</span><br><span class="line">            dummy.next = dummy.next.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="206-反转整个链表-—-反转全部"><a href="#206-反转整个链表-—-反转全部" class="headerlink" title="206.反转整个链表 — 反转全部"></a>206.反转整个链表 — 反转全部</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801122809155.png" alt="image-20230801122809155"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归法</span></span><br><span class="line">ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="comment">// 在最后一个节点才会返回，即返回尾节点，然后被last接收</span></span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//// 递归中的last返回的都是链表的最后一个节点，其是结果的头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// // 开始翻转当前节点与后面一个节点的的关系</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回结果的头结点</span></span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代法 --- 头插</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">    ListNode node;</span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">null</span>)&#123;</span><br><span class="line">        node = temp.next;</span><br><span class="line"></span><br><span class="line">        temp.next = newHead.next;</span><br><span class="line">        newHead.next = temp;</span><br><span class="line"></span><br><span class="line">        temp = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="92-反转部分链表-—-反转部分"><a href="#92-反转部分链表-—-反转部分" class="headerlink" title="92.反转部分链表 — 反转部分"></a>92.反转部分链表 — 反转部分</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801125320670.png" alt="image-20230801125320670" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<p>题目翻转中间某一部分连续的节点，如果我们将要反转的第一个节点及其后面的所有节点提取出来形成一段链表，则可以看做去翻转链表的前 N 个节点</p>
<p>反转前 N 个节点代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 记录翻转部分的后驱节点，翻转完需要将其接到后面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 N 个节点， 返回新的头结点</span></span><br><span class="line">ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">// n == 1 时，后续节点都不用翻转，将其保存，同时当前节点为结果的头节点</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以 head.next 为起点， 需要反转前 n - 1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = successor; <span class="comment">// 虽然递归中间的也会执行该代码，但是只有原始链表的第一个节点会成功执行，其他的都会被后面的操作覆盖。</span></span><br><span class="line">    reutrn last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反转部分节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="comment">// left == 1，可以看做从当前节点开始，反转前 N 个节点</span></span><br><span class="line">    <span class="keyword">if</span>(left == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后移时，left 与 right 都减1，因为要保持二者的差值不变</span></span><br><span class="line">    head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转前 N 个节点</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        successor = head.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverseN(head.next, n - <span class="number">1</span>);</span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = successor;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="25-k个一组翻转链表-–-每k个反转"><a href="#25-k个一组翻转链表-–-每k个反转" class="headerlink" title="25.k个一组翻转链表 – 每k个反转"></a>25.k个一组翻转链表 – 每k个反转</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801132929823.png" alt="image-20230801132929823" style="zoom: 67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    ListNode a, b;</span><br><span class="line">    a = head;</span><br><span class="line">    b = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 反转 [a, b)</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">    <span class="comment">// 反转 [a, b) 后，a节点为尾部节点，所以后续节点接到a后面</span></span><br><span class="line">    a.next = reverseKGroup(b, k);</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转已知首尾节点的链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode a, ListNode b)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == b || a.next == b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">last</span> <span class="operator">=</span> reverse(a.next, b);</span><br><span class="line">    a.next.next = a;</span><br><span class="line">    a.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="24-两两交换链表节点-—-每两个反转，-等价于上题中k-2"><a href="#24-两两交换链表节点-—-每两个反转，-等价于上题中k-2" class="headerlink" title="24.两两交换链表节点 — 每两个反转，==等价于上题中k=2=="></a>24.两两交换链表节点 — 每两个反转，==等价于上题中k=2==</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801140732990.png" alt="image-20230801140732990"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> a.next.next;</span><br><span class="line">    <span class="comment">// 反转 a -&gt; b，得到 b -&gt; a，函数返回 b节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a);</span><br><span class="line">    a.next = swapPairs(next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode a)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> a.next;</span><br><span class="line">    a.next.next = a;</span><br><span class="line">    a.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="19-删除链表的倒数第-N-个节点"><a href="#19-删除链表的倒数第-N-个节点" class="headerlink" title="19.删除链表的倒数第 N 个节点"></a>19.删除链表的倒数第 N 个节点</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801141306344.png" alt="image-20230801141306344" style="zoom:67%;" align="left">

<p><strong>思路</strong></p>
<p>双指针先后出发</p>
<p>过程：先给链表加上空白头指针dummy，指针a先走 N+1 步，然后指针b从dummy开始，指针a从当前位置开始，二者同时前进，指针a走到null时，指针b的位置即为倒数第N+1个。此时得到待删除位置的前一个节点，即可执行删除操作</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd2</span><span class="params">(ListNode head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> ||head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;<span class="comment">//无节点或只有一个节点则直接返回空</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>,head);<span class="comment">// 创建头节点</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> newHead;<span class="comment">//快指针先走n+1步</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> newHead;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">null</span>)&#123;<span class="comment">//快慢同时走，快指针走完时，慢指针的位置即为倒数第n个数的前一个</span></span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//执行删除操作</span></span><br><span class="line">    slow.next = slow.next.next;</span><br><span class="line">    <span class="keyword">return</span> newHead.next;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="面试题02-07-链表相交-—-链表连接"><a href="#面试题02-07-链表相交-—-链表连接" class="headerlink" title="面试题02.07 链表相交 — 链表连接"></a>面试题02.07 链表相交 — 链表连接</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801142638992.png" alt="image-20230801142638992" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>构建两个虚拟头结点<code>p1,p2</code>, 我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
<p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code></p>
<p>若没有公共部分，二者在各自遍历一次A，B之后会同时走到null处，此时循环退出。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230801142826527.png" alt="image-20230801142826527" style="zoom:80%;" align="left">



<blockquote>
<p>注意：while内部一定要先判断null，再取next，否则不会出现二者同时取null的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (p1 != p2) &#123;<span class="comment">// 没有交点时，p1和p2在某一刻会同时走到null</span></span><br><span class="line">    <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">    <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = headB;</span><br><span class="line">    <span class="keyword">else</span>            p1 = p1.next;</span><br><span class="line">    <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">    <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = headA;</span><br><span class="line">    <span class="keyword">else</span>            p2 = p2.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p1</span> <span class="operator">=</span> headA, p2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (p1 != p2) &#123;<span class="comment">// 没有交点时，p1和p2在某一刻会同时走到null</span></span><br><span class="line">        <span class="comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p1 == <span class="literal">null</span>) p1 = headB;</span><br><span class="line">        <span class="keyword">else</span>            p1 = p1.next;</span><br><span class="line">        <span class="comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span> (p2 == <span class="literal">null</span>) p2 = headA;</span><br><span class="line">        <span class="keyword">else</span>            p2 = p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="142-环形链表II-—-找环入口"><a href="#142-环形链表II-—-找环入口" class="headerlink" title="142.环形链表II — 找环入口"></a>142.环形链表II — 找环入口</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230802094554870.png" alt="image-20230802094554870" style="zoom: 67%;" align="left">



<p><strong>思路 — 快慢指针</strong></p>
<p>问题：寻找环形指针入口节点<br>方法：<strong>快慢指针</strong><br>算法流程：设两指针 fast，slow 指向链表头部 head，fast 每轮走 2 步，slow 每轮走 1 步；</p>
<ul>
<li>第一种结果：fast 指针走过链表末端，说明链表无环，直接返回 null；<br>注意：若表有环，则两指针一定会相遇，因为fast走两步，slow走一步，相当于slow静止，fast以每次一步的速度追赶slow；</li>
<li>第二种结果：当fast == slow时， 两指针在环中第一次相遇<br>步数关系分析：设环外(不计入环入口节点)长度为a，环长为b；相遇时slow走了s步，fast走了f步.则有：<pre><code>        1.由于fast的速度是slow的2倍，则：f = 2s
        2.双指针都走过 a(环外长度) 步，然后在环内绕圈(fast一直绕圈)直到重合，重合时 fast 比 slow 多走环的长度整数倍，则：f = s + nb
    得：f = 2nb ;  s = nb
</code></pre>
</li>
</ul>
<p>目前情况分析：让一个指针从head出发，当其走了k步后到达环入口，则：k=a+nb(n = 0,1,2,3…),即环外走了a步，然后每次走nb(环一圈为b)步都能到入口<br>而：slow走的步数为nb，则当slow再走a步即可到达入口，但是此时a值未知</p>
<p>方法：让一个指针从head出发，与slow以相同速度出发，二者相遇时则刚好走了a步，且刚好到达入口，返回该指针即可</p>
<p>步骤：</p>
<p>0.给环加上空头结点 dummy，创建快指针 fast 与慢指针 slow 分别都指向 dummy<br>1.循环让 fast 每次走两步，slow 每次走一步，fast 或 fast 下一个节点走到 null 则无环，否则二者一定相遇，第一次相遇时 break<br>2.新建 res 节点从 dummy 重新出发，slow 从当前位置出发，二者同时每次走一步，再次相遇时返回res 即为环入口</p>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/linked-list-cycle-ii/solution/linked-list-cycle-ii-kuai-man-zhi-zhen-shuang-zhi-/">环形链表 II（双指针法，清晰图解） - 环形链表 II - 力扣（LeetCode）</a></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    dummy.next = head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> dummy, slow = dummy;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span> || fast.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fast == slow) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="keyword">while</span>(temp != slow)&#123;</span><br><span class="line">        temp = temp.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表排序-—-归并排序"><a href="#链表排序-—-归并排序" class="headerlink" title="链表排序 — 归并排序"></a>链表排序 — 归并排序</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230802103304314.png" alt="image-20230802103304314" style="zoom:67%;" align="left">

<p>思路 — 递归归并排序</p>
<p>先将当前链表分割，从中间节点处将链表分为两半，然后对左右两半继续递归当前函数，拿到排序后的两条链表，然后进行有序链表的合并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fast取head时会栈溢出</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">    <span class="comment">// 找到链表的中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast!= <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将链表拆成两半</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 左右继续递归</span></span><br><span class="line">    <span class="comment">// 注意：此处使用head接收left 和 temp接收right会超时，问题不明</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(temp);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val)&#123;</span><br><span class="line">            h.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="23-合并-k-个链表"><a href="#23-合并-k-个链表" class="headerlink" title="23.合并 k 个链表"></a>23.合并 k 个链表</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230802110525030.png" alt="image-20230802110525030" style="zoom:80%;" align="left">

<p>方法一：分治归并 — 时间复杂度O(nklogk)，空间复杂度O(logk)</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230802112245605.png" alt="image-20230802112245605" style="zoom:67%;" align="left">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeK(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeK</span><span class="params">(ListNode[] lists, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> mergeK(lists, left, mid);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> mergeK(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> mergeTwo(leftNode, rightNode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwo</span><span class="params">(ListNode left, ListNode right)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> pre;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left.val &lt;= right.val)&#123;</span><br><span class="line">            pre.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre.next = left != <span class="literal">null</span>? left :right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二：使用优先队列保存每条链表头结点 — 时间复杂度O(nklogk)，空间复杂度O(k)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    PriorityQueue&lt;ListNode&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a.val - b.val);</span><br><span class="line">    <span class="comment">// 将每一路第一个节点加入队列</span></span><br><span class="line">    <span class="keyword">for</span>(ListNode node : lists)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)pq.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> res;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="comment">// 小根堆堆顶为堆中最小元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        pre.next = node;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">        <span class="comment">// 将选中元素所在路的下一个元素加入队列</span></span><br><span class="line">        node = node.next;</span><br><span class="line">        <span class="keyword">if</span>(node != <span class="literal">null</span>)pq.offer(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-二叉树专题总结"><a href="#3-二叉树专题总结" class="headerlink" title="3.二叉树专题总结"></a>3.二叉树专题总结</h2><h3 id="方法论-两个数组保存不含重复元素的普通二叉树"><a href="#方法论-两个数组保存不含重复元素的普通二叉树" class="headerlink" title="方法论-两个数组保存不含重复元素的普通二叉树"></a>方法论-两个数组保存不含重复元素的普通二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建两个数组保存左右子树的值，下标为父节点</span></span><br><span class="line">    <span class="type">int</span>[] l = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span>[] r = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">100</span>];</span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">6</span>&#125;);</span><br><span class="line">    list.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">7</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] node : list)&#123;</span><br><span class="line">        add(node[<span class="number">0</span>], node[<span class="number">1</span>], l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; pre = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(<span class="number">1</span>, pre, l, r);</span><br><span class="line"></span><br><span class="line">    System.out.println(pre.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> fa, <span class="type">int</span> son, <span class="type">int</span>[] l, <span class="type">int</span>[] r)</span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span>(l[fa] == <span class="number">0</span>) l[fa] = son;</span><br><span class="line">    <span class="keyword">else</span> r[fa] = son;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="0-二叉树解题思维模式"><a href="#0-二叉树解题思维模式" class="headerlink" title="==0.二叉树解题思维模式=="></a>==0.二叉树解题思维模式==</h3><ol>
<li><p>遍历</p>
<blockquote>
<p><strong>是否可以通过遍历一遍二叉树得到答案</strong>，如果可以，用一个无返回值的<code>traverse</code>函数配合外部变量来实现</p>
</blockquote>
</li>
<li><p>分解问题</p>
<blockquote>
<p><strong>是否可以通过定义一个递归函数，通过子问题(子树)的答案推导出原问题的答案</strong>，如果可以，写出递归函数的定义，并充分利用函数的返回值。</p>
</blockquote>
</li>
</ol>
<p>无论使用哪种思维模式，都需要考虑：</p>
<p><strong>如果单独抽出一个二叉树节点，它需要做什么事情？需要在什么时候(前/ 中/ 后序位置)做？</strong>其他结点无需操心，递归函数会在所有的节点上执行相同的操作。</p>
<p>举例：</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230515104503192.png" alt="image-20230515104503192"></p>
<p>分解子问题解法 — 利用函数返回值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span>  invertTree(root.left);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    root.left = leftNode;</span><br><span class="line">    root.right = rightNode;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历解法 — 无返回值，直接在节点上操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数虽然有返回值，但是是为了最终的结果返回与作为递归出口，递归过程中并没有使用返回值</span></span><br><span class="line"><span class="comment">// 先序遍历，先操作节点，再递归左右节点</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line"></span><br><span class="line">    invertTree(root.left);</span><br><span class="line">    invertTree(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更直观的不使用返回值</span></span><br><span class="line"><span class="comment">// 后序遍历，先递归左右节点，再操作节点</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    traverse(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="1-二叉树的递归与非递归遍历"><a href="#1-二叉树的递归与非递归遍历" class="headerlink" title="1. 二叉树的递归与非递归遍历"></a>1. 二叉树的递归与非递归遍历</h3><h3 id="1-1-先序遍历-—-借助栈"><a href="#1-1-先序遍历-—-借助栈" class="headerlink" title="1.1 先序遍历 — 借助栈"></a>1.1 先序遍历 — 借助栈</h3><blockquote>
<p>步骤：</p>
<ol>
<li>根节点入栈</li>
<li>循环执行（要求栈非空）：<ol>
<li>弹出节点并打印</li>
<li>将弹出节点的<strong>右节点</strong>（若存在）入栈</li>
<li>将弹出节点的<strong>左节点</strong>（若存在）入栈</li>
</ol>
</li>
</ol>
<p>为什么先右后左：假设只有三个结点，先输出了头结点，由于我们使用栈存储结点，只有先存右节点再存左结点，才能先输出左节点。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">preOrderUnRecur</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.push(head);<span class="comment">//根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        head = stack.pop();<span class="comment">//弹出栈顶节点</span></span><br><span class="line">        System.out.println(head.value);<span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">if</span>(head.right != <span class="literal">null</span>) stack.push(head.right);<span class="comment">//右节点（若存在）入栈</span></span><br><span class="line">        <span class="keyword">if</span>(head.left != <span class="literal">null</span>) stack.push(head.left);<span class="comment">//左节点（若存在）入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-2-后序遍历-—-借助栈"><a href="#1-2-后序遍历-—-借助栈" class="headerlink" title="1.2 后序遍历 — 借助栈"></a>1.2 后序遍历 — 借助栈</h3><blockquote>
<p>步骤：</p>
<ol>
<li><p>建立两个栈，根节点入栈1</p>
</li>
<li><p>循环执行（要求栈非空）：</p>
<ol>
<li>弹出栈1顶节点压入栈2</li>
<li>将弹出节点的左节点（若存在）入栈1</li>
<li>将弹出节点的右节点（若存在）入栈1</li>
</ol>
<p>为什么先左后右：由于我们是先入栈 1 再入栈 2。 头先进栈2，然后左右进栈1，然后按右左进栈2。栈2中顺序就是头右左。从头部输出就是左右头。</p>
</li>
<li><p>依次弹出栈2的结点，即为后序遍历</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">posOrderUnRecur</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Deque&lt;Node&gt; stack1 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;Node&gt; stack2 = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack1.push(head);</span><br><span class="line">    <span class="keyword">while</span>(!stack1.isEmpty())&#123;</span><br><span class="line">        head = stack1.pop();</span><br><span class="line">        stack2.push(head);</span><br><span class="line">        <span class="keyword">if</span>(head.left != <span class="literal">null</span>) stack1.push(head.left);</span><br><span class="line">        <span class="keyword">if</span>(head.right != <span class="literal">null</span>) stack1.push(head.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack2.isEmpty())&#123;</span><br><span class="line">        System.out.println(stack2.pop().value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-3-中序遍历-—-借助栈"><a href="#1-3-中序遍历-—-借助栈" class="headerlink" title="1.3 中序遍历 — 借助栈"></a>1.3 中序遍历 — 借助栈</h3><blockquote>
<p>步骤：</p>
<ol>
<li>根节点及其左节点全部入栈，直到为null</li>
<li>弹出栈顶节点并打印</li>
<li>将弹出节点的右节点及其所有左节点全部入栈</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">inOrderUnRecur</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Deque&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//由于stack创建时无元素，需要加入head ！= null让循环第一次成功进入</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() || head != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="literal">null</span>)&#123;<span class="comment">//从根节点开始，左节点全部进栈</span></span><br><span class="line">            stack.push(head);</span><br><span class="line">            head = head.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            System.out.println(head.value);</span><br><span class="line">            head = head.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1-4-层序遍历-—-借助队列"><a href="#1-4-层序遍历-—-借助队列" class="headerlink" title="1.4 层序遍历 — 借助队列"></a>1.4 层序遍历 — 借助队列</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归-层序遍历-使用一个list保存所有数据-一层while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrderInOne</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        head = queue.poll();</span><br><span class="line">        list.add(head.value);</span><br><span class="line">        <span class="keyword">if</span>(head.left != <span class="literal">null</span>) queue.offer(head.left);</span><br><span class="line">        <span class="keyword">if</span>(head.right != <span class="literal">null</span>) queue.offer(head.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归-层序遍历-每行分别使用一个list保存-两层while</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrderInmore</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(head);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();<span class="comment">//记录当前层的节点数</span></span><br><span class="line">        <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            head = queue.poll();</span><br><span class="line">            itemList.add(head.value);</span><br><span class="line">            <span class="keyword">if</span>(head.left != <span class="literal">null</span>) queue.offer(head.left);</span><br><span class="line">            <span class="keyword">if</span>(head.right != <span class="literal">null</span>) queue.offer(head.right);</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(itemList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归写法</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="comment">// root视为第0层</span></span><br><span class="line">    traverse(root, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 前序位置， 看看是否已经存储 depth 层的节点</span></span><br><span class="line">    <span class="keyword">if</span>(res.size() &lt;= depth)&#123;</span><br><span class="line">        <span class="comment">// 第一次进入depth层</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置，在depth层添加 root 节点的值</span></span><br><span class="line">    res.get(depth).add(root.val);</span><br><span class="line">    traverse(root.left, depth + <span class="number">1</span>);</span><br><span class="line">    traverse(root.right, depth + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-先序递归-dfs-解决问题"><a href="#2-先序递归-dfs-解决问题" class="headerlink" title="2.先序递归(dfs)解决问题"></a>2.先序递归(dfs)解决问题</h3><p>模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,<span class="type">int</span> deep)</span>&#123;</span><br><span class="line">	<span class="comment">// 递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对符合条件的结点操作</span></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; ......)&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 然后递归操作左右结点</span></span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>) dfs(root.left,deep+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>) dfs(root.right,deep+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归先序遍历交换子节点</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="comment">// 交换当前结点的左右结点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 操作左右子节点</span></span><br><span class="line">    invertTree1(root.left);</span><br><span class="line">    invertTree1(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的所有路径"><a href="#二叉树的所有路径" class="headerlink" title="二叉树的所有路径"></a>二叉树的所有路径</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240301205551559.png" alt="image-20240301205551559" style="zoom:50%;" align="left">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root,String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历的普通操作当前结点</span></span><br><span class="line">    str  = str+root.val;</span><br><span class="line">    <span class="comment">// dfs找到符合结点</span></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)&#123;</span><br><span class="line">        list.add(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="literal">null</span>) dfs(root.left,str+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="literal">null</span>) dfs(root.right,str+<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="3-后序递归解决问题"><a href="#3-后序递归解决问题" class="headerlink" title="3. 后序递归解决问题"></a>3. 后序递归解决问题</h3><h3 id="平衡二叉树-—-重点"><a href="#平衡二叉树-—-重点" class="headerlink" title="平衡二叉树 — 重点"></a>平衡二叉树 — 重点</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230309112620744.png" alt="image-20230309112620744"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">方法：使用递归后序遍历，若某棵树不为平衡二叉树则返回-1，否则返回该树的最大高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> depth(root) == -<span class="number">1</span>? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -1 表示已经不是平衡二叉树了，否则返回值是以该节点为根节点树的高度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得左树的高度时先判断其是否平衡，若不平衡则直接返回-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftDepth</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="keyword">if</span>(leftDepth == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得右树的高度时先判断其是否平衡，若不平衡则直接返回-1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightDepth</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    <span class="keyword">if</span>(rightDepth == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右子树都平衡时，当前树的高度才有意义</span></span><br><span class="line">    <span class="keyword">return</span> Math.abs(leftDepth - rightDepth) &gt; <span class="number">2</span> ? -<span class="number">1</span> : Math.max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="完全二叉树结点个数"><a href="#完全二叉树结点个数" class="headerlink" title="完全二叉树结点个数"></a>完全二叉树结点个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归写法：使用后序遍历先得到左右子树的节点个数，再加上根节点即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到左子树节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftNodes</span> <span class="operator">=</span> countNodes(root.left);</span><br><span class="line">    <span class="comment">//得到右子树节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rightNodes</span> <span class="operator">=</span> countNodes(root.right);</span><br><span class="line">    <span class="comment">//当前树的总节点个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">treeNodes</span> <span class="operator">=</span> leftNodes + rightNodes + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> treeNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>二叉树最大直径</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230503164356316.png" alt="image-20230503164356316" style="zoom:50%;" align="left">

<p>先序遍历解法</p>
<blockquote>
<p>先序遍历递归到每个节点时都需要计算当前节点为根节点的最大直径，自顶向下递归的存在大量重复计算，最坏时间复杂度为o(n^2)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(rootDep(root), Math.max(diameterOfBinaryTree(root.left), diameterOfBinaryTree(root.right)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rootDep</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> maxDep(root.left) + maxDep(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDep</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDep</span> <span class="operator">=</span> maxDep(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDep</span> <span class="operator">=</span> maxDep(root.right);</span><br></pre></td></tr></table></figure>



<p>后序遍历解法</p>
<blockquote>
<p>后序遍历为自底向上遍历，每个节点的计算只进行一次</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">maxDia</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDep(root);</span><br><span class="line">        <span class="keyword">return</span> maxDia;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDep</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 计算左右子节点的高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftDep</span> <span class="operator">=</span> maxDep(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightDep</span> <span class="operator">=</span> maxDep(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取子节点的高度后，可以顺便获得以当前节点为根节点的最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curDia</span> <span class="operator">=</span> leftDep + rightDep;</span><br><span class="line">        maxDia = Math.max(maxDia, curDia);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDep, rightDep) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="4-多树递归"><a href="#4-多树递归" class="headerlink" title="4.多树递归"></a>4.多树递归</h3><h3 id="相同的树"><a href="#相同的树" class="headerlink" title="相同的树"></a>相同的树</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240301220557274.png" alt="image-20240301220557274" style="zoom: 50%;" align="left">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="comment">// 两个结点都为null，则相同</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 两个结点有一个为null，或都不为null但是val不同</span></span><br><span class="line">    <span class="keyword">if</span>(p== <span class="literal">null</span> || q == <span class="literal">null</span> || p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 都不为null，且值相同，继续比较左右子节点</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="另外一颗树的子树"><a href="#另外一颗树的子树" class="headerlink" title="另外一颗树的子树"></a>另外一颗树的子树</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240301220702840.png" alt="image-20240301220702840" style="zoom:80%;" align="left">

<blockquote>
<p>要判断一个树 t 是不是树 s 的子树，那么可以判断 t 是否和树 s 的任意子树相等。那么就转化成 求Same Tree。<br>即，这个题的做法就是在 s 的每个子节点上，判断该子节点是否和 t 相等。</p>
<p>判断两个树是否相等的三个条件是与的关系，即：</p>
<p>当前两个树的根节点值相等；<br>并且，s 的左子树和 t 的左子树相等；<br>并且，s 的右子树和 t 的右子树相等。<br>而判断 t 是否为 s 的子树的三个条件是或的关系，即：</p>
<p>当前两棵树相等；<br>或者，t 是 s 的左子树；<br>或者，t 是 s 的右子树。<br>判断 是否是相等的树 与 是否是子树 的代码简直是对称美啊~</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode root, TreeNode subRoot)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归到根节点都没发现相同树</span></span><br><span class="line">    <span class="keyword">if</span>(root.v == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 递归判断当前节点与其左右子节点开始的树是否与另外一个树相同</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(root, subRoot) || isSubtree(root.left,subRoot) || isSubtree(root.right, subRoot);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> &amp;&amp; q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> || q== <span class="literal">null</span> || p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240301220754128.png" alt="image-20240301220754128" style="zoom:80%;" align="left">

<blockquote>
<p>==本题与上题的区别==，B可能如果是A中间部分的相同结构也符合条件。</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">    <span class="comment">// A为空时 B一定不是其子结构，B为空时，题目说明空树不是任意子树的子结构</span></span><br><span class="line">    <span class="keyword">if</span>(A == <span class="literal">null</span> || B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 当前结点为根节点，当前结点左右子节点作为根节点，</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">    <span class="comment">// q遍历到null，则所有结点都符合</span></span><br><span class="line">    <span class="keyword">if</span>(q == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// q不为null，但q遍历到null，或 都不为null，但是值不同，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">null</span> || p.val != q.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 当前结点符合条件，开始递归比较子节点</span></span><br><span class="line">    <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230308143231443.png" alt="image-20230308143231443"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSym(root.left, root.right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSym</span><span class="params">(TreeNode node1, TreeNode node2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node1 == <span class="literal">null</span> &amp;&amp; node2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(node1.val != node2.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSym(node1.left, node2.right) &amp;&amp; isSym(node1.right, node2.left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//官方题解：非递归解法---</span></span><br><span class="line"><span class="comment">// 此解法与利用两次层序遍历类似，但是只使用一个队列来保存子节点</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(root.left);</span><br><span class="line">    que.offer(root.right);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        <span class="comment">//都空</span></span><br><span class="line">        <span class="keyword">if</span>(leftNode == <span class="literal">null</span> &amp;&amp; rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只有一个为空或者都不可但是不等</span></span><br><span class="line">        <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        que.offer(leftNode.left);</span><br><span class="line">        que.offer(rightNode.right);</span><br><span class="line">        que.offer(leftNode.right);</span><br><span class="line">        que.offer(rightNode.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips:</p>
<p>ArrayDeque：内部以数组的形式保存集合中的元素，因此随机访问元素时有较好的性能，插入删除时性能较差。<br>LinkedList：内部以双向链表的形式来保存集合中的元素，因此随机访问集合中的元素时虽然性能较差，但在插入、删除元素时性能较好。</p>
<p>我比较喜欢使用ArrayDeque或者LinkedList来模拟实现栈或者队列，但最近遇到了一个问题，在一段程序中，我使用LinkedList模拟时是正常的，使用ArrayDeque模拟会报空指针异常。<br><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230308143335007.png" alt="image-20230308143335007"></p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230308143349464.png" alt="image-20230308143349464"></p>
<p>==看了二者的源码之后，可以知道，ArrayDeque它是不允许储存null的，当我们想保存一个null时，它会抛出一个空指针异常错误，而LinkedList则不会检查是否为空。==</p>
</blockquote>
<h3 id="5-填充每一个节点的下一个右侧节点指针"><a href="#5-填充每一个节点的下一个右侧节点指针" class="headerlink" title="5.填充每一个节点的下一个右侧节点指针"></a>5.填充每一个节点的下一个右侧节点指针</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230515150706643.png" alt="image-20230515150706643"></p>
<p>常规解法 — 层序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">    Deque&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len ;i++)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur.left != <span class="literal">null</span>) queue.offer(cur.left);</span><br><span class="line">            <span class="keyword">if</span>(cur.right != <span class="literal">null</span>) queue.offer(cur.right);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归遍历解法 — 将树看成三叉树</p>
<p>常规的二叉树遍历只能将父节点的左右节点进行连接，无法连接相邻节点的两个节点</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230515151118352.png" alt="image-20230515151118352" style="zoom:50%;" align="left">



<p><strong>传统的 <code>traverse</code> 函数是遍历二叉树的所有节点，但现在我们想遍历的其实是两个相邻节点之间的「空隙」</strong>。</p>
<p>所以我们可以在二叉树的基础上进行抽象，你把图中的每一个方框看做一个节点：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/3.png" alt="img" style="zoom: 33%;" align="left">

<p><strong>这样，一棵二叉树被抽象成了一棵三叉树，三叉树上的每个节点就是原先二叉树的两个相邻节点</strong>。</p>
<p>现在，我们只要实现一个 <code>traverse</code> 函数来遍历这棵三叉树，每个「三叉树节点」需要做的事就是把自己内部的两个二叉树节点穿起来。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Node <span class="title function_">connect</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 遍历三叉树，连接相邻节点</span></span><br><span class="line">    tarverse(root.left, root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tarverse</span><span class="params">(Node node1, Node node2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 前序位置</span></span><br><span class="line">    <span class="comment">// 将传入的两个节点连接</span></span><br><span class="line">    node1.next = node2;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 连接相同父节点的两个子节点</span></span><br><span class="line">    tarverse(node1.left, node1.right);</span><br><span class="line">    tarverse(node2.left, node2.right);</span><br><span class="line">	<span class="comment">// 连接跨越父节点的两个子节点</span></span><br><span class="line">    tarverse(node1.right, node2.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="6-二叉树展平为链表"><a href="#6-二叉树展平为链表" class="headerlink" title="6.二叉树展平为链表"></a>6.二叉树展平为链表</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230515151548433.png" alt="image-20230515151548433"></p>
<p>常规解法 — 迭代前序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 设置虚拟头结点，使所有节点处理统一</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">dummpy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummpy;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        pre.right = node;</span><br><span class="line">        <span class="comment">// 借助栈先序遍历时，先进右节点，再进左节点</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line"></span><br><span class="line">        node.left = <span class="literal">null</span>;</span><br><span class="line">        pre = node;</span><br><span class="line">    &#125;</span><br><span class="line">    root = dummpy.right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>递归遍历解法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记住先序遍历的上一个节点</span></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">successor</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isBegin</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">// 标记当前为根节点，不需要被接上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 记录当前节点的右节点，由于递归过程中节点的右节点需要连接下一个节点，此处需要取下来用于先序遍历的遍历右子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.right;</span><br><span class="line">    <span class="comment">// 当前节点不为根节点，将其作为上一个节点的右节点</span></span><br><span class="line">    <span class="keyword">if</span>(!isBegin)&#123;</span><br><span class="line">        successor.right = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理完当前节点后，标记当前节点为下一个遍历节点的前置节点</span></span><br><span class="line">    successor = root;</span><br><span class="line">    isBegin = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 递归左子树</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    <span class="comment">// 处理完成后将左子树置为null，因为要链表化，只有右节点</span></span><br><span class="line">    root.left = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    flatten(temp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="7-根据前序和中序构建二叉树"><a href="#7-根据前序和中序构建二叉树" class="headerlink" title="7.根据前序和中序构建二叉树"></a>7.根据前序和中序构建二叉树</h3><p>思路：</p>
<p>先序遍历的顺序是根节点，左子树，右子树。中序遍历的顺序是左子树，根节点，右子树。</p>
<p>只需要从先序遍历的第一个节点拿到根节点，然后在中序遍历中找到该根节点的位置，中序遍历中该节点的左边就是左子树的节点，右边就是右子树的节点。</p>
<p>鉴于二叉树节点值不重复，可以使用HashMap保存元素到索引的映射，从而直接通过HashMap查到<code>rootVal</code>对应的<code>rootIndexIninorder</code></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/1.jpeg" alt="img" style="zoom: 33%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 保存中序遍历的元素及其下标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">        map.put(inorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> build(preorder,<span class="number">0</span>, preorder.length - <span class="number">1</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>, map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preBegin, <span class="type">int</span> preEnd, <span class="type">int</span>[] inorder, <span class="type">int</span> inBegin, <span class="type">int</span> inEnd, Map&lt;Integer, Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preBegin &gt; preEnd || inBegin &gt; inEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 前序遍历的第一个节点就是 root 节点</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preBegin];</span><br><span class="line">    <span class="comment">// 找到 root 在中序遍历中的位置，</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rootIndex</span> <span class="operator">=</span> map.get(rootVal);</span><br><span class="line">    <span class="comment">// 根据root在中序中的位置与左边界的差，即可拿到左边的长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> rootIndex - inBegin;</span><br><span class="line">    <span class="comment">//构建根节点</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">	<span class="comment">// 依次建立根节点的左右子树</span></span><br><span class="line">    root.left = build(preorder, preBegin + <span class="number">1</span>, preBegin + len, inorder,inBegin, rootIndex - <span class="number">1</span>, map); </span><br><span class="line">    root.right = build(preorder, preBegin + len + <span class="number">1</span>, preEnd, inorder, rootIndex + <span class="number">1</span>, inEnd,map);</span><br><span class="line">	<span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据前序和后序构建二叉树"><a href="#根据前序和后序构建二叉树" class="headerlink" title="根据前序和后序构建二叉树"></a>根据前序和后序构建二叉树</h3><p>思路</p>
<blockquote>
<p><strong>通过前序中序，或者后序中序遍历结果可以确定唯一一棵原始二叉树，但是通过前序后序遍历结果无法确定唯一的原始二叉树</strong>。</p>
</blockquote>
<p>因此结果存在多种，只需要返回一种即可。</p>
<p>用后序遍历和前序遍历结果还原二叉树，解法逻辑上和前中构建差别不大，也是通过控制左右子树的索引来构建：</p>
<p><strong>1、首先把前序遍历结果的第一个元素或者后序遍历结果的最后一个元素确定为根节点的值</strong>。</p>
<p><strong>2、然后把前序遍历结果的第二个元素作为左子树的根节点的值</strong>。</p>
<p><strong>3、在后序遍历结果中==寻找左子树根节点==的值，从而确定了左子树的索引边界，进而确定右子树的索引边界，递归构造左右子树即可</strong>。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/8.jpeg" alt="img" style="zoom:33%;" align="left">



<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">constructFromPrePost</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; postorder.length; i++)&#123;</span><br><span class="line">        map.put(postorder[i], i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> build(preorder, <span class="number">0</span>, preorder.length - <span class="number">1</span>, postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>, map);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span> preBegin, <span class="type">int</span> preEnd, <span class="type">int</span>[] postorder, <span class="type">int</span> postBegin, <span class="type">int</span> postEnd, Map&lt;Integer, Integer&gt; map)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(postBegin &gt; postEnd || preBegin &gt; preEnd) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 左子树根节点要取到前序遍历的第二个节点，可能存在溢出问题。</span></span><br><span class="line">    <span class="keyword">if</span>(preBegin == preEnd) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[preBegin]);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> preorder[preBegin];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">leftRootVal</span> <span class="operator">=</span> preorder[preBegin + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">leftRootIndexInPost</span> <span class="operator">=</span> map.get(leftRootVal);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> leftRootIndexInPost - postBegin + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line"></span><br><span class="line">    root.left = build(preorder, preBegin + <span class="number">1</span>, preBegin + len, postorder, postBegin, leftRootIndexInPost, map);</span><br><span class="line">    root.right = build(preorder, preBegin + len + <span class="number">1</span>, preEnd, postorder, leftRootIndexInPost + <span class="number">1</span>, postEnd - <span class="number">1</span>, map);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="8-序列化与反序列化二叉树"><a href="#8-序列化与反序列化二叉树" class="headerlink" title="8.序列化与反序列化二叉树"></a>8.序列化与反序列化二叉树</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230517094334599.png" alt="image-20230517094334599"></p>
<p>思路</p>
<blockquote>
<ol>
<li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，那么你无法还原出唯一的一棵二叉树。</p>
</li>
<li><p>如果你的序列化结果中<strong>不包含空指针的信息</strong>，且你会给出<strong>两种</strong>遍历顺序，分两种情况：</p>
<p>2.1. 如果你给出的是前序和中序，或者后序和中序，那么你可以还原出唯一的一棵二叉树。</p>
<p>2.2. 如果你给出前序和后序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树。</p>
</li>
<li><p>如果你的序列化结果中<strong>包含空指针的信息</strong>，且你只给出<strong>一种</strong>遍历顺序，也要分两种情况：</p>
<p>3.1. 如果你给出的是前序或者后序，那么你可以还原出唯一的一棵二叉树。</p>
<p>3.2. 如果你给出的是中序，那么除非你的整棵树中不包含值相同的节点，否则你无法还原出唯一的一棵二叉树。</p>
<p>总结：</p>
<p>不包含空指针：前序和中序，后序和中序可还原唯一一颗二叉树</p>
<p>包含空指针：前序，后序，层序可还原一颗二叉树</p>
</li>
</ol>
</blockquote>
<p>方法一：包含空指针，使用层序遍历序列化和反序列化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">null</span>)&#123;</span><br><span class="line">            sb.append(<span class="string">&quot;X,&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sb.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            que.offer(node.left);</span><br><span class="line">            que.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(data == <span class="literal">null</span> || data.equals(<span class="string">&quot;&quot;</span>) || data.charAt(<span class="number">0</span>) == <span class="string">&#x27;X&#x27;</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    Deque&lt;String&gt; strQ = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">    Deque&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(strQ.poll()));</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> root;</span><br><span class="line">    que.offer(root);</span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        root = que.poll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">leftVal</span> <span class="operator">=</span> strQ.poll();</span><br><span class="line">        <span class="type">String</span> <span class="variable">rightVal</span> <span class="operator">=</span> strQ.poll();</span><br><span class="line">        <span class="keyword">if</span>(!leftVal.equals(<span class="string">&quot;X&quot;</span>))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(leftVal));</span><br><span class="line">            root.left = leftNode;</span><br><span class="line">            que.offer(leftNode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!rightVal.equals(<span class="string">&quot;X&quot;</span>))&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(rightVal));</span><br><span class="line">            root.right = rightNode;</span><br><span class="line">            que.offer(rightNode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二：前序遍历序列化和反序列化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> reserialize(root, <span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">reserialize</span><span class="params">(TreeNode root, String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">        str += <span class="string">&quot;X,&quot;</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 前序遍历处理根节点</span></span><br><span class="line">        str += root.val + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//遍历左右节点</span></span><br><span class="line">        str = reserialize(root.left, str);</span><br><span class="line">        str = reserialize(root.right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(data.split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">    <span class="keyword">return</span> redeserialize(list);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">redeserialize</span><span class="params">(List&lt;String&gt; list)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">curStr</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    list.remove(<span class="number">0</span>);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(!curStr.equals(<span class="string">&quot;X&quot;</span>))&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(curStr));</span><br><span class="line">        root.left = redeserialize(list);</span><br><span class="line">        root.right = redeserialize(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找重复的数"><a href="#寻找重复的数" class="headerlink" title="寻找重复的数"></a>寻找重复的数</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230517112237789.png" alt="image-20230517112237789"></p>
<p>思路</p>
<p>根据上题的思路，当保存空指针时，前序或后序可以唯一确定一颗树。</p>
<p>我们可以将以每个节点为根节点的前序序列保存进哈希表，当某个前序序列的个数大于1时，说明该树重复出现。</p>
<p>遍历时使用后序遍历生成前序序列，可以减少节点的重复计算。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存结果</span></span><br><span class="line">List&lt;TreeNode&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 保存包含空指针的前序序列</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dfs</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// 获得左子树的前序序列</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">leftStr</span> <span class="operator">=</span> dfs(root.left);</span><br><span class="line">    <span class="comment">// 获得右子树的前序序列</span></span><br><span class="line">     <span class="type">String</span> <span class="variable">rightStr</span> <span class="operator">=</span> dfs(root.right);</span><br><span class="line">	<span class="comment">// 构建包含空指针的前序序列，虽然对于空指针并没有加入对应字符</span></span><br><span class="line">    <span class="comment">// 但是序列中每个节点使用逗号分隔，空指针处会出现两个逗号相连的情况，也可以据此做出区分。</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>().append(root.val).append(<span class="string">&quot;,&quot;</span>).append(leftStr).append(<span class="string">&quot;,&quot;</span>).append(rightStr).toString();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 判断结果时，不采用是否大于1的条件进行判断，因为可能会出现重复添加，例如出现的第2,3,4次时都会被添加</span></span><br><span class="line">    <span class="comment">// 所以此处在节点序列被添加前，根据是否==1时进行添加，保证只添加一次。</span></span><br><span class="line">    <span class="keyword">if</span>(map.getOrDefault(key, <span class="number">0</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        res.add(root);</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(key, map.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="9-验证二叉搜索树"><a href="#9-验证二叉搜索树" class="headerlink" title="9.验证二叉搜索树"></a>9.验证二叉搜索树</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230520101530601.png" alt="image-20230520101530601" style="zoom:80%;" align="left">

<p>思路</p>
<p>利用二叉搜索树的特性，根节点大于左子节点，大于右子节点。利用后序遍历检查每个节点是否符合条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// root 的左边应该更小</span></span><br><span class="line">    <span class="keyword">if</span> (root.left != <span class="literal">null</span> &amp;&amp; root.left.val &gt;= root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// root 的右边应该更大</span></span><br><span class="line">    <span class="keyword">if</span> (root.right != <span class="literal">null</span> &amp;&amp; root.right.val &lt;= root.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left)</span><br><span class="line">        &amp;&amp; isValidBST(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是上述代码存在一个问题，bst的特性不光是根节点大于左子节点，大于右子节点。根节点的右边部分还需要大于左边部分所有节点，而上述代码只判断的某个节点的情况。例如下面的情况就会出现问题。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/假BST.png" alt="img" style="zoom:80%;" align="left">

<p>所以在遍历到某个节点时，还需要记住带上应该小于的最大值与应该大于的最小值</p>
<p>改进如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">    <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">    <span class="keyword">return</span> isValidBST(root.left, min, root) </span><br><span class="line">        &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二叉树的完全性校验-验证完全二叉树"><a href="#二叉树的完全性校验-验证完全二叉树" class="headerlink" title="二叉树的完全性校验(验证完全二叉树)"></a>二叉树的完全性校验(验证完全二叉树)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230717140904623.png" alt="image-20230717140904623" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<p>层序遍历二叉树，左右子树不判断是否为null，直接加入队列。当当前节点为 null 值时停止遍历，此时对队列中剩下节点进行判断，若为完全二叉树，则余下节点均为null节点，如果存在非null节点，说明该树非完全二叉树。</p>
<p>注意：若需要将null加入队列，需要使用LinkedList实现的队列，ArrayDeque实现的队列无法加入null。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            queue.offer(cur.left);</span><br><span class="line">            queue.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











<h3 id="10-不同的二叉搜索树"><a href="#10-不同的二叉搜索树" class="headerlink" title="10.不同的二叉搜索树"></a>10.不同的二叉搜索树</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230520111520543.png" alt="image-20230520111520543" style="zoom:80%;" align="left">

<p>思路</p>
<p>确定根节点，递归得出其可能的左子树集合和右子树集合，每次从中选择一个左子树与右子树即可</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> generateTree(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title function_">generateTree</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">        List&lt;TreeNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            list.add(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 确定根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">// 递归得到左子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; leftList = generateTree(start, i - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归得到右子树集合</span></span><br><span class="line">            List&lt;TreeNode&gt; rightList = generateTree(i+<span class="number">1</span>, end);</span><br><span class="line">	   <span class="comment">// 选择一颗左子树与一颗右子树得到一组解。</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftNode : leftList)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightNode : rightList)&#123;</span><br><span class="line">                    <span class="type">TreeNode</span> <span class="variable">curRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(i);</span><br><span class="line">                    curRoot.left = leftNode;</span><br><span class="line">                    curRoot.right = rightNode;</span><br><span class="line"></span><br><span class="line">                    list.add(curRoot);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="11-引子：如何在二叉树中寻找一个元素"><a href="#11-引子：如何在二叉树中寻找一个元素" class="headerlink" title="11. 引子：如何在二叉树中寻找一个元素"></a>11. 引子：如何在二叉树中寻找一个元素</h3><p>输入一棵<strong>没有重复元素</strong>的二叉树根节点<code>root</code>和一个目标值<code>val</code>，请你写一个函数寻找树中值为<code>val</code>的节点。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 看看 root.val 是不是要找的</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，那就去左子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 左子树找不着，那就去右子树找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="keyword">if</span> (right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实在找不到了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>修改return的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 看看哪边找到了</span></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码也可以达到目的，但是实际运行的效率会低一些，原因也很简单，如果能够在左子树找到目标节点，还有没有必要去右子树找了？没有必要。但这段代码还是会去右子树找一圈，所以效率相对差一些。</p>
<p>更进一步，把对 root.val 的判断从前序位置移动到后序位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val);</span><br><span class="line">    <span class="comment">// 后序位置，看看 root 是不是目标节点</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// root 不是目标节点，再去看看哪边的子树找到了</span></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码相当于先去左右子树找，然后才检查<code>root</code>，依然可以到达目的，但是效率会进一步下降。<strong>因为这种写法必然会遍历二叉树的每一个节点</strong>。</p>
<p>对于之前的解法，在前序位置就检查<code>root</code>，如果输入的二叉树根节点的值恰好就是目标值<code>val</code>，那么函数直接结束了，其他的节点根本不用搜索。</p>
<p>但如果在后序位置判断，那么就算根节点就是目标节点，也要去左右子树遍历完所有节点才能判断出来。</p>
<p>最后，再改一下题目，现在不找值为<code>val</code>的节点，而是寻找值为<code>val1</code><strong>或</strong><code>val2</code>的节点</p>
<p>这和我们第一次实现的<code>find</code>函数基本上是一样的，而且你应该知道可以有多种写法，我选择这样写代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：在以 root 为根的二叉树中寻找值为 val1 或 val2 的节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置，看看 root 是不是目标值</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去左右子树寻找</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>为什么要写这样一个奇怪的<code>find</code>函数呢？因为最近公共祖先系列问题的解法都是把上面这个函数作为框架的</strong>。</p>
<h3 id="二叉树的最近公共祖先-—-两个节点"><a href="#二叉树的最近公共祖先-—-两个节点" class="headerlink" title="二叉树的最近公共祖先 — 两个节点"></a>二叉树的最近公共祖先 — 两个节点</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230521114119909.png" alt="image-20230521114119909" style="zoom:67%;" align="left">



<p>思路</p>
<p>祖先的定义: 若节点 <em>p</em> 在节点 <em>root</em> 的左(右)子树中，或 <em>p = root</em>，则称 <em>root</em> 是 <em>p</em> 的祖先。<br>最近公共祖先的定义: 设节点 <em>root</em> 为节点 <em>p</em>, <em>q</em> 的某公共祖先，若其左子节点 <em>root.left</em> 和右子节点 <em>root.right</em> 都不是 <em>p, q</em>的公共祖先，则称 <em>root</em> 是“最近的公共祖先”。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/1599885247-rxcHcZ-Picture1.png" alt="Picture1.png" style="zoom:33%;" align="left">

<p>根据以上定义，若 root 是 p,q 的最近公共祖先，则只可能为以下情况之—:</p>
<ol>
<li>p 和 q 在 root 的子树中，且分列 root 的异侧(即分别在左、右子树中);</li>
<li>p = root，且 q 在 root 的左或右子树中;</li>
<li>q = root，且 p 在 root 的左或右子树中;</li>
</ol>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/1599885247-mgYjRv-Picture2.png" alt="Picture2.png" style="zoom:33%;" align="left">

<p><strong>考虑通过递归对二叉树进行先序遍历，当遇到节点 p 或 q 时返回。从底至顶回溯，当节点 p,q 在节点 root 的异侧时，节点 root 即为最近公共祖先，则向上返回 root 。</strong></p>
<p>递归解析:</p>
<ol>
<li>终止条件:<ol>
<li>当越过叶节点，则直接返回nall ;</li>
<li>当root等于p, q，则直接返回root ;</li>
</ol>
</li>
<li>递推工作:<ol>
<li>开启递归左子节点，返回值记为left ;</li>
<li>开启递归右子节点，返回值记为right ;</li>
</ol>
</li>
<li>返回值:根据left和right，可展开为四种情况;<ol>
<li>当left和right同时不为空:说明p,q分列在root的异侧(分别在左/右子树)，因此root为最近公共祖先，返回root ;</li>
<li>当left为空，right 不为空:p,q都不在root 的左子树中，直接返回right。具体可分为两种情况:<ol>
<li>p, q其中一个在root的右子树中，此时right指向p（假设为p);</li>
<li>p,q两节点都在root的右子树中，此时的right指向最近公共祖先节点;</li>
</ol>
</li>
<li>当left不为空，right 为空:与情况3.同理;</li>
<li>当left和right同时为空:说明root的左/右子树中都不包含p, q，返回null ;</li>
</ol>
</li>
</ol>
<p>复杂度分析</p>
<blockquote>
<p>时间复杂度 o(N): 其中 N 为二叉树节点数; 最差情况下，需要递归遍历树的所有节点。</p>
<p>空间复杂度 O(N): 最差情况下，递归深度达到 N，系统使用 O(N) 大小的额外空间。</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">leftNode</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">rightNode</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(leftNode != <span class="literal">null</span> &amp;&amp; rightNode != <span class="literal">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">	<span class="keyword">if</span>(leftNode != <span class="literal">null</span> ||  rightNode != <span class="literal">null</span>) leftNode != <span class="literal">null</span> ? leftNode : rightNode; </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩展1：若寻找两个以上节点的LCA呢"><a href="#扩展1：若寻找两个以上节点的LCA呢" class="headerlink" title="扩展1：若寻找两个以上节点的LCA呢"></a>扩展1：若寻找两个以上节点的LCA呢</h3><p>只需要改进</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 两个节点</span></span><br><span class="line"> <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"><span class="comment">// 多个节点</span></span><br><span class="line"><span class="keyword">if</span>(nodeSet.contains(root)) <span class="keyword">return</span> root;</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode[] nodes)</span> &#123;</span><br><span class="line">    <span class="comment">// 将列表转化成哈希集合，便于判断元素是否存在</span></span><br><span class="line">    HashSet&lt;Integer&gt; values = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (TreeNode node : nodes) &#123;</span><br><span class="line">        values.add(node.val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> find(root, values);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树中寻找 values 的最近公共祖先节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, HashSet&lt;Integer&gt; values)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置</span></span><br><span class="line">    <span class="keyword">if</span> (values.contains(root.val))&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, values);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, values);</span><br><span class="line">    <span class="comment">// 后序位置，已经知道左右子树是否存在目标值</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前节点是 LCA 节点</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩展2：若p，q需要同时存在，否则返回null？"><a href="#扩展2：若p，q需要同时存在，否则返回null？" class="headerlink" title="扩展2：若p，q需要同时存在，否则返回null？"></a>扩展2：若p，q需要同时存在，否则返回null？</h3><p>在解决标准的最近公共祖先问题时，由于p和q都存在于树中，我们有如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序位置</span></span><br><span class="line"><span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">    <span class="comment">// 如果遇到目标值，直接返回</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其主要解决下面这种情况</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/640" alt="图片" style="zoom:33%;" align="left">

<p>但是若p或q不一定存在于数中时，我们则应该对二叉树进行完全遍历，且标记p和q是否被找到。</p>
<p>若p或q没有被找到，则不存LCA，返回null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于记录 p 和 q 是否存在于二叉树中</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">foundP</span> <span class="operator">=</span> <span class="literal">false</span>, foundQ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">res</span> <span class="operator">=</span> find(root, p.val, q.val);</span><br><span class="line">    <span class="keyword">if</span> (!foundP || !foundQ) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p 和 q 都存在二叉树中，才有公共祖先</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树中寻找 val1 和 val2 的最近公共祖先节点</span></span><br><span class="line">TreeNode <span class="title function_">find</span><span class="params">(TreeNode root, <span class="type">int</span> val1, <span class="type">int</span> val2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> find(root.left, val1, val2);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> find(root.right, val1, val2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，判断当前节点是不是 LCA 节点</span></span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序位置，判断当前节点是不是目标值</span></span><br><span class="line">    <span class="keyword">if</span> (root.val == val1 || root.val == val2) &#123;</span><br><span class="line">        <span class="comment">// 找到了，记录一下</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == val1) foundP = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == val2) foundQ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> left != <span class="literal">null</span> ? left : right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="扩展3：二叉搜索树的最近公共祖先"><a href="#扩展3：二叉搜索树的最近公共祖先" class="headerlink" title="扩展3：二叉搜索树的最近公共祖先"></a>扩展3：二叉搜索树的最近公共祖先</h3><p>对于BST来说，不需要老老实实去遍历子树，利用BST左小右大的性质，将当前节点的值与p，q的值进行对比即可判断当前节点是否为LCA：</p>
<p>假设val1 &lt; val2</p>
<ul>
<li>若 val1 &lt; root.val &lt; val2， 则当前节点为LCA</li>
<li>若root.val &lt; val1， 说明root的左子树的节点都小于p, q，则需要去值更大的右子树寻找LCA</li>
<li>若root.val &gt; val2， 说明root的右子树的节点都大于p, q，则需要去值更小的左子树寻找LCA</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<p>扩展4：求包含父节点的LCA</p>
<p>节点结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node left;</span><br><span class="line">    Node right;</span><br><span class="line">    Node parent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于节点包含指向父节点的指针，则无需遍历子树，可以根据父节点向上搜索寻找LCA</p>
<p>则题目可以转化为单链表相交问题。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/640" alt="图片" style="zoom: 50%;" align="left">

<p>单链表相交问题思路</p>
<p>构建两个虚拟头结点<code>p1,p2</code>, 我们可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让 <code>p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表 <code>A</code>，这样相当于「逻辑上」两条链表接在了一起。</p>
<p>如果这样进行拼接，就可以让 <code>p1</code> 和 <code>p2</code> 同时进入公共部分，也就是同时到达相交节点 <code>c1</code></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230522100156243.png" alt="image-20230522100156243" style="zoom: 33%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">lowestCommonAncestor</span><span class="params">(Node p, Node q)</span> &#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">a</span> <span class="operator">=</span> p, b = q;</span><br><span class="line">    <span class="keyword">while</span>(a != b)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == <span class="literal">null</span>) a = q;</span><br><span class="line">        <span class="keyword">else</span> a = a.parent;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(b == <span class="literal">null</span>) b = p;</span><br><span class="line">        <span class="keyword">else</span> b = b.parent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="12-计算完全二叉树节点个数"><a href="#12-计算完全二叉树节点个数" class="headerlink" title="12.计算完全二叉树节点个数"></a>12.计算完全二叉树节点个数</h3><p>计算普通二叉树节点个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度: O(n)。需要遍历所有节点。</p>
</blockquote>
<p>计算满二叉树节点个数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 计算树的高度</span></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        root = root.left;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点总数就是 2^h - 1</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, h) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度: O(logn) 。只需要遍历树高</p>
</blockquote>
<p><strong>完全</strong>二叉树比普通二叉树特殊，但又没有满二叉树那么特殊，计算它的节点总数，可以说是普通二叉树和完全二叉树的结合版</p>
<p><strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong>：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/1.jpg" alt="img" style="zoom: 33%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">l</span> <span class="operator">=</span> root, r = root;</span><br><span class="line">    <span class="comment">// 沿最左侧和最右侧分别计算高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hl</span> <span class="operator">=</span> <span class="number">0</span>, hr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">        l = l.left;</span><br><span class="line">        hl++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (r != <span class="literal">null</span>) &#123;</span><br><span class="line">        r = r.right;</span><br><span class="line">        hr++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右侧计算的高度相同，则是一棵满二叉树</span></span><br><span class="line">    <span class="keyword">if</span> (hl == hr) &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">2</span>, hl) - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果左右侧的高度不同，则按照普通二叉树的逻辑计算</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>时间复杂度：O(logn * logn)</p>
</blockquote>
<p><strong>复杂度分析</strong></p>
<p>这个算法的时间复杂度是 O(logN*logN)，这是怎么算出来的呢？</p>
<p>直觉感觉好像最坏情况下是 O(N*logN) 吧，因为 while 里面需要 logN 的时间，同时需要 O(N) 的时间向左右子树递归。但是由于<strong>一棵完全二叉树的两棵子树，至少有一棵是满二叉树</strong>。则其子树一定有一颗是满二叉树，即一定会触发<code>hl == hr</code>，只需要消耗 O(logn) 的复杂度而不会继续递归。</p>
<p>综上，算法的递归深度就是树的高度 O(logN)，每次递归所花费的时间就是 while 循环，需要 O(logN)，所以总体的时间复杂度是 O(logN*logN)。</p>
<h3 id="13-二叉树的最大路径和"><a href="#13-二叉树的最大路径和" class="headerlink" title="13.二叉树的最大路径和"></a>13.二叉树的最大路径和</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230614102923205.png" alt="image-20230614102923205" style="zoom:50%;" align="left">

<p><strong>思路</strong></p>
<p>对于任意一个节点，如果最大路径包含该节点，则只有两种情况：</p>
<p>1.该节点是最大路径的根节点，其左右子树都在最大路径中。</p>
<p>2.其左右子树中路径和较大的一侧路径加上该节点的值然后向父节点回溯构成最大路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于任意一个节点, 如果最大和路径包含该节点, 那么只可能是两种情况:</span></span><br><span class="line"><span class="comment">        1. 其左右子树中所构成的和路径值较大的那个加上该节点的值后向父节点回溯构成最大路径</span></span><br><span class="line"><span class="comment">        2. 左右子树都在最大路径中, 加上该节点的值构成了最终的最大路径</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        getMax(root);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(TreeNode r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, getMax(r.left)); <span class="comment">// 如果子树路径和为负则应当置0表示最大路径不包含子树</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, getMax(r.right));</span><br><span class="line">        ret = Math.max(ret, r.val + left + right); <span class="comment">// 判断在该节点包含左右子树的路径和是否大于当前最大路径和</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + r.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="14-二叉树的直径"><a href="#14-二叉树的直径" class="headerlink" title="14.二叉树的直径"></a>14.二叉树的直径</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230628100506892.png" alt="image-20230628100506892" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>遍历每一个节点，以每一个节点为中心点计算最长路径(左子树边长+右子树边长)，更新全局变量max</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    diameterCurRoot(root);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">    <span class="comment">// 以当前节点为中心点计算最长路径</span></span><br><span class="line">    max = Math.max(max, left + right);</span><br><span class="line">    <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>##15.二叉树最大宽度_==计入空节点==</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230706105505056.png" alt="image-20230706105505056" style="zoom: 80%;" align="left">



<p><strong>方法—DFS</strong></p>
<p>根据满二叉树的编号规则：若根节点编号为<code>u</code>，则左节点编号为 <code>u &lt;&lt; 1</code>，右节点编号为 <code>u &lt;&lt; 1 | 1</code></p>
<p>一个朴素的想法是：我们在 DFS 过程中使用两个哈希表分别记录每层深度中的最小节点编号和最大节点编号，两者距离即是当前层的宽度，最终所有层数中的最大宽度即是答案。</p>
<p>而实现上，我们可以利用先 DFS 左节点，再 DFS 右节点的性质可知，每层的最左节点必然是最先被遍历到，因此我们只需要记录当前层最先被遍历到点编号（即当前层最小节点编号），并在 DFS 过程中计算宽度，更新答案即可。</p>
<blockquote>
<p>编号溢出问题：深度过深时，结点的编号可能超出Integer的最大值类型</p>
<p>可以通过使用 <code>u = u - map.get(depth) + 1;</code>操作来对同层内的节点进行重新编号(使得同层最靠左的非空节点编号为1)</p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> u, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(depth)) map.put(depth, u);</span><br><span class="line">        ans = Math.max(ans, u - map.get(depth) + <span class="number">1</span>);</span><br><span class="line">        u = u - map.get(depth) + <span class="number">1</span>;</span><br><span class="line">        dfs(root.left, u &lt;&lt; <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">        dfs(root.right, u &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-动态规划专题总结"><a href="#4-动态规划专题总结" class="headerlink" title="4.动态规划专题总结"></a>4.动态规划专题总结</h2><h3 id="1-方法论-—-基本dp"><a href="#1-方法论-—-基本dp" class="headerlink" title="==1==.方法论 — 基本dp"></a>==1==.方法论 — <strong>基本dp</strong></h3><p><strong>动态规划介绍</strong></p>
<p>动态规划，简称DP算法，如果某一问题有很多重叠子问题，使用DP来求解是最有效的</p>
<p>由于存在许多子问题，所有动态规划的每一个状态都是从上一个状态推导出来的，这与贪心算法的区别很大，贪心算法没有状态推导，是由局部最优推出全局最优。</p>
<p><strong>动态规划解题步骤</strong></p>
<ol>
<li><p>确定dp数组以及下标的含义</p>
</li>
<li><p>确定递推公式</p>
</li>
<li><p>dp数组如何初始化</p>
</li>
<li><p>确定遍历顺序</p>
</li>
<li><p>举例推导dp数组</p>
</li>
</ol>
<h3 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230808103024450.png" alt="image-20230808103024450" style="zoom: 80%;" align="left">

<p>思路分析：</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<br>dp[i]:爬到第i层楼梯，有dp[i]种方法</li>
<li>确定递推公式<br>从dp[i]的定义可以看出，dp[i] 可以有两个方向推出来。<br>首先是dp[i - 1]，上i-1层楼梯，有dp[i - 1]种方法，那么再一步跳一个台阶不就是dp[i]了么。<br>还有就是dp[i - 2]，上i-2层楼梯，有dp[i - 2]种方法，那么再一步跳两个台阶不就是dp[i]了么。<br>那么dp[i]就是 dp[i - 1]与dp[i - 2]之和！<br>所以dp[i] = dp[i - 1] + dp[i - 2] 。<br>在推导dp[i]的时候，一定要时刻想着dp[i]的定义，否则容易跑偏。</li>
<li>dp数组初始化<br>n &gt;= 1<br>爬第一层有一种方式，dp[1] = 1<br>爬第二层有两种方式，dp[2] = 2</li>
<li>确定遍历顺序<br>从递推公式dp[i] = dp[i - 1] + dp[i - 2];中可以看出，遍历顺序一定是从前向后遍历的</li>
<li>举例推导dp数组<br>n=5时，dp = [1,2,3,5,8]</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp[0] = 1</span></span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 滚动数组优化</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">//由于dp数组的状态只与前两个值有关，则可以使用三个int型变量来优化空间</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp2</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        sum = dp1+dp2;</span><br><span class="line">        dp1 = dp2;<span class="comment">//记录下一轮dp[i-2]</span></span><br><span class="line">        dp2 = sum;<span class="comment">//记录下一轮dp[i-1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a>746.使用最小花费爬楼梯</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230808150952669.png" alt="image-20230808150952669" style="zoom:80%;" align="left">

<p>思路分析</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<br>dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]。</li>
<li>确定递推公式<br>每次可以爬一层或两层，则第i层可以由第i-1层爬一步上来，也可以由第i-2层爬上来,再考虑爬第i层需要的体力成本cost[i]<br>即爬第i层最少的体力为：==dp[i] = min(dp[i-1], dp[i-2]) + cost[i]==</li>
<li>dp数组初始化<br>dp[0] = cost[0]<br>dp[1] = cost[1]</li>
<li>确定遍历顺序<br>从前往后</li>
<li>举例推导dp数组<br>当cost = {1, 100, 1, 1, 1, 100, 1, 1, 100, 1}<br>可推导出dp = {1,100,2,3,3,103,4,,5,104,6}<br>由于需要爬上楼顶(也可认为楼顶的体力消耗为0)，而最后需要根据最后两个数据得出最后体力消耗<br>res = min(104,6) + 0 = 6</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cost.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i] = Math.min(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环结束后，还没有达到楼顶，此时可用选择从dp0跨两个楼梯上楼顶 或者 dp1 跨一个楼梯上楼顶</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[n - <span class="number">1</span>], dp[n - <span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> cost[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> cost[<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;cost.length;i++)&#123;</span><br><span class="line">        temp = Math.min(dp0,dp1)+cost[i];</span><br><span class="line">        dp0 = dp1;</span><br><span class="line">        dp1 = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for循环结束后，还没有达到楼顶，此时可用选择从dp0跨两个楼梯上楼顶 或者 dp1 跨一个楼梯上楼顶</span></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp0,dp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="62-不同路径-机器人走路"><a href="#62-不同路径-机器人走路" class="headerlink" title="62.不同路径(机器人走路)"></a>62.不同路径(机器人走路)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230808151941318.png" alt="image-20230808151941318" style="zoom: 80%;" align="left">

<p>思路</p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>dp[i] [j]是到达(i,j)位置的所有路径数
</code></pre>
</li>
<li><p>确定递推公式</p>
<pre><code>除了第0行和第0列，每个位置都可由其上和其左边过来，则dp[i] [j] = dp[i-1] [j] + dp[i] [j-1] (其中 1&lt;=i&lt;m,1&lt;=j&lt;n)
</code></pre>
</li>
<li><p>dp数组初始化</p>
<pre><code>除了[0,0],第0行的位置都只能由其左边位置过来，则dp[1] [1~n] = 1 
</code></pre>
<p>​    除了[0,0],第0列的位置都只能由其上边位置过来，则dp[1~m] [1] = 1</p>
<p>​     dp[0] [0] = 1, 到达该位置只有一种方法。</p>
</li>
<li><p>确定遍历顺序</p>
<pre><code>只能向右或向下，顺序无所谓
</code></pre>
</li>
<li><p>举例推导dp数组</p>
<pre><code>m=3,n=2时
dp = [0,1]
         [1,2]
         [1,3]
</code></pre>
</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//先向右遍历再向下遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">            dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] = dp[j - <span class="number">1</span>] + dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="63-不同路径II-机器人走路带障碍"><a href="#63-不同路径II-机器人走路带障碍" class="headerlink" title="63.不同路径II(机器人走路带障碍)"></a>63.不同路径II(机器人走路带障碍)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230808153616848.png" alt="image-20230808153616848" style="zoom:80%;" align="left">



<p>思路分析</p>
<blockquote>
<p>在上一题的基础上加入限制条件：表格中存在障碍点，这些位置不能通过。障碍点的位置使用obstacleGrid)数组记录</p>
<p>本题动态规划五部曲与上一题类似，主要不同的地方在于dp数组初始化和递推公式</p>
<ul>
<li>初始化第0行时，由于该行的位置都只能从左边过来，只要遇到第一个障碍，后面的位置都无法到达</li>
<li>初始化第0列时，由于该行的位置都只能从上边过来，只要遇到第一个障碍，下面的位置都无法到达</li>
<li>递推公式也需要加入判断条件，如果该位置有障碍，则该位置无法到达<ul>
<li>if(obstacleGrid[i][j] != 1) dp[i] [j] = dp[i-1] [j] + dp[i] [j-1];</li>
</ul>
</li>
</ul>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> obstacleGrid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid[m-<span class="number">1</span>][n-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    <span class="comment">//初始化第0行时，由于该行的位置都只能从左边过来，只要遇到第一个障碍，后面的位置都无法到达</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i] != <span class="number">1</span>) dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>] != <span class="number">1</span>) dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新位置时，遇到有障碍，则到达该位置的路径为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j] != <span class="number">1</span>) dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="343-整数拆分"><a href="#343-整数拆分" class="headerlink" title="343.整数拆分"></a>343.整数拆分</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230809100128836.png" alt="image-20230809100128836" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<blockquote>
<p>1.确定dp数组以及下标的含义<br>    dp[i]：数字i拆分后可以得到的最大乘积为dp[i]。</p>
<p>2.确定递推公式<br>    创建数组dp，其中 dp[i] 表示将正整数 i 拆分成至少两个正整数的和之后，这些正整数的最大乘积。特别地，0 不是正整数，1 是最小的正整数，0 和 1 都不能拆分，因此 dp[0]=dp[1]=0。<br>    当 i ≥2 时，假设对正整数 i 拆分出的第一个正整数是 j（1≤j&lt;i），则有以下两种方案：</p>
<ul>
<li><p>将 i 拆分成 j 和 i−j 的和，且 i−j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；</p>
</li>
<li><p>将 i 拆分成 j 和 i−j 的和，且 i−j 继续拆分成多个正整数，此时的乘积是 j×dp[i−j]。</p>
</li>
</ul>
<p>​       因此，当 j 固定时，有 ==dp[i]=max(j×(i−j),j×dp[i−j])==。由于 j 的取值范围是 1 到 i−1，需要遍历所有的 j 得到 dp[i] 的最大值，所以最后有：==dp[i] = Math.max(dp[i],Math.max(j * (i-j), j * dp[i-j]))==;</p>
<p>3.dp数组初始化<br>    由于0和1不能拆分，所以只初始化dp[2] = 1;</p>
<p>4.确定遍历顺序<br>    dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历，先有dp[i - j]再有dp[i]。</p>
<p>5.举例推导dp数组<br>    n = 4<br>    dp[2] = 1,dp[3]=max(1 * 2,1 * dp[2]) = max(2,1) = 2<br>    dp[4] = max(1 * 3,1 * dp[3],2 * 2,2 * dp[2],3 * 1) = 4</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=n; i++)&#123;<span class="comment">//i为需要拆分的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j&lt;i-<span class="number">1</span>; j++)&#123;<span class="comment">//将i差为j和i-j（i-j也可以选择继续拆分）</span></span><br><span class="line">            dp[i] = Math.max(dp[i],Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="2-方法论-—-01背包"><a href="#2-方法论-—-01背包" class="headerlink" title="==2==.方法论 — 01背包"></a>==2==.方法论 — <strong>01背包</strong></h3><p>问题描述：有==n件物品==和一个最多能背==重量为w的背包==。第==i==件物品的==重量是weight[i]==，得到的==价值是value[i]== 。每件物品只能==用一次==，求解将哪些物品装入背包里物品价值总和最大。</p>
<blockquote>
<p>关键词：物品，物品重量，背包容量，物品价值，一次，价值最大。</p>
</blockquote>
<p>二维数组动态规划五部曲：</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i] [j]表示从下标为[0-i]的物品里面任意取，放进容量为j的背包，价值总和最大为多少
</code></pre>
</li>
<li>确定递推公式<br>dp[i] [j]主要从两个方向推出：<br>*不放物品：由dp[i-1] [j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1] [j]。<pre><code>(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
</code></pre>
*放物品：由dp[i-1] [j-weight[i]]+value[i]推出，其中dp[i - 1] [j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值(此时加上weight[i]则重量为j)<br>递推公式：dp[i] [j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]);//==由于是01背包，物品只能取一次，所以要从dp[i - 1]里面找符合条件的值==</li>
<li>dp数组初始化<br>首先从dp[i] [j]的定义出发，如果背包容量j为0的话，即dp[i] [0]，无论是选取哪些物品，背包价值总和一定为0。<br>其次，由状态转移方程 dp[i][j] = max(dp[i - 1] [j], dp[i - 1] [j - weight[i]] + value[i]); 可以看出i 是由 i-1 推导出来，那么i为0的时候就一定要初始化。<br>dp[0] [j]，即：i为0，存放编号0的物品的时候，各个容量的背包所能存放的最大价值。<br>那么很明显当 j &lt; weight[0]的时候，dp[0] [j] 应该是 0，因为背包容量比编号0的物品重量还小。<br>当j &gt;= weight[0]时，dp[0] [j] 应该是value[0]，因为背包容量放足够放编号0物品。</li>
<li>确定遍历顺序<br>主要有两个遍历的维度：物品和背包容量。先遍历物品更好理解</li>
<li>举例推导dp数组<br>重量     0 1  2  3  4<br>物品0    0 15 15 15 15<br>物品1    0 15 15 20 35<br>物品2    0 15 15 20 35    </li>
</ol>
</blockquote>
<p>代码模版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testweightbagproblem</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagsize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//定义dp数组:dp[i][j]表示背包容量为j时，前i个物品能获得的最大价值</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[wLen][bagsize + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历顺序：先遍历物品，在遍历背包容量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; wLen; i++) &#123;<span class="comment">//遍历物品</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= bagsize; j++) &#123;<span class="comment">//遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//当前背包容量小于当前物品重量，则无法装入</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dp[wLen][bagsize];<span class="comment">//能获得的最大价值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>一维数组动态规划五部曲</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>在一维dp数组中，dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。
</code></pre>
</li>
<li>确定递推公式<br>dp[j]可以通过dp[j - weight[i]]推导出来，dp[j - weight[i]]表示容量为j - weight[i]的背包所背的最大价值。<br>dp[j - weight[i]] + value[i] 表示 容量为 j - 物品i重量 的背包 加上 物品i的价值。（也就是容量为j的背包，放入物品i了之后的价值即：dp[j]）<br>此时dp[j]有两个选择，一个是取自己dp[j] 相当于 二维dp数组中的dp[i-1] [j]，即不放物品i，一个是取dp[j - weight[i]] + value[i]，即放物品i，指定是取最大的，毕竟是求最大价值，<br>即：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</li>
<li>dp数组初始化<br>由递归公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>dp数组在推导的时候一定是取价值最大的数，如果题目给的价值都是正整数那么非0下标都初始化为0就可以了。<br>这样才能让dp数组在递归公式的过程中取的最大的价值，而不是被初始值覆盖了。<br>那么假设物品价值都是大于0的，所以dp数组初始化的时候，都初始为0就可以了</li>
<li>确定遍历顺序<br>一维dp数组与二维dp数组遍历顺序不一样<br>二维dp遍历的时候，背包容量是从小到大，而一维dp遍历的时候，背包是从大到小(即倒序)。<br>因为一维dp的dp[i]的值需要用到dp[i-1],如果正序遍历的话dp[i]会用到dp[i-1]变化之后的值<br>倒序遍历的原因是，本质上还是一个对二维数组的遍历，并且右下角的值依赖上一层左上角的值，因此需要保证左边的值仍然是上一层的，从右向左覆盖。<br>即：先遍历物品，再倒序遍历背包容量</li>
<li>举例推导dp数组<br>用物品0遍历时    0 15 15 15 15<br>用物品1遍历时    0 15 15 20 35<br>用物品2遍历时    0 15 15 20 35</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testweightbagproblem1</span><span class="params">(<span class="type">int</span>[] weight, <span class="type">int</span>[] value, <span class="type">int</span> bagsize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">wLen</span> <span class="operator">=</span> weight.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagsize+<span class="number">1</span>];<span class="comment">//bag[j]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;wLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=bagsize; j&gt;=weight[i]; j--)&#123;<span class="comment">//背包容量逆序遍历，截止到weight[i]</span></span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-weight[i]]+value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	dp[bagsize]即为背包能装的最大价值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230809102850642.png" alt="image-20230809102850642" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<p>本题可以转化为01背包问题。即从数组中找到一部分元素，这些元素的和为数组所有元素和的一半。</p>
<p>数组元素为物品，元素和一半为背包容量，数组元素值为价值，求最大价值是否等于背包容量。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canPartition1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums) sum += num;</span><br><span class="line">    <span class="keyword">if</span>(sum % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &gt;= nums[i - <span class="number">1</span>]) dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m] == m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canPartition1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=target;j&gt;=nums[i];j--)&#123;<span class="comment">//j逆序直到nums[i]，小于nums[i]时装不进去</span></span><br><span class="line">            dp[j] = Math.max(dp[j],dp[j-nums[i]]+nums[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(dp[target] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="1049-最后一块石头的重量II"><a href="#1049-最后一块石头的重量II" class="headerlink" title="1049.最后一块石头的重量II"></a>1049.最后一块石头的重量II</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230809110115233.png" alt="image-20230809110115233" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>题目的本质就是==将所有石头分为两堆，然后求两堆石头的最小差值==。</p>
<p>转化为01背包问题：==价格背包容量设为石头总量的一半，然后找到重量最大的的石头组合，当前得到的组合为最接近总量一半且较少的一堆，再用另外一堆减当前堆即可==</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[j]表示容量（这里说容量更形象，其实就是重量）为j的背包，最多可以背dp[j]这么重的石头。
</code></pre>
</li>
<li>确定递推公式<br>dp[j] = max(dp[j], dp[j - stones[i]] + stones[i]);</li>
<li>dp数组初始化<br>所有石头总量不为负数，初始化为0即可</li>
<li>确定遍历顺序<br>先正序遍历石头，再逆序遍历背包容量</li>
<li>举例推导dp数组<pre><code>j     4 3 2 1
</code></pre>
  s[0]  2 2 2 0<br>  s[0]  4 2 2 0<br>  s[0]  4 3 2 1<br>  s[0]  4 3 2 1</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : stones) sum += num;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> sum / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> target; j &gt;= stones[i - <span class="number">1</span>]; j--)&#123;</span><br><span class="line">            dp[j] = Math.max(dp[j], dp[j - stones[i - <span class="number">1</span>]] + stones[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum - <span class="number">2</span> * dp[target];<span class="comment">// (sum - dp[tatget]) - dp[target]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="494-目标和"><a href="#494-目标和" class="headerlink" title="494.目标和"></a>494.目标和</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230809110521728.png" alt="image-20230809110521728" style="zoom:80%;" align="left">



<p><strong>思路分析</strong></p>
<p>部分带+号，部分带-号，最后求和。本质就是求数组中的一部分数 - 剩下的一部分 = target。</p>
<p>记：带 + 号的元素之和为left，带 - 号的元素之和为right。</p>
<p>则可得到：</p>
<ul>
<li>left - right = target</li>
<li>left + right = sum</li>
</ul>
<p>即 left = (target + sum)/2</p>
<p>从而，题目转换为找出元素和为**(target + sum)/2**的元素组合的个数，本质上也属于背包问题</p>
<p>动态规划五部曲</p>
<p>==注意：本题是组合问题==</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[j]:组成==和为j的组合有dp[j]种方法==
</code></pre>
</li>
<li>确定递推公式<br>不考虑nums[i]的情况下，填满容量为j的背包，有dp[j]种方法。<br>那么考虑nums[i]的话（只要搞到nums[i]），凑成dp[j]就有dp[j - nums[i]] 种方法。<br>例如：dp[j]，j 为5，<br>已经有一个1（nums[i]） 的话，有 dp[4]种方法 凑成 dp[5]。<br>已经有一个2（nums[i]） 的话，有 dp[3]种方法 凑成 dp[5]。<br>已经有一个3（nums[i]） 的话，有 dp[2]中方法 凑成 dp[5]<br>已经有一个4（nums[i]） 的话，有 dp[1]中方法 凑成 dp[5]<br>已经有一个5（nums[i]）的话，有 dp[0]中方法 凑成 dp[5]<br>即:dp[j] += dp[j-nums[i]] —求组合问题都可用类似公式</li>
<li>dp数组初始化<br>由递推公式可知一切递推结果都与dp[0]有关<br>而对于容量为0的背包，只有一种办法，即装0件物品<br>即：dp[0] = 1</li>
<li>确定遍历顺序<br>先正序遍历物品，再逆序遍历容量</li>
<li>举例推导dp数组<br>对于nums = {1,1,1,1,1} target = 3<br>left = (5+3)/2 = 4<pre><code>    j        4 3  2  1 0
</code></pre>
  nums[0]  0 0  0  1 1<br>  nums[1]  0 0  1  2 1<br>  nums[2]  0 1  3  3 1<br>  nums[3]  1 4  6  4 1<br>  nums[4]  5 10 10 5 1</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)  sum += nums[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(Math.abs(target) &gt; sum || (sum + target)%<span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> (sum + target)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[left+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//组成0的方法有一种</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=left;j&gt;=nums[i]; j--)&#123;</span><br><span class="line">             <span class="comment">//当背包容量为j时，dp[j-nums[i]]为考虑nums[i]时的方法数，旧dp[j]为不考虑当前nums[i]的方法数，新的dp[j]取二者和即可</span></span><br><span class="line">             dp[j] += dp[j-nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[left];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="一和零"><a href="#一和零" class="headerlink" title="一和零"></a>一和零</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230809234053970.png" alt="image-20230809234053970" style="zoom: 80%;" align="left">



<p><strong>思路分析</strong></p>
<p>回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</p>
<p>对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。</p>
<p>即当前问题就是一个典型的01背包！ 只不过物品的重量有了两个维度而已。</p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>dp[jZero] [jOne]:最多有jZero个0和jOne个1的最大子集的大小为dp[jZero] [jOne]
</code></pre>
</li>
<li><p>确定递推公式</p>
<p>​    dp[i] [j]不考虑当前str时，子集大小可以由前一个strs里的字符串推导出来。<br>​    dp[i] [j]考虑当前str，当前str有zeroNum个0，oneNum个1, 则子集大小为 dp[i - zeroNum] [j - oneNum] + 1。<br>​    然后我们在遍历的过程中，取dp[i] [j]的最大值。<br>​    所以递推公式：dp[i] [j] = max(dp[i] [j], dp[i - zeroNum] [j - oneNum] + 1);</p>
<p>​    回想一下01背包的递推公式：dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);<br>​    对比一下就会发现，字符串的zeroNum和oneNum相当于物品的重量（weight[i]），字符串本身的个数相当于物品的价值（value[i]）。<br>​    即当前问题就是一个典型的01背包！ 只不过物品的重量有了两个维度而已。</p>
</li>
<li><p>dp数组如何初始化</p>
<pre><code>每个字符串里面的0和1的个数都不为负数，则可以初始化为0，保证递推时dp数组不会被初始值覆盖即可。
</code></pre>
</li>
<li><p>确定遍历顺序</p>
<pre><code>先遍历物品（字符串里面的字符），再遍历背包(即0的个数m和1的个数n)
</code></pre>
</li>
<li><p>举例推导dp数组</p>
<pre><code>以输入：[&quot;10&quot;,&quot;0001&quot;,&quot;111001&quot;,&quot;1&quot;,&quot;0&quot;]，m = 3，n = 3为例
</code></pre>
</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> strs.length;</span><br><span class="line">    <span class="type">int</span>[][] zeroAndOne = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 计算出每个str的0和1的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; strs[i].length(); j++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> strs[i].charAt(j);</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;0&#x27;</span>) zeroAndOne[i][<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">else</span> zeroAndOne[i][<span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//正序遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">// 逆序遍历二维背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= zeroAndOne[i][<span class="number">0</span>]; j--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n; k &gt;= zeroAndOne[i][<span class="number">1</span>]; k--)&#123;</span><br><span class="line">                dp[j][k] = Math.max(dp[j][k], dp[j - zeroAndOne[i][<span class="number">0</span>]][k - zeroAndOne[i][<span class="number">1</span>]] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-方法论-—-完全背包"><a href="#3-方法论-—-完全背包" class="headerlink" title="==3==.方法论 — 完全背包"></a>==3==.方法论 — <strong>完全背包</strong></h3><p>01背包每个物品只能选一次   ——&gt;    完全背包物品可以选无数次</p>
<p>二者区别：</p>
<blockquote>
<p>当dp取二维数组时：遍历顺序一样，都是外正序物品，内正序背包</p>
<p>01背包递推公式：dp[i] [j] = max(==dp[i - 1]== [j], ==dp[i - 1]== [j - weight[i]] + value[i]);</p>
<p>完全背包递推公式：dp[i] [j] = max(dp[i - 1] [j], ==dp[i]== [j - weight[i]] + value[i]);// 当前元素选时，从当前行拿dp[i] [j - weight[i]]</p>
<p>当dp数组取一维时：区别在于==遍历顺序==，01背包遍历背包是逆序遍历，从而保证每个物品只被添加一次。而完全背包因为每个可以添加无限次，则==遍历背包时为正序遍历==</p>
</blockquote>
<p>完全背包场景分类：</p>
<p>1.求极值情况</p>
<blockquote>
<p>dp[0] = 0;// 一般情况</p>
<p>dp[j] = Math.max(dp[j], dp[j - nums[s]] + 1)</p>
</blockquote>
<p>2.求排列组合等所有解的个数</p>
<blockquote>
<p>d[0] = 1;// 一般情况</p>
<p>dp[j] += dp[j - nums[i]];</p>
</blockquote>
<p>方法论 — 完全背包求组合和求排列</p>
<p>当物品可以被多次选择时，有时需要考虑排列解和组合解的问题。</p>
<p>组合：(1,1,2) 与 (2,1,1) 属于一个解，只会计入一次</p>
<p>排列：(1,1,2) 与 (2,1,1) 属于不同解，各自计入一次</p>
<p>常见的==外物品内背包==求解的是==组合解==</p>
<blockquote>
<p>通过外层遍历物品，内层遍历背包容量来计算dp[i]的值时，可以确保使用的硬币的顺序，即先把某一种面值使用完，下一轮循环时不会再使用，从而保证为组合结果</p>
<p>例如，coins = {1,2}计算dp[3]时，一定是先遍历面额为1的硬币，再遍历面额为2的硬币，只会出现以下的组合</p>
<p>​    3 = 1 + 1 + 1</p>
<p>​    3 = 1 + 2</p>
<p>遍历到2时，不会再去遍历1，所有不会出现(1,2)和(2,1)同时出现</p>
</blockquote>
<p>先背包后物品求解的排列解</p>
<blockquote>
<p>正如上述分析的，外层遍历背包容量，则不能保证使用硬币的顺序，因为对于每个容量，都会遍历一次所有的面额</p>
<p>例如coins={1,2} amount = 4 计算dp[3]时，</p>
<p>j=3</p>
<p>​    i=0,coins[0] =1      dp[3] = dp[3] (不考虑面值1) + dp[2] (考虑面值1)</p>
<p>​    i=1,coins[1] =2      dp[3] = dp[3] (不考虑面值2，但是考虑过面值1) + dp[1] (考虑面值2)</p>
<p>j=4</p>
<p>​    i=0,coins[0] =1      dp[4] = dp[4] (不考虑面值1) + dp[3] (考虑面值1,注意，此时dp[3]的值在上一次遍历时已经考虑过面值2以及面值1，所有得到的结果为排列数，即1,1,2和2,1,1是会同时出现)</p>
<p>​    i=1,coins[1] =2      dp[4] = dp[4] (不考虑面值2) + dp[2] (考虑面值2)</p>
</blockquote>
<p>==辨析口诀：先物品得到的解比较少，先背包得到的解比较多。==</p>
<h3 id="103-零钱兑换-—-完全背包求-解的极值"><a href="#103-零钱兑换-—-完全背包求-解的极值" class="headerlink" title="103.零钱兑换 — 完全背包求 解的极值"></a>103.零钱兑换 — 完全背包求 解的极值</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230810151133851.png" alt="image-20230810151133851"></p>
<p><strong>思路</strong></p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[j]:凑足总额为j所需钱币的最少个数
</code></pre>
</li>
<li>确定递推公式<br>得到dp[j]（考虑coins[i]），只有一个来源，dp[j - coins[i]]（没有考虑coins[i]）。<br>凑足总额为j - coins[i]的最少个数为dp[j - coins[i]]，那么只需要加上一个钱币coins[i]即dp[j - coins[i]] + 1就是dp[j]（考虑coins[i]）<br>所以dp[j] 要取所有 dp[j - coins[i]] + 1 中最小的。<br>递推公式：dp[j] = min(dp[j - coins[i]] + 1, dp[j]);</li>
<li>dp数组初始化<br>为了保证递推过程中得到的结果不被初始值覆盖，则dp[j]必出初始化一个最大的数来保证每次更新数值时数据会正确变化<br>此外，递推时初始数据会被dp[0]影响，则dp[0]初始化为0<br>即<pre><code>Arrays.fill(dp,10001);//硬币最大值为10000，所以选取10001，也可选取Integer.MAX_VALUE
dp[0] = 0;
</code></pre>
</li>
<li>确定遍历顺序<br>本题为纯完全背包问题<br>则先正序遍历物品，再正序遍历背包</li>
<li>举例推导dp数组<br>j       1  2  3  4  5<br>coins[0]=1  1  2  3  4  5<br>coins[1]=2      1  2  2  3<br>coins[2]=5                  1</li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//本题外层遍历背包或物品都可以，因为只是求一组解，而不是求可行解的总数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; coins.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> coins[i]; j &lt;= amount; j++)&#123;</span><br><span class="line">            dp[j] = Math.min(dp[j], dp[j-coins[i]]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230810152826054.png" alt="image-20230810152826054" style="zoom:80%;">



<p><strong>思路</strong></p>
<blockquote>
<ol>
<li>确定dp数组以及下标含义<pre><code>dp[j]：和为j的完全平方数的最少数量为dp[j]
</code></pre>
</li>
<li>确定递推公式<br>dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。<br>此时我们要选择最小的dp[j]，所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);</li>
<li>dp数组初始化<br>dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。<br>有同学问题，那0 * 0 也算是一种啊，为啥dp[0] 就是 0呢？<br>看题目描述，找到若干个完全平方数（比如 1, 4, 9, 16, …），题目描述中可没说要从0开始，dp[0]=0完全是为了递推公式。<br>非0下标的dp[j]应该是多少呢？<br>从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖。</li>
<li>确定遍历顺序<br>本题为纯完全背包问题<br>则先正序遍历物品，再正序遍历背包</li>
<li>举例推导dp数组<br>略</li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[]dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    Arrays.fill(dp,<span class="number">10001</span>);</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i*i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i*i; j&lt;=n; j++)&#123;</span><br><span class="line">            dp[j] = Math.min(dp[j],dp[j-i*i]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="518-零钱兑换II-—完全背包求组合解个数—组合问题外物品内背包，即先把物品固定"><a href="#518-零钱兑换II-—完全背包求组合解个数—组合问题外物品内背包，即先把物品固定" class="headerlink" title="518.零钱兑换II —完全背包求组合解个数—组合问题外物品内背包，即先把物品固定"></a>518.零钱兑换II —完全背包求组合解个数—<strong>组合问题外物品内背包，即先把物品固定</strong></h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230810143543250.png" alt="image-20230810143543250" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>完全背包求组合问题</p>
<p>一维数组先正序物品再正序背包即可</p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>dp[j]:凑成金额为j的货币组合有dp[j]种
</code></pre>
</li>
<li><p>确定递推公式<br>当前问题属于组合问题，则递推公式为</p>
<pre><code>dp[j] += dp[j-coins[i]]
</code></pre>
</li>
<li><p>dp数组初始化<br>由递推公式可知后续所有值都与dp[0]有关<br>而对于dp[0],组成金额为0的方法只有一种，即使用0个硬币</p>
</li>
<li><p>确定遍历顺序<br>一般的完全背包问题，先遍历物品还是先遍历背包都可以，因为对于求和来说，内部元素的顺序没有关系<br>但是当前问题是求组合问题，对于组合问题，两个方案的内部元素相同时则只能算一种方案<br>例如：先遍历背包，再遍历物品<br>for (int j = 0; j &lt;= amount; j++) { // 遍历背包容量</p>
<pre><code>for (int i = 0; i &lt; coins.size(); i++) &#123; // 遍历物品
    if (j - coins[i] &gt;= 0) dp[j] += dp[j - coins[i]];
&#125;
</code></pre>
<p>}<br>背包容量的每一个值，都是经过 1 和 5 的计算，包含了{1, 5} 和 {5, 1}两种情况。<br>此时dp[j]里算出来的就是排列数！</p>
<p>即：对于组合问题，先遍历物品，再遍历背包<br>此外，对于完全背包，物品可以重复添加，所有遍历背包时使用正序遍历，即从小到大遍历</p>
</li>
<li><p>举例推导dp数组<br>输入: amount = 5, coins = [1, 2, 5]<br>   j        0  1  2  3  4  5<br>coins[0]=1  1  1  1  1  1  1<br>coins[1]=2  1  1  2  2  3  3<br>coins[2]=5  1  1  2  2  3  4</p>
</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp数组初始化</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;coins.length; i++)&#123;<span class="comment">//正序遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=coins[i]; j&lt;=amount; j++)&#123;<span class="comment">//正序遍历背包</span></span><br><span class="line">            dp[j] += dp[j-coins[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="104-组合问题IV—完全背包求排列解个数—排列问题外背包内物品，即先把背包固定"><a href="#104-组合问题IV—完全背包求排列解个数—排列问题外背包内物品，即先把背包固定" class="headerlink" title="104.组合问题IV—完全背包求排列解个数—排列问题外背包内物品，即先把背包固定"></a>104.组合问题IV—完全背包求排列解个数—<strong>排列问题外背包内物品，即先把背包固定</strong></h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230810144214837.png" alt="image-20230810144214837" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>完全背包求排列问题，一维数组先背包后物品即可。</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[j]:凑成目标正整数为i的排列个数为的dp[j]
</code></pre>
</li>
<li>确定递推公式<br>dp[j]（考虑nums[i]）可以由 dp[j - nums[i]]（不考虑nums[i]） 推导出来。<br>因为只要得到nums[i]，排列个数dp[j - nums[i]]，就是dp[j]的一部分</li>
<li>dp数组初始化<br>dp[0] = 1;</li>
<li>确定遍历顺序<br>由于是完全背包问题，则需要正序遍历物品和正序遍历背包<br>再加上是求排列问题<br>则是先正序遍历背包，再正序遍历物品</li>
<li>举例推导dp数组<br>j  nums[0]=1 nums[1]=2 nums[2]=3<br>1     1         1         1<br>2     1         2         2<br>3     2         3         4<br>4     4         6         7</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">combinationSum4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[target+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=target; j++)&#123;<span class="comment">//外层遍历背包</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;<span class="comment">//内层遍历物品</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=nums[i])dp[j] = dp[j] + dp[j-nums[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="70-爬楼梯-转化为完全背包求排列问题"><a href="#70-爬楼梯-转化为完全背包求排列问题" class="headerlink" title="70.爬楼梯(转化为完全背包求排列问题)"></a>70.爬楼梯(转化为完全背包求排列问题)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230810150919313.png" alt="image-20230810150919313" style="zoom:80%;" align="left">

<p><strong>分析</strong></p>
<p>爬楼梯每次爬一层或两层，爬到楼顶共有多少种方式</p>
<p>可转换成 有无限个1和2，组成j(楼高)有多少种方式</p>
<blockquote>
<ol>
<li>确定dp数组以及下标含义<br>   dp[j]:爬到j级台阶有多少种方式</li>
<li>确定递推公式<br> dp[j] = dp[j] + dp[j-i] //i取1和2</li>
<li>dp数组初始化<br> 既然递归公式是 dp[i] += dp[i - j]，那么dp[0] 一定为1，dp[0]是递归中一切数值的基础所在，如果dp[0]是0的话，其他数值都是0了。</li>
<li>确定遍历顺序<br> 完全背包求排列问题<br> 先正序遍历背包，再正序遍历物品</li>
<li>举例推导递推数组<br> 略</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=i) dp[j] += dp[j-i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139.单词拆分"></a>139.单词拆分</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230811134509784.png" alt="image-20230811134509784" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[j]:字符串长度为j的话，若dp[j]为1或0，1表示可以拆分为一个或多个在字典中出现的单词，0表示不能
</code></pre>
</li>
<li>确定递推公式<br>j用于遍历背包，i用于遍历物品<br>如果dp[i]为true，且[i,j]这个区间的子串出现在字典里，那么dp[j]一定是true(i&lt;j)</li>
<li>dp数组初始化<br>dp[j]依赖于dp[i]的值，而i&lt;j，所以dp[0]就是递归的根基，dp[0]初始化为1</li>
<li>确定遍历顺序<br>由于物品和背包的遍历次序只是决定后得到的结果的组合还是排列，本题要求的是是否出现，则二者都可以<br>==但是本题需要求子串，所以先遍历背包，再遍历物品==</li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(String str : wordDict) set.add(str);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(i, j);</span><br><span class="line">            <span class="comment">//依次截取0~j,1~j,2~j，i~j...等长度的字符串，查看list中是否有该字符串，</span></span><br><span class="line">            <span class="comment">// 再查看其前面0~i部分是否可拆分，若二者都可以，则说明当前长度的字符串可拆分</span></span><br><span class="line">            <span class="keyword">if</span>(set.contains(str) &amp;&amp; dp[i] == <span class="number">1</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n] == <span class="number">1</span> ? <span class="literal">true</span> :<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-方法论-—-多重背包"><a href="#4-方法论-—-多重背包" class="headerlink" title="==4==.方法论 — 多重背包"></a>==4==.方法论 — <strong>多重背包</strong></h3><blockquote>
<ul>
<li>01背包：物品数量为1</li>
<li>完全背包：物品数量无限</li>
<li>多重背包：物品数量有限且不一定为1</li>
</ul>
<p>多重背包可以转化为01背包：将每种物品的数量在01背包里面再遍历一遍</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">multiPack</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] weight = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;<span class="comment">//物品重量</span></span><br><span class="line">    <span class="type">int</span>[] value = &#123;<span class="number">15</span>,<span class="number">20</span>,<span class="number">30</span>&#125;;<span class="comment">//物品价值</span></span><br><span class="line">    <span class="type">int</span>[] nums = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;<span class="comment">//物品个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">bagWeight</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//背包容量</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[bagWeight+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;weight.length; i++)&#123;<span class="comment">//遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=bagWeight; j&gt;=weight[i]; j--)&#123;<span class="comment">//遍历背包</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=nums[i] &amp;&amp; j-k*weight[i]&gt;=<span class="number">0</span>; k++)&#123;<span class="comment">//遍历物品个数</span></span><br><span class="line">                dp[j] = Math.max(dp[j],dp[j-k*weight[i]]+k*value[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(dp[bagWeight]);</span><br><span class="line">    <span class="comment">//时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量</span></span><br><span class="line">    <span class="comment">//从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​       </p>
<h3 id="背包系列结束"><a href="#背包系列结束" class="headerlink" title="背包系列结束"></a>背包系列结束</h3><h3 id="5-方法论-—-状态DP"><a href="#5-方法论-—-状态DP" class="headerlink" title="==5==.方法论 — 状态DP"></a>==5==.方法论 — <strong>状态DP</strong></h3><p>线性状态dp也是线性dp的一种，但稍复杂一点。他们的本质区别在：<strong>线性dp只需要考虑一个状态的递推，状态dp需要考虑多个变量之间的动态递推</strong>。</p>
<p><strong>解题模版</strong></p>
<p>以打家劫舍为例，状态dp中有多个维度，也就是<strong>每个房子既有可能被偷，也有可能不被偷，两种情况都要考虑</strong>，换句话说，<strong>无论前面一次递推结果如何，后一次都要考虑两种情况</strong></p>
<blockquote>
<p><strong>状态dp的无敌模板：增加维度</strong><br>将dp数组从一维变成二维<code>dp[i][j]</code><br>其中第二维的<code>j</code>只能取<code>0</code>或<code>1</code>，用来表示当前的房子是否被偷<br><code>dp[i][0]</code>表示第<code>i</code>栋房子<strong>没被偷</strong>，<code>dp[i][1]</code>表示第<code>i</code>栋房子<strong>被偷</strong>了<br>所以我们每次都要维护同一房子的两个变量，对应的动态转移方程也有两个</p>
<p>如果选择不偷当前的第i栋房子，那么第i - 1栋房子可以被偷，也有可能没被偷<br><code>dp[i][0] = max(dp[i - 1][1], dp[i - 1][0])</code><br>如果选择偷当前的第i栋房子，那么第i - 1栋房子一定不能被偷过<br><code>dp[i][1] = dp[i - 1][0] + price[i]</code></p>
</blockquote>
<h3 id="打家劫舍-—-状态DP"><a href="#打家劫舍-—-状态DP" class="headerlink" title="打家劫舍 — 状态DP"></a>打家劫舍 — 状态DP</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230812110115303.png" alt="image-20230812110115303" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i]:考虑下标i(包括i)之前的范围，可以偷窃的最多金额为dp[i]
</code></pre>
</li>
<li>确定递推公式<br>决定dp[i]的因素就是第i房间偷还是不偷。<br>如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i] ，即：第i-1房一定是不考虑的，找出 下标i-2（包括i-2）以内的房屋，最多可以偷窃的金额为dp[i-2] 加上第i房间偷到的钱。<br>如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房，（注意这里是考虑，并不是一定要偷i-1房，这是很多同学容易混淆的点）<br>然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);</li>
<li>dp数组初始化<br>从递推公式dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);可以看出，递推公式的基础就是dp[0] 和 dp[1]<br>从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);</li>
<li>确定递推顺序<br>dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！</li>
<li>举例推导dp数组<br>nums = {1,2,3,1}时<br>dp[0] = 1;<br>dp[2] = 2;<br>dp[3] = 4;<br>dp[4] = 4;</li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// dp[i][0]表示第i间房不偷，dp[i][1]表示第i间房偷</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维滚动数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dp0;</span><br><span class="line">        dp0 = Math.max(dp0, dp1);</span><br><span class="line">        dp1 = temp + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp0, dp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打家劫舍II-—-环形DP转换为两次线性DP"><a href="#打家劫舍II-—-环形DP转换为两次线性DP" class="headerlink" title="打家劫舍II — 环形DP转换为两次线性DP"></a>打家劫舍II — 环形DP转换为两次线性DP</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230812112200067.png" alt="image-20230812112200067" style="zoom:80%;" align="left">



<p>思路分析</p>
<p>在上一题的基础上，房屋的排列从直线变成环形，即首尾的房屋不能同时偷窃</p>
<blockquote>
<p>对于不能同时偷窃首尾，则只需要分类讨论即可</p>
<ul>
<li>偷窃时不考虑最后一个房屋</li>
<li>偷窃时不考虑最开始的房屋</li>
</ul>
<p>最后取二者最大值即可</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">return</span> Math.max(robPart(nums, <span class="number">0</span>, n - <span class="number">1</span>), robPart(nums, <span class="number">1</span>, n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">robPart</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> begin, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//int n = nums.length;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">dp0</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> nums[begin];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> begin + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dp0;</span><br><span class="line">        dp0 = Math.max(dp0, dp1);</span><br><span class="line">        dp1 = temp + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.max(dp0, dp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打家劫舍III-—-树形DP入门"><a href="#打家劫舍III-—-树形DP入门" class="headerlink" title="打家劫舍III — 树形DP入门"></a>打家劫舍III — 树形DP入门</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230812113528476.png" alt="image-20230812113528476" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>在前两题的基础之上，房屋的摆放成树形结构</p>
<blockquote>
<p>这道题目算是树形dp的入门题目，因为是在树上进行状态转移，我们在讲解二叉树的时候说过递归三部曲，<br>那么下面我以递归三部曲为框架，其中融合动规五部曲的内容来进行讲解。</p>
<ol>
<li>确定递归函数的参数和返回值<pre><code>由于要求得到一个节点偷与不偷的两个状态得到的金钱，则返回值就是一个长度为2的数组，该数值也就是动态规划中的dp数组
所以dp数组以及下标的含义为：**下标为0记录不偷该节点**得到的最大金钱，**下标为1记录偷该节点**得到的最大金钱
即本题的**dp数组就是一个长度为2的数组**
</code></pre>
</li>
<li>确定终止条件<pre><code>在遍历的过程中，如果遇到空节点的话，很明显，无论偷还是不偷都是0，所以就返回
该步骤也相当于的dp数组的初始化
</code></pre>
</li>
<li>确定遍历顺序<pre><code>首先需要明确的是==使用后序遍历==，因为需要递归函数的返回值来做动态规划的递推计算
通过递归左节点，得到左节点偷与不偷的金钱
通过递归右节点，得到右节点偷与不偷的金钱
</code></pre>
</li>
<li>确定单层递归的逻辑<pre><code>   如果偷当前节点，则左右子节点不偷: `res[1] = root.val + left[0] + right[0];`
   如果不偷当前节点，则左右子节点可以偷，具体偷不偷选取最大值:
</code></pre>
<code> res[0] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]);</code><pre><code>   最后当前节点的状态就是&#123;res[0], res[1]&#125;; 即：&#123;不偷当前节点得到的最大金钱，偷当前节点得到的最大金钱&#125;
</code></pre>
</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] res = robAction1(root);</span><br><span class="line">    <span class="keyword">return</span> Math.max(res[<span class="number">0</span>],res[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] robAction1(TreeNode root)&#123;</span><br><span class="line">    <span class="comment">//dp数组以及下标的含义为：下标为0记录不偷该节点得到的最大金钱，下标为1记录偷该节点得到的最大金钱</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//递归出口</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//后序遍历，先递归得到子节点的dp数组</span></span><br><span class="line">    <span class="type">int</span>[] left = robAction1(root.left);</span><br><span class="line">    <span class="type">int</span>[] right = robAction1(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再得到当前节点的dp数组，res[0]为不偷当前节点的最大金钱值，res[1]为偷当前节点的最大金钱值</span></span><br><span class="line">    res[<span class="number">0</span>] = Math.max(left[<span class="number">0</span>],left[<span class="number">1</span>]) + Math.max(right[<span class="number">0</span>],right[<span class="number">1</span>]);</span><br><span class="line">    res[<span class="number">1</span>] = root.val + left[<span class="number">0</span>] + right[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机-买卖一次"><a href="#买卖股票的最佳时机-买卖一次" class="headerlink" title="买卖股票的最佳时机(买卖一次)"></a>买卖股票的最佳时机(买卖一次)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230812115834928.png" alt="image-20230812115834928" style="zoom:80%;" align="left">



<p><strong>方法一 — 状态DP</strong></p>
<blockquote>
<p>1.确定dp数组以及下标的含义<br>    <code>dp[i] [0]</code>表示第 i 天持有股票所得最多现金。规定最开始现金为 0，如果第 i 天买入股票，则当前现金为-prices[i]<br>    <code>dp[i] [1]</code>表示第 i 天不持有股票所得最多现金，这里的持有不代表当天买入，也可以是以前买入今天保持现状</p>
<p>2.确定递推公式<br>        第i天持有股票即<code>dp[i] [0]</code>，持有股票的状态可以由两个情况推出：1.今天之前有股票在手，但是今天不卖出 2.今天之前没有股票在手，今天买入股票</p>
<ul>
<li><p>第 i-1 天持有股票，那么就保持现状，所得现金即为昨天持有股票的所得现金：<code>dp[i-1] [0]</code></p>
</li>
<li><p>第 i 天买入股票，所得现金即为今天买入股票后所得现金：<code>-prices[i]</code></p>
</li>
</ul>
<p><code>dp[i] [0]</code>应该选所得现金最大的，所以<code>dp[i] [0] = max(dp[i - 1] [0], -prices[i]);</code></p>
<p>==tips==：第 i 天买入股票不能用前一天不持有股票而今天持有股票<code>dp[i - 1] [1] - prices[i]</code>来考虑，因为股票只允许买一次，而前一天不持有股票的状态考虑了之前买卖股票的情况，只能用<code>-prices[i]</code>来考虑。允许多次买卖时，则可使用前一天不持有来考虑。</p>
<p>​        第i天不持有股票即<code>dp[i] [1]</code>， 不持有股票的状态可以由两个情况推出来：1.今天之前没有股票，今天也不买入 2.今天之前有股票在手，今天卖出</p>
<ul>
<li><p>第 i-1天 就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：</p>
<p><code>dp[i - 1] [1]</code></p>
</li>
<li><p>第 i 天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：</p>
<p><code>prices[i] + dp[i - 1] [0]</code></p>
<p>同样dp[i] [1]取最大的，<code>dp[i] [1] = max(dp[i - 1] [1], prices[i] + dp[i - 1] [0]);</code></p>
</li>
</ul>
<p>3.dp数组初始化<br>由递推公式可知所有递推结果都基于dp[0] [0]和dp[0] [1]<br>第一天买入股票：dp[0] [0] = -prices[0];<br>第一天不买入股票：dp[0] [1] = 0;</p>
<p>4.确定遍历顺序<br>从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。</p>
<p>5.举例推导dp数组<br>输入[7,1,5,3,6,4]<br>dp[i] [0] dp[i] [1]<br>     -7           0<br>     -1           0<br>     -1           4<br>     -1           4<br>     -1           5<br>     -1           5</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],-prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心解法: 记录最左最小值，遍历price[i]时减去最小值得到差值，最大的差值就是最大利润</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit1</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        <span class="comment">//记录最小值</span></span><br><span class="line">        minPrice = Math.min(minPrice,prices[i]);</span><br><span class="line">        <span class="comment">//记录最大差值</span></span><br><span class="line">        res = Math.max(res,prices[i]-minPrice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机II-多次买卖但持有一只"><a href="#买卖股票的最佳时机II-多次买卖但持有一只" class="headerlink" title="买卖股票的最佳时机II(多次买卖但持有一只)"></a>买卖股票的最佳时机II(多次买卖但持有一只)</h3><p><strong>思路</strong></p>
<blockquote>
<p>本题的dp数组与上一题的完全相同，唯一的区别在于dp[i] [0]的递推公式：<br> dp[i] [0]表示第i天持有股票时的最大现金数，可以从两个角度推出<br>     -第i天之前持有股票，第i天不买股票，则dp[i] [0] = dp[i-1] [0]<br>     -第i天买入股票，由于只能同时持有一只股票，则递推结果要从前一天不持有股票dp[i-1] [1]来推导，则dp[i] [0] = dp[i-1] [1]-prices[i]<br>     即：dp[i] [0] = Math.max(dp[i-1] [0],dp[i-1] [1]-prices[i]);</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        <span class="comment">//持有股票的最大现金数</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]-prices[i]);</span><br><span class="line">        <span class="comment">//不持有股票的最大现金数</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>]+prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//贪心解法：收集每天的正利润便可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit1</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        <span class="comment">//若当天有利润，则可加入最后的总利润</span></span><br><span class="line">        result += Math.max(prices[i] - prices[i-<span class="number">1</span>],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机III-最多买卖两次"><a href="#买卖股票的最佳时机III-最多买卖两次" class="headerlink" title="买卖股票的最佳时机III(最多买卖两次)"></a>买卖股票的最佳时机III(最多买卖两次)</h3><p><strong>思路</strong></p>
<p>将前面持有一次股票的两种状态扩展为持有一次股票的四种状态</p>
<p>第一次持有，第一次卖出，第二次持有，第二次卖出</p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>某天的股票状态有4种： 0.第一次买入 1.第一次卖出 2.第二次买入 3.第二次卖出
dp[i] [j]中i为第i天，j为[0-3]四种状态，==dp[i] [j]表示第i天的状态j所剩下最大现金==
</code></pre>
</li>
<li><p>确定递推公式<br>需要注意：dp[i] [0]，表示的是第i天，持有股票的状态，并不是指要第i天买入股票，这是很多同学容易陷入的误区。<br>达到dp[i] [0]状态，有两个具体操作:</p>
<pre><code>-操作一：第i天买入股票，那么dp[i] [0] = - prices[i]
-操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i] [0] = dp[i-1] [0]
</code></pre>
<p>那么dp[i] [0]究竟选 - prices[i]，还是dp[i-1] [0]呢？<br>一定是选最大的，所以 dp[i] [0] = max(- prices[i], dp[i - 1] [0]);</p>
<p>同理，dp[i] [1]也有两个操作</p>
<pre><code>-操作一：第i天卖出股票，那么dp[i] [1] = dp[i-1] [0] + prices[i]
-操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i] [1] = dp[i-1] [1]
</code></pre>
<p>所以dp[i] [1] = max(dp[i - 1] [0] + prices[i], dp[i - 1] [1])</p>
<p>同理可推出剩下状态部分：<br>dp[i] [2] = max(dp[i - 1] [2], dp[i - 1] [1] - prices[i]);<br>dp[i] [3] = max(dp[i - 1] [3], dp[i - 1] [2] + prices[i]);</p>
</li>
<li><p>dp数组初始化<br>第0天做第一次买入操作，则dp[0] [0] = -prices[0]<br>由于卖出操作一定是收获利润，则第0天第一次做卖出操作利润一定不大于0，dp[0] [1] = 0<br>第0天做第二次买入操作的情况可能较难理解，其实可以理解为第一天已经买入卖出一次，此时在买入就是第二次买入，即dp[0] [2] = -prices[0]<br>同理，第0天做第二次卖出，dp[0] [3] = 0</p>
</li>
<li><p>确定遍历顺序<br>由递推公式可知从前往后遍历</p>
</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">4</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">// 第一次买入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">// 第一次卖出</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = -prices[<span class="number">0</span>];<span class="comment">// 第二次买入</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">3</span>] = <span class="number">0</span>;<span class="comment">// 第二次卖出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//当天持有第1枚股票 </span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], -prices[i]);</span><br><span class="line">        <span class="comment">//当天不持有第1枚股票 </span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        <span class="comment">//当天持有第2枚股票 </span></span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">        <span class="comment">//当天不持有第2枚股票 </span></span><br><span class="line">        dp[i][<span class="number">3</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">3</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] + prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回最后一天不持有股票的两种状态的最大值</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机IV-最多买卖-k-次"><a href="#买卖股票的最佳时机IV-最多买卖-k-次" class="headerlink" title="买卖股票的最佳时机IV(最多买卖 k 次)"></a>买卖股票的最佳时机IV(最多买卖 k 次)</h3><p>思路</p>
<p>与上一题相似，从两次变为多次</p>
<p>则对于每支股票，都有2*k中状态，第一次持有，第一次不持有，第二次持有，第二次不持有…</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>*k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>*i] = -prices[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">0</span>][<span class="number">2</span>*i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k; j++)&#123;</span><br><span class="line">                <span class="comment">//  每只股票第一次持有的状态，不需要从上一只股票进行转移。</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> j == <span class="number">0</span> ? <span class="number">0</span> : dp[i - <span class="number">1</span>][<span class="number">2</span>*j - <span class="number">1</span>];</span><br><span class="line">                dp[i][<span class="number">2</span>*j] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>*j], temp-prices[i]);</span><br><span class="line">                dp[i][<span class="number">2</span>*j + <span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">2</span>*j + <span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>*j] + prices[i]);</span><br><span class="line">                <span class="keyword">if</span>(i == n - <span class="number">1</span>) res = Math.max(res, dp[i][<span class="number">2</span>*j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机含冷冻期"><a href="#买卖股票的最佳时机含冷冻期" class="headerlink" title="买卖股票的最佳时机含冷冻期"></a>买卖股票的最佳时机含冷冻期</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240304182510919.png" alt="image-20240304182510919" style="zoom:67%;" align="left">

<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>dp[i] [j]表示第i天状态为j时所得现金的最大值
j为[0-2]三种状态
0:目前手上持有股票
1:目前手上不持有股票,且是今天刚卖出，即明天为冷冻期
2:目前手上不持有股票，且不是今天卖出，即明天不为冷冻期
</code></pre>
</li>
<li><p>确定递推公式<br>dp[i] [0]主要有两种来源：</p>
<pre><code>-今天之前买进的股票 dp[i-1] [0]
-今天刚刚买入的股票,若今天买入，则昨天不能持有股票(0)或者卖出股票(1),即 dp[i-1] [2]-prices[i]
</code></pre>
<p>即<strong>dp[i] [0] = max(dp[i-1] [0],dp[i-1] [2]-prices[i])</strong></p>
<p>dp[i] [1]主要有两种来源：</p>
<pre><code>-继承昨天不持有股票状态 dp[i-1] [1]
-今天之前持有股票且今天卖出 dp[i-1] [0]+prices[i]
</code></pre>
<p>即<strong>dp[i] [1] = max(dp[i-1] [1],dp[i-1] [0]+prices[i])</strong></p>
<p>dp[i] [2]主要有两种来源</p>
<pre><code>-继承昨天的不持有股票状态 dp[i-1] [2]
-因为今天可能为冷冻期，所以昨天可能卖出了股票 dp[i-1] [1]
</code></pre>
<p>即<strong>dp[i] [2] = max(dp[i-1] [2],dp[i-1] [1])</strong></p>
</li>
<li><p>dp数组初始化<br>dp[0] [0] = -prices[0]<br>dp[0] [1] = 0<br>dp[0] [2] = 0</p>
</li>
<li><p>确定遍历顺序<br>从前往后</p>
</li>
<li><p>举例推导dp数组</p>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];<span class="comment">// 持有股票</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;<span class="comment">// 不持有股票，今天卖出</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">0</span>;<span class="comment">// 不持有股票，不是今天卖出</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>] - prices[i]);</span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] + prices[i]);</span><br><span class="line">        dp[i][<span class="number">2</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">1</span>], dp[n - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="买卖股票的最佳时机含手续费"><a href="#买卖股票的最佳时机含手续费" class="headerlink" title="买卖股票的最佳时机含手续费"></a>买卖股票的最佳时机含手续费</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230818111412761.png" alt="image-20230818111412761"></p>
<p>思路</p>
<p>方法一 — 在多次买卖但持有一只的基础上加手续费即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[prices.length][<span class="number">2</span>];</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;prices.length; i++)&#123;</span><br><span class="line">        <span class="comment">//第i天持有股票</span></span><br><span class="line">        dp[i][<span class="number">0</span>] = Mat.max(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>] - prices[i]);</span><br><span class="line">        <span class="comment">//第i天不持有股票</span></span><br><span class="line">        dp[i][<span class="number">1</span>] = Math.max(dp[i-<span class="number">1</span>][<span class="number">1</span>],dp[i-<span class="number">1</span>][<span class="number">0</span>] + prices[i] - fee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[prices.length-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二 — 贪心</p>
<p>思路：此题的贪心，贪就贪在他是没有真的卖出去手中的股票的。</p>
<ol>
<li>首先我们遍历数组的时候，是需要记录下当前时刻之前的最小价格买入股，以保证我手里的股票是以最低价格买入的。</li>
<li>其次，当遇到本次股票可以让我获利时，我就收割本次利润，并且把购买成本换成本次股票价钱。关键点来了，为什么要有把购买成本换成本次股票价钱这一步操作呢，因为本次利润只是收割，我并没有真正的把我手上的股票的卖出去（如果卖出去，那成本应该重置为0，并且你下一次再想买进的话就需要再付一次手续费了）。</li>
<li>为什么这样做呢，拿prices = [1,3,7,5,10,3], fee = 3 举例。显而易见我们应该在第一天买入保证我的最低成本为1+3=4，然后我在遍历到7的时候应该卖出去了，因为它可以让我获得7-4=3的利润，但是此时要不要真的卖呢，我不知道。再往后遍历，遇到了10。两种情况<ul>
<li>我在7的时候真卖了 那我就需要在5的时候购入成本为5+3=8</li>
<li>我在7的时候假卖，成本为7，(前面说了假卖的时候要把成本换成本次价钱)。也可以理解为假卖就是没卖，成本为1+3=4，利润为10-4=6。 显而易见我假卖的话可以收获更多，这就是贪心</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">but</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">        buy = Math.min(prices[i] + fee, buy);</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; buy)&#123;</span><br><span class="line">            profit += prices[i] - buy;</span><br><span class="line">            buy = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使序列递增的最小交换次数"><a href="#使序列递增的最小交换次数" class="headerlink" title="使序列递增的最小交换次数"></a>使序列递增的最小交换次数</h3><ul>
<li><p>题目</p>
<blockquote>
<p>我们有两个长度相等且不为空的整型数组 nums1 和 nums2 。在一次操作中，我们可以交换 nums1[i] 和 nums2[i]的元素。</p>
<p>例如，如果 nums1 = [1,2,3,8] ， nums2 =[5,6,7,4] ，你可以交换 i = 3 处的元素，得到 nums1 =[1,2,3,4] 和 nums2 =[5,6,7,8] 。<br>返回 使 nums1 和 nums2 严格递增 所需操作的最小次数 。</p>
<p>数组 arr 严格递增 且  arr[0] &lt; arr[1] &lt; arr[2] &lt; … &lt; arr[arr.length - 1] 。</p>
<p>注意：</p>
<p>用例保证可以实现操作。</p>
<p>示例 1:</p>
<p>输入: nums1 = [1,3,5,4], nums2 = [1,2,3,7]<br>输出: 1<br>解释:<br>交换 A[3] 和 B[3] 后，两个数组如下:<br>A = [1, 3, 5, 7] ， B = [1, 2, 3, 4]<br>两个数组均为严格递增的。<br>示例 2:</p>
<p>输入: nums1 = [0,3,5,8,9], nums2 = [2,1,4,6,9]<br>输出: 1</p>
</blockquote>
</li>
<li><p>动态规划五部曲</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<br>由于两个数组只需要交换相同位置上的元素，则每个位置的状态都有两种，0：交换:1：不交换。<br>dp[i] [j]：到位置i为止使数组nums1和nums2满足严格递增并且位置i的状态为j时的最小操作数。<br>   即dp[i] [0]表示到位置 i 为止使数组 nums1和 nums2 满足严格递增并且位置 i 不进行交换操作的最小操作数<br>   即dp[i] [1]表示到位置 i 为止使数组 nums1和 nums2 满足严格递增并且位置 i 进行交换操作的最小操作数</li>
<li>确定递推公式<br>鉴于题目有解，则数组元素一定满足以下情况之一或同时满足<br>  情况一： nums1[i] &gt; nums1[i-1] 且 nums2[i] &gt; nums2[i-1]<br>  情况二： nums1[i] &gt; nums2[i-1] 且 nums2[i] &gt; nums1[i-1]<br>  1.只满足情况一不满足情况二时 位置i的交换情况需要与i-1的交换情况保持一致，否则是无效交换<br>dp[i] [0] = dp[i-1] [0]<br>dp[i] [1] = dp[i-1] [1] + 1<br>  2.只满足情况二而不满足情况一时 位置i的交换情况与i-1相反，即只能交换其中一个<br>dp[i] [0] = dp[i-1] [1]<br>dp[i] [1] = dp[i-1] [0] + 1<br>  3.两种情况同时满足时，取较小值即可<br>dp[i] [0] = min(dp[i-1] [0], dp[i-1] [1])<br>dp[i] [1] = min(dp[i-1] [1] + 1, dp[i-1] [0] + 1)</li>
<li>dp数组初始化<br>位置0是否交换都为合法情况，可初始化dp[0] [0] = 0,dp[0] [1] = 1</li>
<li>确定遍历顺序<br>由递推公式可知每个状态都只与前一个状态有关，则遍历顺序从前往后</li>
</ol>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSwap</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt; nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums2[i-<span class="number">1</span>] &amp;&amp; nums1[i] &gt; nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums1[i-<span class="number">1</span>])&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>, dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums1[i] &gt; nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums1[i-<span class="number">1</span>])&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i-<span class="number">1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[len-<span class="number">1</span>][<span class="number">0</span>],dp[len-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//滚动数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minSwap1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">at</span> <span class="operator">=</span> a, bt = b;<span class="comment">//记录旧值，即前面一个元素的状态</span></span><br><span class="line">        a = b = n;</span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt; nums1[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums2[i-<span class="number">1</span>])&#123;</span><br><span class="line">            a = Math.min(a, at);</span><br><span class="line">            b = Math.min(b, bt + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果两个条件同时满足，此时a的值就是上面一个if计算出来的值，从而达到取较小值的效果</span></span><br><span class="line">        <span class="keyword">if</span>(nums1[i] &gt; nums2[i-<span class="number">1</span>] &amp;&amp; nums2[i] &gt; nums1[i-<span class="number">1</span>])&#123;</span><br><span class="line">            a = Math.min(a,bt);</span><br><span class="line">            b = Math.min(b,at + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Math.min(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="43-将字符串翻转到单调递增"><a href="#43-将字符串翻转到单调递增" class="headerlink" title="43.将字符串翻转到单调递增"></a>43.将字符串翻转到单调递增</h3><ul>
<li><p>题目</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240307113356511.png" alt="image-20240307113356511" style="zoom:67%;" align="left"></li>
<li><p>动态规划五部曲</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>每个位置都有0和1两种字符状态，我们使用j记录该状态，即j取0时表示当前字符为0，j取1时表示当前字符为1
从而可知：dp[i] [j]表示到位置i为止保证 s 单调递增且元素i的状态为j
</code></pre>
</li>
<li>确定递推公式<br>情况一：当前字符为’0’时<pre><code>dp[i] [0]的前面字符必须全部为0，则该状态只能由前一个字符的dp[i-1] [0]而来，即dp[i] [0] = dp[i-1] [0]
dp[i] [1]的前面字符可以为0或1，则该状态可以由前面一个字符的dp[i-1] [0]和dp[i-1] [1]而来，取较小值再+1(因为当前字符为0，翻转为1需要+1)即可，
    即dp[i] [1] = min(dp[i-1] [0],dp[i-1] [1])+1
</code></pre>
情况二：当前字符为’1’时<pre><code>dp[i] [0]的前面字符必须全部为0，则该状态只能由前一个字符的dp[i-1] [0]而来,由于需要翻转为&#39;0&#39;，所以还需要+1，即dp[i] [0] = dp[i-1] [0] + 1
dp[i] [1]的前面字符可以为0或1，则该状态可以有前面一个字符的dp[i-1] [0]和dp[i-1] [1]而来，取较小值(因为当前字符为1，所以无需翻转)即可，
    即dp[i] [1] = min(dp[i-1] [0],dp[i-1] [1])
</code></pre>
</li>
<li>dp数组初始化<br>创建dp数组时，有效数据从i=1开始，即dp[0] [0]和dp[0] [1]置为0即可</li>
<li>确定遍历顺序<br>由递推公式可知，每个元素与其前一位元素满足题目条件即可，所以从前往后遍历</li>
</ol>
</blockquote>
<p>方法二：前缀和+枚举</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240307112428598.png" alt="image-20240307112428598" style="zoom: 67%;" align="left"></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DP</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minFlipsMonoIncr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.min(dp[i-<span class="number">1</span>][<span class="number">0</span>],dp[i-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.min(dp[len][<span class="number">0</span>],dp[len][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 前缀和+枚举</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFlipsMonoIncr</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] c = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> c.length;</span><br><span class="line">    <span class="type">int</span>[] preSum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) preSum[i] = preSum[i - <span class="number">1</span>] + (c[i - <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> preSum[i - <span class="number">1</span>]；<span class="comment">// i位置前面 1 的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> n - i - (preSum[n] - preSum[i]);<span class="comment">// i位置后面 0 的个数</span></span><br><span class="line">        res = Math.min(res, left + right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-方法论-—-线性DP"><a href="#6-方法论-—-线性DP" class="headerlink" title="==6==.方法论 — 线性DP"></a>==6==.方法论 — <strong>线性DP</strong></h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814101116174.png" alt="image-20230814101116174"></p>
<h3 id="最长上升子序列-子序列不连续"><a href="#最长上升子序列-子序列不连续" class="headerlink" title="最长上升子序列(子序列不连续)"></a>最长上升子序列(子序列不连续)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814101447099.png" alt="image-20230814101447099" style="zoom:80%;" align="left">



<p><strong>方法一 — DP</strong></p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i]:表示**i之前包括i的以nums[i]结尾的最长递增子序列的长度**
</code></pre>
</li>
<li>确定递推公式<br>位置i的最长递增子序列等于j从0~i-1各个位置的最长升序子序列+1的最大值<br>即：if(nums[i]&gt;nums[j]) dp[i] = max(dp[i],dp[j]+1)<br>注意这里不是要dp[i] 与 dp[j] + 1进行比较，而是我们要取dp[j] + 1的最大值。</li>
<li>dp数组初始化<br>每个元素自身都算一个递增元素，则dp[i]的初始值都为1</li>
<li>确定遍历顺序<br>从前往后</li>
<li>举例推导dp数组<br>输入数组：int[] n = {10,9,2,5,3,7,101,18};<br>10结尾  1 1 1 1 1 1 1 1<br>9结尾   1 1 1 1 1 1 1 1<br>2结尾   1 1 1 1 1 1 1 1<br>5结尾   1 1 1 2 1 1 1 1<br>3结尾   1 1 1 2 2 1 1 1<br>7结尾   1 1 1 2 2 3 1 1<br>101结尾 1 1 1 2 2 3 4 1<br>18结尾  1 1 1 2 2 3 4 4</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//记录最大递增子序列值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//初始化dp数组，初始值都为1</span></span><br><span class="line">    Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//每遍历一个元素，都要将其前面的元素再遍历一次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[j]) dp[i] = Math.max(dp[i],dp[j]+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[i] &gt; res) res = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二 — 二分查找</p>
<p>新建数组 d, 用于存最长上升子序列。对原序列进行遍历，根据不同情况将每位元素插入 d 中。</p>
<ul>
<li>如果当前元素 <code>nums[i] &gt; d[n - 1]</code>，则直接保存在数组末尾，保持d递增</li>
<li>如果当前元素 <code>nums[i]  &lt; d[n - 1]</code>，则使用二分查找在 d 中查找第一个大于 nums[i] 的数，并进行替换，从而保持 d 递增的同时，内部元素的递增幅度最小</li>
<li>如果当前元素 <code>nums[i]  = d[n - 1]</code>，则跳过该元素。</li>
</ul>
<p>总之，思想就是让 d 中存储比较小的元素，即递增幅度最小。这样，d 未必是真实的最长上升子序列，但长度是对的。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    d.add(nums[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; d.get(len - <span class="number">1</span>))&#123;</span><br><span class="line">            d.add(nums[i]);</span><br><span class="line">            len++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == d.get(len - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(d.get(mid) &gt;= nums[i]) right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            d.set(left, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最大子数组和-–-求最大连续和"><a href="#最大子数组和-–-求最大连续和" class="headerlink" title="最大子数组和 – 求最大连续和"></a>最大子数组和 – 求最大连续和</h3><blockquote>
<p>走完这一生 如果我和你在一起会变得更好，那我们就在一起，否则我就丢下你。 我回顾我最光辉的时刻就是和不同人在一起，变得更好的最长连续时刻</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-subarray/solution/dong-tai-gui-hua-fen-zhi-fa-python-dai-ma-java-dai/">经典动态规划问题（理解「无后效性」） - 最大子数组和 - 力扣（LeetCode）</a></p>
<ul>
<li><p>题目</p>
<blockquote>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例: 输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6</p>
</blockquote>
</li>
<li><p>动态规划五部曲</p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>dp[i]表示下标i之前(包括i)的最大子数组之和
</code></pre>
</li>
<li><p>确定递推公式<br>dp[i]只有两个方向可以推出来：</p>
<ul>
<li>dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和</li>
<li>nums[i] (因为子数组至少包含一个元素)，即：从头开始计算当前连续子序列和</li>
</ul>
<p>一定是取最大的，所以dp[i] = max(dp[i - 1] + nums[i], nums[i]);</p>
</li>
</ol>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=nums.length; i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>]+nums[i-<span class="number">1</span>],nums[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(dp[i]&gt;res) res = dp[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=nums.length; i++)&#123;</span><br><span class="line">        dp = Math.max(dp + nums[i-<span class="number">1</span>],nums[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>(dp &gt; res) res = dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="谈谈无后效性"><a href="#谈谈无后效性" class="headerlink" title="谈谈无后效性"></a>谈谈无后效性</h3><blockquote>
<p>李煜东著《算法竞赛进阶指南》，摘录如下：：</p>
<blockquote>
<p>为了保证计算子问题能够按照顺序、不重复地进行，动态规划要求已经求解的子问题不受后续阶段的影响。这个条件也被叫做「无后效性」。换言之，动态规划对状态空间的遍历构成一张有向无环图，遍历就是该有向无环图的一个拓扑序。有向无环图中的节点对应问题中的「状态」，图中的边则对应状态之间的「转移」，转移的选取就是动态规划中的「决策」。</p>
</blockquote>
<p>我的解释：</p>
<ul>
<li>「有向无环图」「拓扑序」表示了每一个子问题只求解一次，以后求解问题的过程不会修改以前求解的子问题的结果；</li>
<li>换句话说：如果之前的阶段求解的子问题的结果包含了一些不确定的信息，导致了后面的阶段求解的子问题无法得到，或者很难得到，这叫「有后效性」，我们在当前这个问题第 1 次拆分的子问题就是「有后效性」的（大家可以再翻到上面再看看）；</li>
<li>解决「有后效性」的办法是固定住需要分类讨论的地方，记录下更多的结果。在代码层面上表现为：<ul>
<li>状态数组增加维度，例如：「力扣」的股票系列问题；</li>
<li>把状态定义得更细致、准确，例如：前天推送的第 124 题：状态定义只解决路径来自左右子树的其中一个子树。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240305110454735.png" alt="image-20240305110454735" style="zoom:67%;" align="left">

<p>方法一：动态规划</p>
<p>数组的动态规划问题、子序列、连续子序列的一个常见的状态定义是：</p>
<blockquote>
<p>以下标 i 结尾的连续子序列的乘积的最大值。</p>
</blockquote>
<p>最后把整个 dp 数组看一遍求最大值即可。因此状态转移方程可能是：</p>
<blockquote>
<p>dp[i] = max(dp[i - 1] * nums[i], nums[i])</p>
</blockquote>
<p>说明：牢记状态的定义，一定以下标 i 结尾，即：乘积数组中 nums[i] 必须被选取。</p>
<ul>
<li>如果 dp[i - 1] 是负数，乘上 nums[i] 还是负数，倒不如另起炉灶直接选 nums[i]。</li>
<li>如果 nums[i] 是负数该怎么办呢？dp[i - 1] 是正数的时候，越乘越小，dp[i - 1] 是负数的时候，越乘越大，于是我们可能就需要记录一下负数的那个最小数。</li>
</ul>
<p>遇到这样的问题，其实就在提示我们状态不够用了。因此，需要在原来的一维 dp 后面新增一个状态。</p>
<p>针对这道题，第 2 维状态只需要两个：</p>
<ul>
<li>用 0 表示遍历的过程中得到的以 nums[i] 结尾的连续子序列的乘积的最小值；</li>
<li>用 1 表示遍历的过程中得到的以 nums[i] 结尾的连续子序列的乘积的最大值。</li>
</ul>
<p>当 nums[i] = 0 的时候包含在上面二者之中，无需单独讨论。</p>
<p>这里就声明一下状态：</p>
<p>dp[i] [1] 表示：以 nums[i] 结尾的连续子序列的乘积的最大值；<br>dp[i] [0] 表示：以 nums[i] 结尾的连续子序列的乘积的最小值。</p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = nums[<span class="number">0</span>];<span class="comment">// 最小值</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];<span class="comment">// 最大值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.min(nums[i], dp[i - <span class="number">1</span>][<span class="number">0</span>] * nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(nums[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] * nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.min(nums[i], dp[i - <span class="number">1</span>][<span class="number">1</span>] * nums[i]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max(nums[i], dp[i - <span class="number">1</span>][<span class="number">0</span>] * nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = Math.max(res, dp[i][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dpMin</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">dpMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            dpMin = Math.min(nums[i], dpMin * nums[i]);</span><br><span class="line">            dpMax = Math.max(nums[i], dpMax * nums[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dpMin;<span class="comment">// 注意：dpMax计算时需要用到之前的dpMin，故需要先保存旧值</span></span><br><span class="line">            dpMin = Math.min(nums[i], dpMax * nums[i]);</span><br><span class="line">            dpMax = Math.max(nums[i], temp * nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = Math.max(res, dpMax);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方法二：求连续子数组的乘积最大值，可以看成是求被0拆分的各个子数组的最大值</p>
<p>当一个数组中没有0存在，则分为两种情况：</p>
<ul>
<li>负数为偶数个，则整个数组的各个值相乘为最大值</li>
<li>负数为奇数个，则从左边开始，乘到最后一个负数停止有一个”最大值”，从右边也有一个”最大值”，从所有的最大值中得出最大的最大值</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curMax</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从左边开始乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        product = product * num;</span><br><span class="line">        <span class="keyword">if</span>(curMax &lt; product) curMax = product;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) product = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再从右边往左计算一次</span></span><br><span class="line">    product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        product = product * nums[i];</span><br><span class="line">        <span class="keyword">if</span>(curMax &lt; product) curMax = product;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) product = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> curMax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="环形子数组的最大和"><a href="#环形子数组的最大和" class="headerlink" title="环形子数组的最大和"></a>环形子数组的最大和</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230721105209803.png" alt="image-20230721105209803" style="zoom: 80%;" align="left">



<p><strong>思路</strong></p>
<p>基于最大子数组和的动态规划解法，本题增加了数组首尾连接的情况，那么最大子数组可能出现在两种位置：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230721105410853.png" alt="image-20230721105410853" style="zoom:80%;" align="left">

<p>情况一：最大子数组不跨越首尾，则等价于求最大子数组和<code>maxSum</code></p>
<p>情况二：最大子数组跨越首尾，如上图 case2，其等价于 求出最小子数组和<code>minSum</code>，然后使用<code>数组元素和 total - 最小子数组和 minSum</code></p>
<p>结果：<code>res = Math.max(maxSum, total - minSum)</code></p>
<p>特殊情况：当数组元素全为负数时，maxSum取到数组最大的一个负数，而minSum取到数组所有元素，此时 total - minSum = 0，由于结果必须包含数组元素，但较大的 total - minSum不包含数组元素，所以此时应该直接去maxSum</p>
<p>即 <code>res = maxSum &gt; 0 ? Math.max(maxSum, total - minSum) : maxSum</code></p>
<p>注：maxSum &lt; 0 时，数组即全为负数</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dpMax</span> <span class="operator">=</span> <span class="number">0</span>, dpMin = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> nums[<span class="number">0</span>], minSum = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        total += nums[i];</span><br><span class="line"></span><br><span class="line">        dpMax = Math.max(dpMax + nums[i], nums[i]);</span><br><span class="line">        dpMin = Math.min(dpMin + nums[i], nums[i]);</span><br><span class="line"></span><br><span class="line">        maxSum = Math.max(maxSum, dpMax);</span><br><span class="line">        minSum = Math.min(minSum, dpMin);</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxSum &gt; <span class="number">0</span> ? Math.max(maxSum, total - minSum) : maxSum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="7-方法论-—-双序列DP"><a href="#7-方法论-—-双序列DP" class="headerlink" title="==7==.方法论 — 双序列DP"></a>==7==.方法论 — <strong>双序列DP</strong></h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814105202681.png" alt="image-20230814105202681"></p>
<h3 id="最长重复子数组"><a href="#最长重复子数组" class="headerlink" title="最长重复子数组"></a>最长重复子数组</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814110515262.png" alt="image-20230814110515262" style="zoom:80%;" align="left">



<p>思路</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i] [j]表示**以下标i-1结尾的nums1**和**以下标j-1结尾的nums2**，**最长重复子数组长度为dp[i] [j]**
</code></pre>
</li>
<li>确定递推公式<br>根据dp[i] [j]的定义，dp[i] [j]的状态只能由dp[i - 1] [j - 1]推导出来。<br>==即当A[i - 1] 和B[j - 1]相等的时候，dp[i] [j] = dp[i - 1] [j - 1] + 1==</li>
<li>dp数组如何初始化<br>所以dp[i] [0] 和dp[0] [j]初始化为0</li>
<li>确定遍历顺序<br>nums1和nums2都从前往后遍历</li>
<li>举例推导dp数组<br>nums1: [1,2,3,2,1]，nums2: [3,2,1,4,7]为例<pre><code>0 0 1 0 0
0 1 0 0 0
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
</code></pre>
</li>
</ol>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLength</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length+<span class="number">1</span>][nums2.length+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=nums1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=nums2.length; j++)&#123;<span class="comment">//此处循环的终止条件不能为j&lt;=i,因为后面还有可能存在等于nums1[i]的值</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//记录最大的连续重复子序列</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &gt; res)  res = dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由递推公式可知，dp[i][j]的状态只与dp[i-1][j-1]有关，则可将二维数组压缩为一维滚动数组，但需要注意j遍历时需要逆序遍历</span></span><br><span class="line"><span class="comment">//一维数组版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLength1</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums2.length+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums1.length; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=nums2.length; j&gt;<span class="number">0</span>; j--)&#123;<span class="comment">//遍历nums2数组的时候，就要从后向前遍历，这样避免重复覆盖。</span></span><br><span class="line">            <span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) dp[j] = dp[j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dp[j] &gt; res) res = dp[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814111015630.png" alt="image-20230814111015630" style="zoom:80%;">



<p>思路</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i] [j]表示**以下标i-1结尾的A**和**以下标j-1结尾的B**之间的**最长公共子序列的最大长度**
</code></pre>
</li>
<li>确定递推公式<br>主要就是两大情况： text1[i - 1] 与 text2[j - 1]相同，text1[i - 1] 与 text2[j - 1]不相同<br>如果text1[i - 1] 与 text2[j - 1]相同，那么找到了一个公共元素，所以==dp[i] [j] = dp[i - 1] [j - 1] + 1==;<br>如果text1[i - 1] 与 text2[j - 1]不相同，那就看看text1[0, i - 2]与text2[0, j - 1]的最长公共子序列 和 text1[0, i - 1]与text2[0, j - 2]的最长公共子序列，取最大的。<br>即：==dp[i] [j] = max(dp[i - 1] [j], dp[i] [j - 1])==;</li>
<li>dp数组初始化<br>由递推公式可知dp[0] [j]和dp[i] [0]都初始化为0</li>
<li>确定递推顺序<br>从前往后</li>
<li>举例推导dp数组<br>输入 String text1 = “ezupkr”, text2 = “ubmrapg”;<br>0 0 0 0 0 0 0<br>0 0 0 0 0 0 0<br>1 1 1 1 1 1 1<br>1 1 1 1 1 2 2<br>1 1 1 1 1 2 2<br>1 1 1 2 2 2 2</li>
</ol>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> text1.length(), n2 = text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n1 + <span class="number">1</span>][n2 + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(text1.charAt(i - <span class="number">1</span>) == text2.charAt(j - <span class="number">1</span>)) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="不相交的线"><a href="#不相交的线" class="headerlink" title="不相交的线"></a>不相交的线</h3><ul>
<li><p>题目</p>
<blockquote>
<p>我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。</p>
<p>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。</p>
<p>以这种方法绘制线条，并返回我们可以绘制的最大连线数。</p>
<p>题目本质就是求A和B的最长公共子序列</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxUncrossedLines</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//初始化：dp[i][0] 和 dp[0][j]都是0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums1[i-<span class="number">1</span>] == nums2[j-<span class="number">1</span>]) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="判断子序列"><a href="#判断子序列" class="headerlink" title="判断子序列"></a>判断子序列</h3><ul>
<li><p>题目</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240305115422464.png" alt="image-20240305115422464" style="zoom: 80%;" align="left"></li>
<li><p>思路分析</p>
<blockquote>
<p>题目类似于求两个数组的最长公共子序列，只需要子序列的长度等于s的长度即可</p>
</blockquote>
</li>
<li><p>动态规划五部曲</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i] [j]表示以下标i-1结尾的字符串t和以下标j-1结尾的字符串s之间的相同子序列的长度
</code></pre>
</li>
<li>确定递推公式<br>s.charAt(j-1) == t.charAt(i-1)时说明当前字符相同，则前面的基础上+1 即dp[i] [j] = dp[i-1] [j-1]+1<br>s.charAt(j-1) != t.charAt(i-1)时，s说明t的当前字符不符合条件，所有取前一次的比较结果，即dp[i] [j] = dp[i-1] [j];</li>
<li>dp数组初始化<br>dp[i] [0]和dp[0] [j]都初始化为0</li>
<li>确定遍历顺序<br>先遍历字符串t，则遍历字符串s</li>
<li>举例推导dp数组String s = “abc”, t = “ahbgdc”;<pre><code>0 0 0
1 0 0 
1 2 0 
1 2 0 
1 2 0 
1 2 3 
</code></pre>
</li>
</ol>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DP解法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSubsequence</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> s.length();</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=t.length(); i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=s.length();j++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(s.charAt(j-<span class="number">1</span>) == t.charAt(i-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">           <span class="comment">//t当前的字符不能与s的字符匹配，取前一次的比较结果</span></span><br><span class="line">           <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> dp[len1][len2] == len2?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双指针解法:遍历比较s和t的元素，能把s遍历完则为true</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubsequence1</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &gt; t.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index_s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;t.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t.charAt(i) == s.charAt(index_s)) index_s++;</span><br><span class="line">            <span class="keyword">if</span>(index_s == s.length()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="不同的子序列-动态规划的两种穷举视角"><a href="#不同的子序列-动态规划的两种穷举视角" class="headerlink" title="不同的子序列_==动态规划的两种穷举视角=="></a>不同的子序列_==动态规划的两种穷举视角==</h3><p><strong>前置知识：排列组合</strong></p>
<p>排列：<code>P(n, k)</code></p>
<p>组合：<code>C(n, k)</code></p>
<p>区别：排列考虑元素顺序，组合不考虑元素顺序</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230604110732009.png" alt="image-20230604110732009" style="zoom:50%;" align="left">



<p><strong>球盒模型</strong></p>
<p>即，将 <code>n</code> 个标记了不同序号的球（标号为了体现顺序的差异），放入 <code>k</code> 个标记了不同序号的盒子中（其中 <code>n &gt;= k</code>，每个盒子最终都装有恰好一个球），共有 <code>P(n, k)</code> 种不同的方法。</p>
<p>现在你来，往盒子里放球，你怎么放？其实有两种视角。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230604110933515.png" alt="image-20230604110933515" style="zoom: 50%;" align="left">



<p><strong>盒子视角</strong></p>
<p>每个盒子必然要选择一个球。</p>
<p>这样，第一个盒子可以选择 <code>n</code> 个球中的任意一个，然后你需要让剩下 <code>k - 1</code> 个盒子在 <code>n - 1</code> 个球中选择：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230604111104982.png" alt="image-20230604111104982" style="zoom:50%;" align="left">



<p><strong>球的视角</strong></p>
<p>因为并不是每个球都会被装进盒子，所以球的视角分两种情况：</p>
<p>1、第一个球可以不装进任何一个盒子，这样的话你就需要将剩下 <code>n - 1</code> 个球放入 <code>k</code> 个盒子。</p>
<p>2、第一个球可以装进 <code>k</code> 个盒子中的任意一个，这样的话你就需要将剩下 <code>n - 1</code> 个球放入 <code>k - 1</code> 个盒子。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230604111230295.png" alt="image-20230604111230295" style="zoom:50%;" align="left">



<p><strong>题目分析</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230604144323697.png" alt="image-20230604144323697" style="zoom:80%;" align="left">



<p>函数签名</p>
<blockquote>
<p>int numDistinct(String s, String t);</p>
</blockquote>
<p>要求出s的子序列中有多少个t，其本质上还是靠穷举。</p>
<p>那么首先想到的是能不能将原问题分解为规模更小的子问题，然后通过子问题的答案推导出原问题的答案。</p>
<p>定义递归函数：题目要求求出出现次数，则定义函数返回值为出现次数即可。</p>
<blockquote>
<p>// <em>定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</em><br>int dp(String s, int i, String t, int j)</p>
</blockquote>
<p>base case</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="comment">// base case 1</span></span><br><span class="line">    <span class="keyword">if</span> (j == t.length()) &#123;</span><br><span class="line">        <span class="comment">// t 已经全部匹配完成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// base case 2</span></span><br><span class="line">    <span class="keyword">if</span> (s.length() - i &lt; t.length() - j) &#123;</span><br><span class="line">        <span class="comment">// s[i..] 比 t[j..] 还短，必然没有匹配的子序列</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>回顾一下之前讲的排列组合的「球盒模型」，这里是不是很类似？<code>t</code> 中的若干字符就好像若干盒子，<code>s</code> 中的若干字符就好像若干小球，你需要做的就是给所有盒子都装一个小球。所以这里就有两种穷举思路了，分别是站在 <code>t</code> 的视角（盒子选择小球）和站在 <code>s</code> 的视角（小球选择盒子）</strong>。</p>
<p><strong>视角一，站在 <code>t</code> 的角度进行穷举</strong>：</p>
<p>我们的原问题是求 <code>s[0..]</code> 的所有子序列中 <code>t[0..]</code> 出现的次数，那么可以先看 <code>t[0]</code> 在 <code>s</code> 中的什么位置，假设 <code>s[2], s[6]</code> 是字符 <code>t[0]</code>，那么原问题转化成了在 <code>s[2..]</code> 和 <code>s[6..]</code> 的所有子序列中计算 <code>t[1..]</code> 出现的次数。</p>
<p>翻译成代码大致就是这个思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 在 s[i..] 中寻找 k，使得 s[k] == t[j]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; s.length(); k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(k) == t.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// 累加结果</span></span><br><span class="line">            res += dp(s, k + <span class="number">1</span>, t, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加备忘录消除重叠子问题</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录为特殊值 -1</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][t.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(s, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// base case 1</span></span><br><span class="line">        <span class="keyword">if</span> (j == t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base case 2</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() - i &lt; t.length() - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查备忘录防止冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行状态转移方程</span></span><br><span class="line">        <span class="comment">// 在 s[i..] 中寻找 k，使得 s[k] == t[j]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i; k &lt; s.length(); k++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(k) == t.charAt(j)) &#123;</span><br><span class="line">                <span class="comment">// 累加结果</span></span><br><span class="line">                res += dp(s, k + <span class="number">1</span>, t, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 存入备忘录</span></span><br><span class="line">        memo[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>视角二，站在 <code>s</code> 的角度进行穷举</strong>：</p>
<p>我们的原问题是计算 <code>s[0..]</code> 的所有子序列中 <code>t[0..]</code> 出现的次数，可以先看看 <code>s[0]</code> 是否能匹配 <code>t[0]</code>，如果不匹配，那没得说，原问题就可以转化为计算 <code>s[1..]</code> 的所有子序列中 <code>t[0..]</code> 出现的次数；</p>
<p>但如果 <code>s[0]</code> 可以匹配 <code>t[0]</code>，那么又有两种情况，这两种情况是累加的关系：</p>
<p>1、让 <code>s[0]</code> 匹配 <code>t[0]</code>，那么原问题转化为在 <code>s[1..]</code> 的所有子序列中计算 <code>t[1..]</code> 出现的次数。</p>
<p>2、不让 <code>s[0]</code> 匹配 <code>t[0]</code>，那么原问题转化为在 <code>s[1..]</code> 的所有子序列中计算 <code>t[0..]</code> 出现的次数。</p>
<p>为啥明明 <code>s[0]</code> 可以匹配 <code>t[0]</code>，还不让它俩匹配呢？主要是为了给 <code>s[0]</code> 之后的元素匹配的机会，比如 <code>s = &quot;aab&quot;, t = &quot;ab&quot;</code>，就有两种匹配方式：<code>a_b</code> 和 <code>_ab</code>。</p>
<p>把以上思路写成状态转移方程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">        <span class="comment">// 匹配，两种情况，累加关系</span></span><br><span class="line">        <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, t, j + <span class="number">1</span>) + dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数</span></span><br><span class="line">        <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加入备忘录消除重叠子问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化备忘录为特殊值 -1</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][t.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] row : memo) &#123;</span><br><span class="line">            Arrays.fill(row, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp(s, <span class="number">0</span>, t, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：s[i..] 的子序列中 t[j..] 出现的次数为 dp(s, i, t, j)</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String t, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="comment">// base case 1</span></span><br><span class="line">        <span class="keyword">if</span> (j == t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// base case 2</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() - i &lt; t.length() - j) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查备忘录防止冗余计算</span></span><br><span class="line">        <span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 执行状态转移方程</span></span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == t.charAt(j)) &#123;</span><br><span class="line">            <span class="comment">// 匹配，两种情况，累加关系</span></span><br><span class="line">            res += dp(s, i + <span class="number">1</span>, t, j + <span class="number">1</span>) + dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配，在 s[i+1..] 的子序列中计算 t[j..] 的出现次数</span></span><br><span class="line">            res += dp(s, i + <span class="number">1</span>, t, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结果存入备忘录</span></span><br><span class="line">        memo[i][j] = res;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>动态规划五部曲</strong></p>
<blockquote>
<ol>
<li><p>dp数组以及下标的含义</p>
<p>dp[i] [j]：以i-1为结尾的s子序列中出现以j-1为结尾的t的个数为dp[i] [j]。</p>
</li>
<li><p>确定递推公式</p>
<p>这一类问题，基本是要分析两种情况</p>
<ul>
<li>s[i - 1] 与 t[j - 1]相等</li>
<li>s[i - 1] 与 t[j - 1] 不相等</li>
</ul>
<p>当s[i - 1] 与 t[j - 1]相等时，dp[i] [j]可以有两部分组成。</p>
<p>一部分是用s[i - 1]来匹配，那么个数为dp[i - 1] [j - 1]。</p>
<p>一部分是不用s[i - 1]来匹配，个数为dp[i - 1] [j]。</p>
<p>这里可能有同学不明白了，为什么还要考虑 不用s[i - 1]来匹配，都相同了指定要匹配啊。</p>
<p>例如： s：bagg 和 t：bag ，s[3] 和 t[2]是相同的，但是字符串s也可以不用s[3]来匹配，即用s[0]s[1]s[2]组成的bag。</p>
<p>当然也可以用s[3]来匹配，即：s[0]s[1]s[3]组成的bag。</p>
<p>所以当s[i - 1] 与 t[j - 1]相等时，dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j];</p>
<p>当s[i - 1] 与 t[j - 1]不相等时，dp[i] [j]只有一部分组成，不用s[i - 1]来匹配，即：dp[i - 1] [j]</p>
<p>所以递推公式为：dp[i] [j] = dp[i - 1] [j];</p>
</li>
<li><p>dp数组初始化</p>
<p>当 t 为空串时，此时 s 为了匹配它，方式只有1种：什么字符也不用挑,即dp[i] [0] = 1;<br>当 s 空串时，但 t 不是，s 怎么也匹配不了 t，方式数为 0 即dp[0] [j] = 0<br>dp[0] [0]遵循第一种情况</p>
</li>
<li><p>确定遍历顺序</p>
<p>从递推公式dp[i] [j] = dp[i - 1] [j - 1] + dp[i - 1] [j]; 和 dp[i] [j] = dp[i - 1] [j]; 中可以看出dp[i][j]都是根据左上方和正上方推出来的。</p>
<p>所以遍历的时候一定是从上到下，从左到右，这样保证dp[i][j]可以根据之前计算出来的数值进行计算。</p>
</li>
<li><p>dp数组初始化</p>
</li>
</ol>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">tLen</span> <span class="operator">=</span> t.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sLen+<span class="number">1</span>][tLen+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//t为空串时，匹配方法只有一种：什么都不选</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;t.length(); j++) dp[<span class="number">0</span>][j] = <span class="number">0</span>;<span class="comment">//s为空串时，找不到字符与t进行匹配，所以方式为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=sLen; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=tLen; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == t.charAt(j)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[sLen][tLen];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="38-两个字符的删除操作"><a href="#38-两个字符的删除操作" class="headerlink" title="38.两个字符的删除操作"></a>38.两个字符的删除操作</h3><ul>
<li><p>题目</p>
<blockquote>
<p>给定两个单词 word1 和 word2，找到使得 word1 和 word2 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<p>示例：</p>
<p>输入: “sea”, “eat”<br>输出: 2 解释: 第一步将”sea”变为”ea”，第二步将”eat”变为”ea”</p>
</blockquote>
</li>
<li><p>思路</p>
<blockquote>
<p>找到二者的最长公共子序列，使用len1+len2-2*dp[len1] [len2]即可</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> text1.length(),len2 = text2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=len1; i++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">str</span> <span class="operator">=</span> text1.charAt(i-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=len2; j++)&#123;</span><br><span class="line">            <span class="comment">//当前遍历的两个字符相同</span></span><br><span class="line">            <span class="keyword">if</span>(str == text2.charAt(j-<span class="number">1</span>)) dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//当前遍历的两个字符不相同</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1+len2-<span class="number">2</span>*dp[len1][len2];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="39-编辑距离"><a href="#39-编辑距离" class="headerlink" title="39.编辑距离"></a>39.编辑距离</h3><ul>
<li><p>题目</p>
<blockquote>
<p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p>
<p>你可以对一个单词进行如下三种操作：</p>
<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
<p>示例 1： 输入：word1 = “horse”, word2 = “ros” 输出：3 解释： horse -&gt; rorse (将 ‘h’ 替换为 ‘r’) rorse -&gt; rose (删除 ‘r’) rose -&gt; ros (删除 ‘e’)</p>
<p>示例 2： 输入：word1 = “intention”, word2 = “execution” 输出：5 解释： intention -&gt; inention (删除 ‘t’) inention -&gt; enention (将 ‘i’ 替换为 ‘e’) enention -&gt; exention (将 ‘n’ 替换为 ‘x’) exention -&gt; exection (将 ‘n’ 替换为 ‘c’) exection -&gt; execution (插入 ‘u’)</p>
<p>提示：</p>
<ul>
<li>0 &lt;= word1.length, word2.length &lt;= 500</li>
<li>word1 和 word2 由小写英文字母组成</li>
</ul>
</blockquote>
</li>
<li><p>动态规划五部曲</p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>dp[i] [j]表示以**下标i-1为结尾的字符串word1** 和 **以下标j-1为结尾的字符串word2**，最近==编辑距离为dp[i] [j]==
    通俗讲就是：word1的前i个字符变成word2的前j个字符需要进行的操作步骤数
</code></pre>
</li>
<li><p>确定递推公式</p>
<ul>
<li>情况1：<strong>word1[i - 1] == word2[j - 1]</strong>  即当前两个字符相同，则说明不用任何编辑，<pre><code>dp[i] [j] 就应该是 dp[i - 1] [j - 1]，即dp[i] [j] = dp[i - 1] [j - 1];
</code></pre>
</li>
<li>情况2: **word1[i - 1] != word2[j - 1]**，此时就需要进行编辑操作<br>考虑操作时只考虑增加操作和替换操作，因为word1的删除操作等价于word2的增加操作，word2的删除操作也等价于word1的增加操作<ul>
<li>操作1：dp[i] [j-1]为 word1 的前 i 个字符和 word2 的前 j - 1 个字符的编辑距离。即word1的前i个字符变成word2的前j-1个字符需要的操作步骤数<pre><code>那么对于 word2 的第 j 个字符，我们在 word1 的末尾添加了一个相同的字符，那么 dp[i] [j] 最小可以为 dp[i] [j-1] + 1；
</code></pre>
</li>
<li>操作2：dp[i-1] [j]为 word1 的前 i-1 个字符和 word2 的前 j 个字符的编辑距离。<pre><code>那么对于 word1 的第 i 个字符，我们在 word2 的末尾添加了一个相同的字符，那么 dp[i] [j] 最小可以为 dp[i-1] [j] + 1；
</code></pre>
</li>
<li>操作3：dp[i-1] [j-1]为 word1 的前 i-1 个字符和 word2 的前 j-1 个字符的编辑距离。<pre><code>那么对于 word1 的第 i 个字符，我们把 word2 的末尾替换成相同的字符，那么 dp[i] [j] 最小可以为 dp[i-1] [j-1] + 1；
</code></pre>
此时对于最少的编辑距离，我们取上述三种操作的最小值即可<pre><code>dp[i] [j] = Math.min(Math.min(dp[i-1] [j],dp[i] [j-1]),dp[i-1] [j-1]) + 1;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>dp数组初始化<br>对于word1字符串为空时，word2只需要删除所有元素即可(即j多大就删除几次即可)，则对于i=0，dp[0] [j] = j;<br>word2为空同理，对于j=0，dp[i] [0] = i;</p>
</li>
<li><p>确定遍历顺序</p>
<p>由递推公式可知，dp[i] [j]的值与其上方，左方以及左上角有关，则遍历顺序为从左到右，从上到下。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1+<span class="number">1</span>][len2+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp数组初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=len1; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=len1; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=len2; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (word1.charAt(i) != word2.charAt(j)) </span><br><span class="line">                dp[i][j] = Math.min(Math.min(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]),dp[i-<span class="number">1</span>][j-<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="8-方法论-—-区间DP"><a href="#8-方法论-—-区间DP" class="headerlink" title="==8==.方法论 — 区间DP"></a>==8==.方法论 — <strong>区间DP</strong></h3><h3 id="回文子串-可以使用中心扩展法"><a href="#回文子串-可以使用中心扩展法" class="headerlink" title="回文子串_可以使用中心扩展法"></a>回文子串_可以使用中心扩展法</h3><p><strong>题目</strong></p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240306103657702.png" alt="image-20240306103657702" style="zoom:67%;" align="left">

<p><strong>动态规划思路</strong></p>
<blockquote>
<ol>
<li><p>确定dp数组以及下标的含义</p>
<pre><code>boolean类型的dp[i] [j]:表示区间范围[i,j] (注意是左闭右闭)的子串是否是回文子串，是则为true，不是则为false
</code></pre>
</li>
<li><p>确定递推公式<br>递推公式主要分为两种情况：s[i]与s[j]相等，s[i]与s[j]不相等<br>1.s[i]与s[j]不相等，dp[i] [j] = false<br>2.s[i]与s[j]相等时，包含以下三种情况</p>
<pre><code>1.下标 i 与 j 相同，同一个字符例如 a，肯定为回文串
2.下标 i 与 j 相差1或2，例如 aa, aba，也为回文串
3.i 与 j 相差大于2，例如==c==aba==c==，此时s[i]与s[j]已经相同，此时判断[i,j]区间是不是回文串只需要看aba是不是回文即可，那么aba区间就是[i+1,j-1]，即判断该区间是不是回文看dp[i+1] [j-1]是不是为true即可 
</code></pre>
<p>[i,j]字符串为：s[i] s[i+1] s[i+2] … s[j-2] s[j-1] s[j]</p>
</li>
<li><p>dp数组初始化<br>dp[i] [j]初始化都为false</p>
</li>
<li><p>确定遍历顺序<br>由递推公式相等情况的条件三可知，dp[i] [j]值被dp[i+1] [j-1]影响，而[i+1] [j-1]在dp[i] [j]的左下角</p>
<pre><code>i值/j值 0 1 2 ... j-1             j
0
1
...
i                                dp[i] [j]
i+1             dp[i+1] [j-1]
</code></pre>
<p>为了保证dp[i+1] [j-1]在dp[i] [j]之前计算，则遍历顺序应该为从下到上，从左到右或者说外层遍历上界，内层遍历下界</p>
</li>
<li><p>举例推导dp数组<br>输入 s = “abababc”</p>
<pre><code>a b a b a c
</code></pre>
<p>  a 1 0 1 0 1 0<br>  b    1 0 1 0 0<br>  a       1 0 1 0<br>  b          1 0 0<br>  a             1 0<br>  c                1</p>
</li>
</ol>
</blockquote>
<p><strong>中心扩展法思路</strong></p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230331143840117.png" alt="image-20230331143840117"></p>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dp：外下界 ( i ) 内上界 ( j ) 遍历 --- 建议</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">boolean</span>[] d : dp) Arrays.fill(d, <span class="literal">true</span>);</span><br><span class="line">	<span class="comment">// dp[i][j] 受dp[i + 1][j - 1]影响，则i需要逆序遍历，才能先得到i+1处的状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dp[i][j] = ((s.charAt(i) == s.charAt(j)) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j])res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中心扩展法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 扩展中心可以为一个点或两个点，例如aba中心为a，abba中心为bb</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>; center &lt; <span class="number">2</span>*len - <span class="number">1</span>; center++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(left &gt;=<span class="number">0</span> &amp;&amp; right &lt; len &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                res++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="最长回文子串"><a href="#最长回文子串" class="headerlink" title="最长回文子串"></a>最长回文子串</h3><blockquote>
<p>给你一个字符串 s，找到 s 中最长的回文子串。</p>
<p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p>
<p>示例 1：</p>
<p>输入：s = “babad”<br>输出：”bab”<br>解释：”aba” 同样是符合题意的答案。<br>示例 2：</p>
<p>输入：s = “cbbd”<br>输出：”bb”</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br>s 仅由数字和英文字母组成</p>
</blockquote>
<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中心扩展法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">1</span>) <span class="keyword">return</span> s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 扩展中心可以为一个点或两个点，例如aba中心为a，abba中心为bb</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>; center &lt; <span class="number">2</span>*len - <span class="number">1</span>; center++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; n &amp;&amp; c[left] == c[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>((right - left) &gt; (end - begin))&#123;</span><br><span class="line">                begin = left;</span><br><span class="line">                end = right;</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通俗版中心扩展法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> palindrome(s, i, i);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> palindrome(s, i, i + <span class="number">1</span>);</span><br><span class="line">            res = res.length() &gt; s1.length() ? res : s1;</span><br><span class="line">            res = res.length() &gt; s2.length() ? res : s2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">palindrome</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(left + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="最长回文子序列-—-类似最长公共子序列"><a href="#最长回文子序列-—-类似最长公共子序列" class="headerlink" title="最长回文子序列 — 类似最长公共子序列"></a>最长回文子序列 — 类似最长公共子序列</h3><ul>
<li><p>题目</p>
<blockquote>
<p>给定一个字符串 s ，找到其中最长的回文子序列，并返回该序列的长度。可以假设 s 的最大长度为 1000 。</p>
<p>示例 1: 输入: “bbbab” 输出: 4 一个可能的最长回文子序列为 “bbbb”。</p>
<p>示例 2: 输入:”cbbd” 输出: 2 一个可能的最长回文子序列为 “bb”。</p>
<p>提示：</p>
<p>1 &lt;= s.length &lt;= 1000<br>s 只包含小写英文字母</p>
</blockquote>
</li>
<li><p>==特殊解法== </p>
<blockquote>
<p>将字符串进行翻转，然后求出两个字符串的最长公共子序列，即为最长回文子序列</p>
</blockquote>
</li>
<li><p>思考</p>
<blockquote>
<p>遍历字符串的方式与上一题类似，也是使用[i,j]区间的方式查找回文串，只是本题是找到最大长度，所以</p>
<p>​    s[i]与s[j]相同时，直接在dp[i+1] [j-1]的基础上+2即可</p>
<p>​    s[i]与s[j]不同时，则需要对两种情况做取舍，即在[i+1,j-1]的基础上加上s[i] (头部加)或者s[j] (尾部加)，取二者较大值即可</p>
</blockquote>
</li>
<li><p>动态规划五部曲</p>
<blockquote>
<ol>
<li>确定dp数组以及下标的含义<pre><code>dp[i] [j]:表示字符串s在[i,j]范围内最长的回文子序列的长度为dp[i] [j]
</code></pre>
</li>
<li>确定递推公式<ul>
<li>s[i]与s[j]相同时，dp[i] [j] = dp[i+1] [j-1] + 2</li>
<li>s[i]与s[j]不相同，说明s[i]和s[j]的同时加入 并不能增加[i,j]区间回文子串的长度，那么分别加入s[i]、s[j]看看哪一个可以组成最长的回文子序列。<br>1.加入s[j]的回文子序列长度为dp[i + 1] [j]。<br>2.加入s[i]的回文子序列长度为dp[i] [j - 1]。<br>即dp[i] [j] = max(dp[i+1] [j],dp[i] [j-1])</li>
</ul>
</li>
<li>dp数组初始化<br>当i与j相同，那么dp[i] [j]一定是等于1的，即：一个字符的回文子序列长度就是1。<br>其他情况dp[i] [j]初始为0就行，这样递推公式：dp[i] [j] = max(dp[i + 1] [j], dp[i] [j - 1]); 中dp[i] [j]才不会被初始值覆盖。</li>
<li>确定遍历顺序<br>从递推公式<pre><code>dp[i] [j] = dp[i + 1] [j - 1] + 2 和
dp[i] [j] = max(dp[i + 1] [j], dp[i] [j - 1])
</code></pre>
可以看出，dp[i] [j]是依赖于dp[i + 1] [j - 1]，dp[i] [j - 1] 和 dp[i + 1] [j]<br>则遍历顺序应该为先从下往上，再从左往右</li>
</ol>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len+<span class="number">1</span>][len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;<span class="comment">// 从下往上遍历</span></span><br><span class="line">        dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;<span class="comment">//从左往右遍历</span></span><br><span class="line">            <span class="comment">//s[i]与s[j]相等时，在[i+1,j-1]的基础上+2</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(j)) dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//s[i]与s[j]不相等时，取[i,j-1]和[i+1,j]的较大值</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// dp：了解思路即可</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">boolean</span>[] a : dp)&#123;</span><br><span class="line">        Arrays.fill(a, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dp[i][j] = (s.charAt(i) == s.charAt(j)) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; (j - i &gt; end - begin))&#123;</span><br><span class="line">                begin = i;</span><br><span class="line">                end = j;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(begin, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="44-不同的子序列II"><a href="#44-不同的子序列II" class="headerlink" title="44.不同的子序列II"></a>44.不同的子序列II</h2><ul>
<li><p>题目</p>
<blockquote>
<p>给定一个字符串 s，计算 s 的 不同非空子序列 的个数。因为结果可能很大，所以返回答案需要对 10^9 + 7 取余 。</p>
<p>字符串的 子序列 是经由原字符串删除一些（也可能不删除）字符但不改变剩余字符相对位置的一个新字符串。</p>
<p>例如，”ace” 是 “abcde” 的一个子序列，但 “aec” 不是。<strong>即不能对其排序</strong></p>
<p>示例 1：</p>
<p>输入：s = “abc”<br>输出：7<br>解释：7 个不同的子序列分别是 “a”, “b”, “c”, “ab”, “ac”, “bc”, 以及 “abc”。<br>示例 2：</p>
<p>输入：s = “aba”<br>输出：6<br>解释：6 个不同的子序列分别是 “a”, “b”, “ab”, “ba”, “aa” 以及 “aba”。<br>示例 3：</p>
<p>输入：s = “aaa”<br>输出：3<br>解释：3 个不同的子序列分别是 “a”, “aa” 以及 “aaa”。</p>
</blockquote>
</li>
<li><p>思路</p>
<blockquote>
<p>引子</p>
<ol>
<li>对于子序列问题，通常可以从每个元素[选/不选]的角度入手</li>
<li>麻烦的地方在于，如何保证对同样的子序列，我们只统计一次(即回溯中的树层去重)？<pre><code>例如&quot;aba&quot;，前两个字符可以得到&quot;a&quot;,&quot;b&quot;,&quot;ab&quot;,再遍历第三个字符时，会再得到一个&quot;a&quot;，与前面重复了
</code></pre>
</li>
</ol>
<p>所以我们可以把第三个”a”，加入到”a”,”b”,”ab”的末尾，从而得到”aa”,”ba”,”aba”,同时把”a”单独作为一个子序列，此时便不会重复<br>但是，我们最后的答案却忽略掉了”b”,”ab”,可以注意到这些字符都不是以”a”结尾的</p>
<pre><code>    此时，我们可以把问题细分为，==分别统计以&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,...,&quot;z&quot;结尾的子序列==，便可得到满足我们需求的解
    具体来说，在遍历 s 的过程中，将 s[i] 加到前 i-1 个字符(即前面所有)组成的不同子序列的末尾，同时将 s[i] 单独作为一个子序列，便得到
</code></pre>
<p>前 i 个字符以 s[i] 结尾的不同子序列的个数。最后将以”a”,”b”,”c”,…,”z”结尾的子序列的个数相加即可得到答案</p>
<pre><code>    以上说法换言之：对于相同的子序列，只考虑其最后一次出现的位置
</code></pre>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录以某个字符结尾的子序列的个数</span></span><br><span class="line">    <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">//得到以当前字符结尾的最近一次的子序列数量，如果是第一次遍历，则该值为0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> last[c];</span><br><span class="line">        <span class="comment">//更新以当前字符结尾的子序列数量，即前面所有子序列的个数+1</span></span><br><span class="line">        last[c] = (res + <span class="number">1</span>) % MOD;</span><br><span class="line">        <span class="comment">//更新所有的子序列和(但还未去重),即以当前字符结尾的子序列 + 前面已经得到所有的子序列</span></span><br><span class="line">        res = (res + last[c]) % MOD;</span><br><span class="line">        <span class="comment">//由于上一步得到res里面会重复添加有以当前字符结尾的子序列，则需要将这些去掉</span></span><br><span class="line">        res = (res - prev + MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="45-数位DP-详解"><a href="#45-数位DP-详解" class="headerlink" title="45.==数位DP==_详解"></a>45.==数位DP==_详解</h2><ul>
<li>引子</li>
</ul>
<blockquote>
<p>考虑一个需求：<code>遍历 &lt;=n 的所有数字，n=1234</code></p>
<ul>
<li><p>傻瓜式遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>按位遍历</p>
</li>
</ul>
<blockquote>
<p>按位遍历需要以每一位为单位，所有我们将n转化为字符数组<code>s=[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;,&#39;4&#39;]</code></p>
<p>现在考虑处于每一位上面临的选择：从左到右，即从高位开始（结合以下图片食用）</p>
<ul>
<li>当处于第 <code>0</code> 位时，可以选择 <code>0, 1</code></li>
<li>当处于第 <code>1</code>位时，可选数字有两种情况</li>
<li>当第 <code>0</code> 位选择的是<code>0</code>, 则第<code>1</code>位可以选择<code>0~9</code></li>
<li>当第 <code>0</code> 位选择的是<code>1</code>, 那么此时的选择就不能超过原数第<code>1</code>位的值, 则第<code>1</code>位可以选择<code>0~2</code></li>
<li>当处于第<code>2</code>位时，如果第 <code>0</code> 位选择的是<code>1</code>，第<code>1</code>位选择的是<code>2</code>,则第<code>2</code>位只能选择<code>0~3</code>;其他情况可以选择<code>0~9</code></li>
<li>… <img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/Users\10306\AppData\Roaming\Typora\typora-user-images\image-20221020145933416.png" alt="image-20221020145933416" style="zoom:50%;"></li>
</ul>
</blockquote>
</blockquote>
<ul>
<li><p>按位遍历的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getAllNum</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] s = Integer.toString(n).toCharArray();</span><br><span class="line">    <span class="comment">// 处于第 0 位的时候，选择是被限制的，只能选择不超过第 0 位的值</span></span><br><span class="line">    traversal(s, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// list 就是所有数的集合啦</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从第 i 位开始遍历</span></span><br><span class="line"><span class="comment">// path 记录路径</span></span><br><span class="line"><span class="comment">// isLimit 如图所示，为了防止大小超过 n</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">int</span> path, <span class="type">boolean</span> isLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">        list.add(path);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定选择的上界</span></span><br><span class="line">    <span class="comment">// 如果 isLimit 为 true，那么可选择的上界不能超过该位的值；否则可以一直选择到 9</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        <span class="comment">// 递归遍历下一位</span></span><br><span class="line">        <span class="comment">// 下一位的 isLimit 确定方法：当前位被限制了，而且选择的值是上界</span></span><br><span class="line">        <span class="comment">// 继续按照上图，举个例子：当处于第 0 位时，isLimit 为 true，</span></span><br><span class="line">        <span class="comment">// 如果此时选择上界 1，那么遍历第 1 位的时候也是被限制的；</span></span><br><span class="line">        <span class="comment">// 但是如果此时选择的不是上界 1，那么遍历第 1 位的时候就没有被限制</span></span><br><span class="line">        traversal(s, i + <span class="number">1</span>, path * <span class="number">10</span> + d, isLimit &amp;&amp; d == up);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="46-数位DP的应用-数字1的个数"><a href="#46-数位DP的应用-数字1的个数" class="headerlink" title="46.数位DP的应用-数字1的个数"></a>46.数位DP的应用-数字1的个数</h2><ul>
<li><p>题目</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240307120631288.png" alt="image-20240307120631288" style="zoom: 80%;" align="left"></li>
<li><p>按照按位遍历的思路，写一个遍历所有数字的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] s;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    s = Integer.toString(n).toCharArray();</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回从第 i 位开始的 &lt;= n 的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">boolean</span> isLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        res += f(i + <span class="number">1</span>, isLimit &amp;&amp; d == up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>根据题意将返回值修改为：返回从第<code>i</code>位开始，数字<code>1</code>的个数</p>
<p>增加一个oneCnt参数记录个数即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] s;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    s = Integer.toString(n).toCharArray();</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span> ,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回从第 i 位开始，数字中 1 的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> oneCnt, <span class="type">boolean</span> isLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 结束条件</span></span><br><span class="line">    <span class="comment">// 前文说过，结束时就表示一条完整的路径，即一个 &lt;= n 的数字，而 ontCnt 则表示该数字中 1 的个数</span></span><br><span class="line">    <span class="comment">// 所以直接返回 oneCnt 即可！！</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> oneCnt;</span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        <span class="comment">// 如果 d = 1，oneCnt 就➕1</span></span><br><span class="line">        res += f(i + <span class="number">1</span>, oneCnt + (d == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>), isLimit &amp;&amp; d == up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>上述代码已经满足基本需求，但是多了许多重复计算，因为许多状态是可以重复使用的，下面分析哪些状态可以复用</p>
</li>
<li><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/Users\10306\AppData\Roaming\Typora\typora-user-images\image-20221020152935567.png" alt="image-20221020152935567" style="zoom:50%;"></li>
</ul>
<blockquote>
<p>假设第一种情况的结果已经计算出来</p>
<p>如果我们处于第三种情况下的第<code>1</code>位的时候，<strong>思考：后面的部分还需要再次计算吗？</strong></p>
<ul>
<li>显然不需要，因为在第一种情况的时候已经算过了，只要我们将第一种情况计算的结果保存一下即可再次复用</li>
</ul>
<p>如果我们处于第二种情况下的第<code>1</code>位的时候，<strong>思考：后面的部分还需要再次计算吗？</strong></p>
<ul>
<li>这次是需要滴！有人可能有疑问了，为啥第三种情况不需要计算，而第二种情况就需要了</li>
<li>设绿色部分的结果为<code>x</code>，如果直接复用，那么第二种情况最终返回的结果为<code>x</code>，显然有问题呀，因为第二种情况的第<code>1</code>位为 1，所以第二种情况的结果应该是<code>x + 1</code>才对呀</li>
<li>出现这个问题的原因在于：我们不能只通过位数来表示一种状态，还需要根据当前已有 1 数量，即参数<code>oneCnt</code>，所以我们可以用一个二维数组<code>emeo[][]</code>来表示所有状态</li>
</ul>
<p>还有最后一个问题，蓝色部分的结果可以复用吗？</p>
<ul>
<li>显然也是不可以的，蓝色部分由于限制的原因，只能选择<code>0 - 3</code>，状态和上面绿色的部分是不一样的。<code>isLimit</code>限制至多只会出现 1 次，到时候特判一下即可</li>
</ul>
<p>说了这么多，都是教你如何唯一标识一个「状态」，其实这里有一个小窍门，记录「状态」是为了减少递归的次数，也就是说一次递归的结果对应着一个「状态」。所以看递归函数中的参数有哪些，就可以判断如何才能唯一标识一个「状态」</p>
</blockquote>
<ul>
<li><p>该题目的最终代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] s;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[][] emeo;  <span class="comment">// 备忘录</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    s = Integer.toString(n).toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">    <span class="comment">// 根据题目给出的范围，一个数中 1 的数量最多只有 10 种情况</span></span><br><span class="line">    emeo = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// 初始化为 -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) Arrays.fill(emeo[i], -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span> ,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 回从第 i 位开始，数字中 1 的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> oneCnt, <span class="type">boolean</span> isLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 结束条件：到达此处的路径均为可行解，oneCnt 表示该可行解中 1 的数量</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> oneCnt;</span><br><span class="line">    <span class="comment">// 「没有限制」且「该状态结果已经计算出」，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isLimit &amp;&amp; emeo[i][oneCnt] != -<span class="number">1</span>) <span class="keyword">return</span> emeo[i][oneCnt];</span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        res += f(i + <span class="number">1</span>, oneCnt + (d == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>), isLimit &amp;&amp; d == up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录该状态的结果</span></span><br><span class="line">    <span class="keyword">if</span> (!isLimit) emeo[i][oneCnt] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>思考</p>
<blockquote>
<p>结合备忘录和上图图解，第二种情况的黄色部分的解虽然也存进了emeo，但是并没有被复用，因为前面有一个<code>1</code>，所以该结果是存进emeo[1] [1]中，而第一种情况的绿色部分被存进了emeo[1] [0]，而后续部分复用的也是该结果。所有符合我们分析的情况</p>
</blockquote>
</li>
</ul>
<h2 id="47-旋转数字"><a href="#47-旋转数字" class="headerlink" title="47.旋转数字"></a>47.旋转数字</h2><ul>
<li><p>题目</p>
<blockquote>
<p>我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。</p>
<p>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 ,6 和 9可以互相旋转成对方（在这种情况下，它们以不同的方向旋转，换句话说，2 和 5 ，6 和 9互为镜像），除了这些以外其他的数字旋转以后都不再是有效的数字。</p>
<p>现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？</p>
<p>示例：</p>
<p>输入: 10<br>输出: 4<br>解释:<br>在[1, 10]中有四个好数： 2, 5, 6, 9。<br>注意 1 和 10 不是好数, 因为他们在旋转之后不变。</p>
</blockquote>
</li>
<li><p>分析</p>
<blockquote>
<p><strong>好数</strong>必须包含旋转后为不同的数字，我们用数组<code>ISDIFF[]</code>记录每个数字的旋转情况</p>
<ul>
<li><code>ISDIFF[i] == -1 表示 i 不能旋转，如：3，4，7</code></li>
<li><code>ISDIFF[i] == 0 表示 i 旋转后为同一个数字，如：0，1，8</code></li>
<li><code>ISDIFF[i] == 1 表示 i 旋转后为不同的数字，如：2，5，6，9</code></li>
</ul>
<p>则最后的<code>ISDIFF = &#123;0, 0, 1, -1, -1, 1, 1, -1, 0, 1&#125;</code></p>
<p>通过<code>ISDIFF</code>数组，我们可以进行剪枝，去掉不能进行旋转数字的情况</p>
<p>但是对于可以进行旋转的数字，我们也要考虑特殊情况：如果最终解里面的所有数字都是旋转得到本身的数字，则该解为无效解</p>
<p>因此我们需要备忘录<code>emeo[][]</code>，一维表示位数<code>i</code>, 二维表示是个包含旋转后为不同的数字<code>hasDiff</code></p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">char</span>[] s;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[][] emeo;</span><br><span class="line"><span class="comment">// ISDIFF[i] == -1 表示 i 不能旋转，如：3，4，7</span></span><br><span class="line"><span class="comment">// ISDIFF[i] == 0 表示 i 旋转后为同一个数字，如：0，1，8</span></span><br><span class="line"><span class="comment">// ISDIFF[i] == 1 表示 i 旋转后为不同的数字，如：2，5，6，9</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span>[] ISDIFF = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rotatedDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    s = Integer.toString(n).toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">    emeo = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) Arrays.fill(emeo[i], -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hasDiff 表示数字中是否包含旋转后为不同的数字，包含则为 1，不包含则为 0</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> hasDiff, <span class="type">boolean</span> isLimit)</span> &#123;</span><br><span class="line">    <span class="comment">// 结束条件：到达此处的路径根据 hasDiff 判断是否为可行解，直接返回 hasDiff 即可</span></span><br><span class="line">    <span class="keyword">if</span> (i == s.length) <span class="keyword">return</span> hasDiff;</span><br><span class="line">    <span class="keyword">if</span> (!isLimit &amp;&amp; emeo[i][hasDiff] != -<span class="number">1</span>) <span class="keyword">return</span> emeo[i][hasDiff];</span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i] - <span class="string">&#x27;0&#x27;</span> : <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= up; d++) &#123;</span><br><span class="line">        <span class="comment">// -1 表示存在不能旋转的数字，如：3，4，7，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (ISDIFF[d] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 ISDIFF[d] = 1，则表示旋转后为不同数字，hasDiff | ISDIFF[d] 或运算后值为 1</span></span><br><span class="line">            res += f(i + <span class="number">1</span>, hasDiff | ISDIFF[d], isLimit &amp;&amp; d == up);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isLimit) emeo[i][hasDiff] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="48-不含连续1的非负整数"><a href="#48-不含连续1的非负整数" class="headerlink" title="48.不含连续1的非负整数"></a>48.不含连续1的非负整数</h2><ul>
<li><p>题目</p>
<blockquote>
<p>给定一个正整数 n ，请你统计在 [0, n] 范围的非负整数中，有多少个整数的二进制表示中不存在 连续的 1 。</p>
<p>示例 1:</p>
<p>输入: n = 5<br>输出: 5<br>解释:<br>下面列出范围在 [0, 5] 的非负整数与其对应的二进制表示：<br>0 : 0<br>1 : 1<br>2 : 10<br>3 : 11<br>4 : 100<br>5 : 101<br>其中，只有整数 3 违反规则（有两个连续的 1 ），其他 5 个满足规则。</p>
</blockquote>
</li>
<li><p>分析</p>
<blockquote>
<p><code>emeo[i][j]</code>:数位为<code>i(0~m-1)</code>且最后一位为<code>j(0或1)</code>的结果</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">char</span>[] s;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[][] emeo;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    s = Integer.toString(n,<span class="number">2</span>).toCharArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length;</span><br><span class="line">    emeo = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m ;i++)  Arrays.fill(emeo[i],-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> prev, <span class="type">boolean</span> isLimit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == s.length) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isLimit &amp;&amp; emeo[i][prev] != -<span class="number">1</span>) <span class="keyword">return</span> emeo[i][prev];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> isLimit ? s[i]-<span class="string">&#x27;0&#x27;</span>:<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d=<span class="number">0</span>; d&lt;=up; d++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!(prev == <span class="number">1</span> &amp;&amp; d == <span class="number">1</span>)) res += dp(i+<span class="number">1</span>,d,isLimit &amp;&amp; d == up);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!isLimit) emeo[i][prev] = res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="49-序列DP-规划兼职工作"><a href="#49-序列DP-规划兼职工作" class="headerlink" title="49.序列DP_规划兼职工作"></a>49.序列DP_规划兼职工作</h2><ul>
<li>题目</li>
</ul>
<blockquote>
<p>你打算利用空闲时间来做兼职工作赚些零花钱。<br>这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。<br>给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。<br>注意，时间上出现重叠的 2 份工作不能同时进行。<br>如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。</p>
<p>实例：<br>输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]<br>输出：150<br>解释：<br>我们选择第 1，4，5 份工作。<br>共获得报酬 150 = 20 + 70 + 60。<br><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/Users\10306\AppData\Roaming\Typora\typora-user-images\image-20221022122142749.png" alt="image-20221022122142749" style="zoom:50%;"></p>
</blockquote>
<ul>
<li>分析</li>
</ul>
<blockquote>
<p>为了方便，我们令 <code>startTime</code> 为 <code>st</code>，<code>endTime</code> 为 <code>et</code>，<code>profit</code> 为 <code>ps</code>，同时定义三元组 <code>job[i] = (st[i], et[i], ps[i])job[i]=(st[i],et[i],ps[i])</code> 来代指某份工作。<br>在理想情况下，若能将所有工作排成不重叠的直线，我们便能通过完成所有工作来取得最大收益。<br><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/Users\10306\AppData\Roaming\Typora\typora-user-images\image-20221022122431052.png" alt="image-20221022122431052" style="zoom:50%;"></p>
<p>归结到每份工作，我们总有 [==选择完成该份工作==] 和 [==选择不完成该份工作==] 两种决策</p>
<p>我们定义<code>dp[i]</code>为考虑前 i 个工作，所能取得的最大收益(注意<code>job[i]</code>不一定被选择完成)，则有以下两种情况</p>
<ul>
<li><p>不选择该工作时，则<code>job[i]</code> 不会产生价值，则：<code>dp[i] = dp[i-1]</code></p>
</li>
<li><p>选择该工作时，又可分为==仅选择完成该工作==与==考虑选择将该工作接在某个工作后面完成==</p>
</li>
<li><p>当选择仅完成该工作时，有 <code>dp[i] = job[i][2]</code></p>
</li>
<li><p>考虑选择将该工作接在前面某个工作之后完成，我们则需要在所有满足<code>job[j][1] &lt;= job[i][0]</code> 中选择最合适的<code>job[j] </code>接在 <code>job[i]</code>的前面</p>
<p>即在所有能够在 <code>job[i]</code>开始前顺利结束的 <code>job[j]</code> 中取最大的 <code>dp[j]</code>，此时有 <code>dp[i] = dp[j] + job[i][2]</code></p>
</li>
</ul>
<p>最终 dp[i] 取上述三种方案的最大值，最终的dp[n]即为我们的答案。</p>
<p>此外，当我们处理<code>job[i]</code>时，为了能够 <strong>将所有能拼接在job[i]前面的job[j]归结到一边</strong> 并且 <strong>所能更新dp[i]的dp[j]均被计算</strong>，我们可以对所有的 job[i] 根据结束时间按从小到大排序<br><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/Users\10306\AppData\Roaming\Typora\typora-user-images\image-20221022145420938.png" alt="image-20221022145420938" style="zoom:50%;"></p>
<p>此处排序的意义有两点：</p>
<ol>
<li>由于是根据右端点排序，当我们处理到某个<code>job[i]</code>时，由于有 <code>job[X][0] &lt; job[X][1]</code>，则所能接在<code>job[i]</code>之前的<code>job[j]</code>必然位于<code>[0,i)</code>之间</li>
<li>由于我们对<code>dp[i]</code>的定义并不限定必须选 <code>job[i]</code>，因此在<code>[0,i)</code>范围内以<code>job[j]</code>为分割点的数组具有二段性：坐标范围 <code>&lt;= j</code> 的<code>job[X]</code> 均可接在 <code>job[i]</code>前面。因此可以通过二分来找所能接在<code>job[i]</code>之前的坐标最大的<code>job[j]</code></li>
</ol>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">jobScheduling</span><span class="params">(<span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">    <span class="comment">//将所给的三个数组转化为三元组 jobs[i] = &#123;开始时间，结束时间，收益&#125;</span></span><br><span class="line">    <span class="type">int</span>[][] jobs = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        jobs[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startTime[i], endTime[i], profit[i]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据结束时间排序</span></span><br><span class="line">    Arrays.sort(jobs,(a,b)-&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i]数组表示排序后的前i个工作能得到的最大profit</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="comment">//找到结束时间最接近当前工作开始时间的工作的下标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> search(jobs, i, jobs[i][<span class="number">0</span>]);</span><br><span class="line">        dp[i + <span class="number">1</span>] = Math.max(dp[i],dp[j+<span class="number">1</span>] + jobs[i][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找：找到endTime &lt;= upper 的最大下标</span></span><br><span class="line"><span class="comment">//二分使用：左闭右闭，&lt;=有意义，+1 -1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[][] jobs, <span class="type">int</span> right, <span class="type">int</span> upper)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(jobs[mid][<span class="number">1</span>] &lt;= upper) left = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(right);</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="50-多米诺和托米诺平铺"><a href="#50-多米诺和托米诺平铺" class="headerlink" title="50.多米诺和托米诺平铺"></a>50.多米诺和托米诺平铺</h2><ul>
<li><p>题目</p>
<blockquote>
<p>有两种形状的瓷砖：一种是 <code>2 x 1</code> 的多米诺形，另一种是形如 “L” 的托米诺形。两种形状都可以旋转。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/Users\10306\AppData\Roaming\Typora\typora-user-images\image-20221112131023888.png" alt="image-20221112131023888" style="zoom:50%;">







<p>给定整数 n ，返回可以平铺 <code>2 x n </code>的面板的方法的数量。返回对 109 + 7 取模 的值。</p>
<p>平铺指的是每个正方形都必须有瓷砖覆盖。两个平铺不同，当且仅当面板上有四个方向上的相邻单元中的两个，使得恰好有一个平铺有一个瓷砖占据两个正方形。</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20221112131229007.png" alt="image-20221112131229007"></p>
</blockquote>
</li>
<li><p>思路</p>
</li>
</ul>
<blockquote>
<p>回忆经典题目==爬楼梯==的思路，爬到当前位置的楼梯，可以由上一节楼梯爬一步过来，也可以由上上一节楼梯爬两步过来。</p>
<p>回到当前题目每一列瓷砖都有几种情况。铺满，只铺了上面一块，只铺了下面一块，没铺。这四种状态都可以由前面瓷砖的某些状态加上新的瓷砖来得到。而最后一列的铺满状态即为我们需要的解</p>
<ol>
<li>dp数组以及下标的含义</li>
</ol>
<p> dp[i] [j]：平铺到第i列瓷砖，状态为j时的方法数。其中i为当前位置的列数。j为上述列出的四种状态。</p>
<p> 即j = 0,铺满；j = 1,只铺上面一块；j = 2, 只铺了下面一块；j = 3, 没铺</p>
<ol start="2">
<li>递推公式</li>
</ol>
<p> 考虑铺到第i列，状态转移方程如下：</p>
<ul>
<li><p>当<code>j=0</code>时，最后一列铺满，可由前一列的<code>0,1,2,3</code>四种状态铺上对应的瓷砖转移而来，即 <code>f[i−1][0]</code> 竖着铺上 1 x 2 型瓷砖，或者 <code>f[i−1][1] </code>铺上 L’ 型瓷砖，或者 <code>f[i−1][2]</code> 铺上 L’ 型瓷砖，或者 <code>f[i−1][3]</code> 铺上两块 2 x 1 型瓷砖。因此      $$ f[i][0]=\sum_{j=0}^{3} f[i-1][j] $$</p>
</li>
<li><p>当 <code>j=1</code> 时，最后一列只铺了上方一个瓷砖，可由前一列的 <code>2,3 </code>两种状态转移而来，即 <code>f[i−1][2]</code> 铺上 2 x 1 型瓷砖，或者 <code>f[i−1][3]</code> 铺上 L 型瓷砖。因此<code>f[i][1]=f[i−1][2]+f[i−1][3]</code>。</p>
</li>
<li><p>当 <code>j=2</code> 时，最后一列只铺了下方一个瓷砖，可由前一列的 <code>1,3</code> 两种状态转移而来，即 <code>f[i−1][1]</code> 铺上 2 x 1 型瓷砖，或者 <code>f[i−1][3]</code>铺上 L’ 型瓷砖。因此<code>f[i][2]=f[i−1][1]+f[i−1][3]</code>。</p>
</li>
<li><p>当 <code>j=3</code>时，最后一列没有铺瓷砖，可由前一列的<code>0</code>一种状态转移而来，即 <code>f[i−1][0] </code>铺上两块 2 x 1 型瓷砖。因此 <code>f[i][3]=f[i−1][0]</code>。</p>
</li>
</ul>
<ol start="3">
<li>初始化</li>
</ol>
<p> <code>dp[0][0] = 1</code>,其余<code>dp[0][j] = 0</code></p>
</blockquote>
<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">numTilings</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">long</span>[] f = &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> (<span class="type">int</span>)<span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="comment">//使用滚动数组减少空间复杂度</span></span><br><span class="line">        <span class="type">long</span>[] g = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">4</span>];</span><br><span class="line">        g[<span class="number">0</span>] = (f[<span class="number">0</span>] + f[<span class="number">1</span>] + f[<span class="number">2</span>] + f[<span class="number">3</span>]) % mod;</span><br><span class="line">        g[<span class="number">1</span>] = (f[<span class="number">2</span>] + f[<span class="number">3</span>]) % mod;</span><br><span class="line">        g[<span class="number">2</span>] = (f[<span class="number">1</span>] + f[<span class="number">3</span>]) % mod;</span><br><span class="line">        g[<span class="number">3</span>] = f[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        f = g;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>)f[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="交错字符串"><a href="#交错字符串" class="headerlink" title="交错字符串"></a>交错字符串</h2><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230412104254688.png" alt="image-20230412104254688"></p>
<p><strong>思路</strong></p>
<p><code>boolean[][] dp[i][j]</code> 含义：s1 前缀长度 <code>i</code> + s2 前缀长度 <code>j</code>，能否交错组成 s3 前缀长度 <code>i + j</code><br>考虑s3的最后一个字符s3[i+j-1]来自哪里？ 做状态转移：</p>
<blockquote>
<p>1）如果来自 s1[i-1]，则<code>dp[i][j]</code> 为：s1前缀长度<code>i-1</code> + s2前缀长度<code>j</code> 能否交错组成s3前缀长度i+j-1，即：<code>dp[i-1][j]</code><br>2）如果来自 s2[j-1]，则<code>dp[i][j]</code> 为：s1前缀长度<code>i</code> + s2前缀长度<code>j-1</code> 能否交错组成s3前缀长度i+j-1，即：<code>dp[i][j-1]</code></p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String str1, String str2, String str3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str2.length();</span><br><span class="line">        <span class="keyword">if</span> (str3.length() != n + m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// dp[i][j]：s1前缀长度i + s2前缀长度j，能否交错组成s3前缀长度i+j</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray(), s2 = str2.toCharArray(), s3 = str3.toCharArray();</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 第0行：s1前缀长度0 + s2前缀长度i，能否交错组成s3前缀长度i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i-<span class="number">1</span>] &amp;&amp; s2[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第0列：s1前缀长度i + s2前缀长度0，能否交错组成s3前缀长度i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i-<span class="number">1</span>][<span class="number">0</span>] &amp;&amp; s1[i - <span class="number">1</span>] == s3[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 普通位置 dp[i][j]：s1前缀长度i + s2前缀长度j，能否交错组成s3前缀长度i+j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">// 考虑s3的最后一个字符s3[i+j-1]来自哪里？做状态转移：</span></span><br><span class="line">                <span class="comment">// 1）如果来自s1[i-1]，则dp[i][j] 为：s1前缀长度i-1 + s2前缀长度j 能否交错组成s3前缀长度i+j-1，即：dp[i-1][j]</span></span><br><span class="line">                <span class="comment">// 2）如果来自s2[j-1]，则dp[i][j] 为：s1前缀长度i + s2前缀长度j-1 能否交错组成s3前缀长度i+j-1，即：dp[i][j-1]</span></span><br><span class="line">                dp[i][j] = (s1[i-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>] &amp;&amp; dp[i-<span class="number">1</span>][j]) ||</span><br><span class="line">                           (s2[j-<span class="number">1</span>] == s3[i+j-<span class="number">1</span>] &amp;&amp; dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="51-备忘录到动态规划"><a href="#51-备忘录到动态规划" class="headerlink" title="51.==备忘录到动态规划=="></a>51.==备忘录到动态规划==</h2><p><strong>概述</strong></p>
<p>动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出<strong>正确的「状态转移方程」</strong>，才能正确地穷举。而且，你需要判断算法问题是否<strong>具备「最优子结构」</strong>，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>重叠子问题、最优子结构、状态转移方程就是动态规划三要素。</p>
<p><strong>以斐波那契数列为例</strong></p>
<p><strong>1.暴力递归</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">1</span> || N == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fib(N - <span class="number">1</span>) + fib(N - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暴力递归是自顶向下的求解，其中存在大量重复计算</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230602114126364.png" alt="image-20230602114126364" style="zoom:50%;" align="left">

<p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间</strong>。</p>
<p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别，爆炸。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<p><strong>2.带备忘录的递归解法</strong></p>
<p>明确了问题，其实就已经把问题解决了一半。即然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录全初始化为 0</span></span><br><span class="line">    <span class="type">int</span>[] memo = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 进行带备忘录的递归</span></span><br><span class="line">    <span class="keyword">return</span> dp(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带着备忘录进行递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[] memo, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="comment">// 已经计算过，不用再计算了</span></span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = dp(memo, n - <span class="number">1</span>) + dp(memo, n - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230602114346367.png" alt="image-20230602114346367" style="zoom:50%;" align="left">

<p>实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230602114431999.png" alt="image-20230602114431999" style="zoom:50%;" align="left">

<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间</strong>。</p>
<p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p>
<p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p>
<p>所以，本算法的时间复杂度是 O(n)，比起暴力算法，是降维打击。</p>
<p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和常见的动态规划解法已经差不多了，只不过这种解法是「自顶向下」进行「递归」求解，我们更常见的动态规划代码是「自底向上」进行「递推」求解。</p>
<p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p>啥叫「自底向上」？反过来，我们直接从最底下、最简单、问题规模最小、已知结果的 <code>f(1)</code> 和 <code>f(2)</code>（base case）开始往上推，直到推到我们想要的答案 <code>f(20)</code>。这就是「递推」的思路，这也是动态规划一般都脱离了递归，而是由循环迭代完成计算的原因。</p>
<p><strong>3.dp数组的迭代解法</strong></p>
<p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，通常叫做 DP table，在这张表上完成「自底向上」的推算岂不美哉！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>; dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 状态转移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230602114641697.png" alt="image-20230602114641697" style="zoom:50%;" align="left">

<p>画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230602114739933.png" alt="image-20230602114739933" style="zoom:50%;" align="left">

<p>为啥叫「状态转移方程」？其实就是为了听起来高端。</p>
<p><code>f(n)</code> 的函数参数会不断变化，所以你把参数 <code>n</code> 想做一个状态，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 转移（相加）而来，这就叫状态转移，仅此而已。</p>
<p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。</p>
<p>可见列出「状态转移方程」的重要性，它是解决问题的核心，而且很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。</p>
<p>只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<h2 id="最小下降路径和"><a href="#最小下降路径和" class="headerlink" title="最小下降路径和 "></a>最小下降路径和 <img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230602113600780.png" alt="image-20230602113600780"></h2><p><strong>备忘录解法 — 自顶向下</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFallingPathSum</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            Arrays.fill(memo[i], <span class="number">10001</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            res = Math.min(res, dp(matrix, n - <span class="number">1</span>, j));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dp</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断索引是否违规</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt;= matrix.length || j &lt; <span class="number">0</span> || j &gt;= matrix.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10001</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> matrix[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[i][j] != <span class="number">10001</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line"></span><br><span class="line">        memo[i][j] = matrix[i][j] +  min(dp(matrix, i - <span class="number">1</span>, j -<span class="number">1</span>), dp(matrix, i - <span class="number">1</span>, j), dp(matrix, i - <span class="number">1</span>, j + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> memo[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>dp解法 — 自底向上</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minFallingPathSum</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dp[i] = matrix[<span class="number">0</span>][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">numleft</span> <span class="operator">=</span> j == <span class="number">0</span> ? <span class="number">10001</span> : temp;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nummid</span>  <span class="operator">=</span> dp[j];</span><br><span class="line">                <span class="type">int</span> <span class="variable">numright</span> <span class="operator">=</span> j == n - <span class="number">1</span> ? <span class="number">10001</span> : dp[j + <span class="number">1</span>];</span><br><span class="line">                temp = dp[j];</span><br><span class="line">                dp[j] = matrix[i][j] + min(numleft, nummid, numright);</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            res = Math.min(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.min(a, Math.min(b, c));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="52-鸡蛋掉落—两枚鸡蛋"><a href="#52-鸡蛋掉落—两枚鸡蛋" class="headerlink" title="52.鸡蛋掉落—两枚鸡蛋"></a>52.鸡蛋掉落—两枚鸡蛋</h2><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230717212219910.png" alt="image-20230717212219910" style="zoom: 80%;" align="left">

<p><strong>思路</strong></p>
<p>手中一共有两枚鸡蛋。假如楼高为 i，我们从第 j 层扔下去(1 &lt;= j &lt;= i),那么会有<strong>两种</strong>可能，一种是鸡蛋碎了，另一种是鸡蛋没碎。</p>
<ul>
<li>鸡蛋碎了：那么手中还剩一枚鸡蛋，我们只能从第 1 楼开始依次往上尝试到第j - 1楼，最多可能要尝试 j - 1次，加上摔碎的那一次，一共 j - 1+ 1 = j 次。</li>
<li>鸡蛋没碎：那么 1 ~ j 楼可以知道不会摔碎。j + 1 ~ i 共 i - j 层楼需要我们继续尝试，此时可以细分为子问题，求楼高为 i - j的楼层需要多少次，加上扔的那一次，一共 dp[i - j] + 1次。</li>
</ul>
<p>即dp[i] 为 楼高为 i 时需要尝试的最少次数。则 <code>dp[i] = Math.max(dp[i - j], j)</code></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoEggDrop</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                min = Math.min(Math.max(dp[i - j] + <span class="number">1</span>, j), min);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = min;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a>正则表达式匹配</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231003214145357.png" alt="image-20231003214145357" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>先思考 s 与 p 的匹配过程，两个指针i, j分别指向两个串上的字符，当前字符可以匹配，则指针向后移动，如果最后两个指针都能移到字符串末尾，则可以匹配</p>
<p>先不考虑 「*」通配符，只有「.」通配符。匹配代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(string s, string p)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; p.length()) &#123;</span><br><span class="line">        <span class="comment">// 「.」通配符就是万金油</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 匹配，接着匹配 s[i+1..] 和 p[j+1..]</span></span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i == j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>现在考虑加入「*」，分析如下：</p>
<p>当 p[j + 1] 为 * 通配符时，我们分情况讨论下：</p>
<p>1、如果 s[i] == p[j]，那么有两种情况：</p>
<p>1.1 p[j] 有可能会匹配多个字符，比如 s = “aaa”, p = “a*”，那么 p[0] 会通过 * 匹配 3 个字符 “a”。</p>
<p>1.2 p[i] 也有可能匹配 0 个字符，比如 s = “aa”, p = “a*aa”，由于后面的字符可以匹配 s，所以 p[0] 只能匹配 0 次。</p>
<p>2、如果 s[i] != p[j]，只有一种情况：</p>
<p>p[j] 只能匹配 0 次，然后看下一个字符是否能和 s[i] 匹配。比如说 s = “aa”, p = “b*aa”，此时 p[0] 只能匹配 0 次。</p>
<p>综上，可以把之前的代码针对 <code>*</code> 通配符进行一下改造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// 匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，可以匹配 0 次或多次</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，老老实实匹配 1 次</span></span><br><span class="line">        i++; j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不匹配</span></span><br><span class="line">    <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 有 * 通配符，只能匹配 0 次</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 无 * 通配符，匹配无法进行下去了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>现在的问题就是 匹配多次 到底应该匹配多少次？</strong></p>
<p>这是一个做「选择」的问题，要把所有可能的选择都穷举一遍才能得出结果。动态规划算法的核心就是「状态」和「选择」，「状态」无非就是 i 和 j 两个指针的位置，「选择」就是 p[j] 选择匹配几个字符。</p>
<p><strong>动态规划(递归 + 备忘录)解法思路</strong></p>
<p>定义一个函数，函数签名如下：<code> boolean dp(string s, int i, string p, int j);</code></p>
<p>函数的定义如下：</p>
<p>若 dp(s, i, p, j) = true，则表示 s[i ~ len - 1] 可以匹配 p[j ~ len - 1]；若 dp(s, i, p, j) = false，则表示 s[i ~ len - 1] 不匹配 p[j ~ len - 1]</p>
<p>根据这个定义，我们想要的答案就是 i = 0, j = 0 时 dp 函数的结果，所以可以这样使用这个 dp 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">isMatch</span><span class="params">(string s, string p)</span> &#123;</span><br><span class="line">    <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在可以得到dp函数的主要逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(string s, <span class="type">int</span> i, string p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// 匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 1.1 通配符匹配 0 次或多次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">                || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 常规匹配 1 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; p.size() - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1 通配符匹配 0 次</span></span><br><span class="line">            <span class="keyword">return</span> dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 2.2 无法继续匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据函数定义，上述情况很好解释：</p>
<p>1.1 通配符匹配 0 次或多次</p>
<p>将 <code>j</code> 加 2，<code>i</code> 不变，含义就是直接跳过 <code>p[j]</code> 和之后的通配符，即通配符匹配 0 次：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231003220322166.png" alt="image-20231003220322166" style="zoom: 33%;" align="left">



<p>将 <code>i</code> 加 1，<code>j</code> 不变，含义就是 <code>p[j]</code> 匹配了 <code>s[i]</code>，但 <code>p[j]</code> 还可以继续匹配，即通配符匹配多次的情况：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231003220347221.png" alt="image-20231003220347221" style="zoom:33%;" align="left">

<p>两种情况只要有一种可以完成匹配即可，所以对上面两种情况求或运算。</p>
<p>1.2 常规匹配 1 次</p>
<p>由于这个条件分支是无 <code>*</code> 的常规匹配，那么如果 <code>s[i] == p[j]</code>，就是 <code>i</code> 和 <code>j</code> 分别加一：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231003220437875.png" alt="image-20231003220437875" style="zoom:33%;" align="left">



<p>2.1 通配符匹配 0 次</p>
<p>类似情况 1.1，将 <code>j</code> 加 2，<code>i</code> 不变：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231003220500087.png" alt="image-20231003220500087" style="zoom:33%;" align="left">

<p>2.2 如果没有 <code>*</code> 通配符，也无法匹配，那只能说明匹配失败了：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231003220523057.png" alt="image-20231003220523057" style="zoom:33%;" align="left">

<p>看图理解应该很容易了，现在可以思考一下 dp 函数的 base case：</p>
<p>一个 base case 是 j == p.size() 时，按照 dp 函数的定义，这意味着模式串 p 已经被匹配完了，那么应该看看文本串 s 匹配到哪里了，如果 s 也恰好被匹配完，则说明匹配成功：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (j == p.size()) &#123;</span><br><span class="line">    <span class="keyword">return</span> i == s.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一个 base case 是 i == s.size() 时，按照 dp 函数的定义，这种情况意味着文本串 s 已经全部被匹配了，那么是不是只要简单地检查一下 p 是否也匹配完就行了呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == s.size()) &#123;</span><br><span class="line">    <span class="comment">// 这样行吗？</span></span><br><span class="line">    <span class="keyword">return</span> j == p.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是==不正确==的，此时并不能根据 j 是否等于 p.size() 来判断是否完成匹配，只要 p[j..] 能够匹配空串，就可以算完成匹配。比如说 s = “a”, p = “ab<em>c</em>“，当 i 走到 s 末尾的时候，j 并没有走到 p 的末尾，但是 p 依然可以匹配 s。</p>
<p>所以我们可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.size(), n = p.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i == s.size()) &#123;</span><br><span class="line">    <span class="comment">// 如果能匹配空串，一定是字符和 * 成对儿出现</span></span><br><span class="line">    <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是否为 x*y*z* 这种形式</span></span><br><span class="line">    <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; p.size(); j += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据以上思路，就可以写出完整的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 计算 p[j..] 是否匹配 s[i..] */</span></span><br><span class="line">bool <span class="title function_">dp</span><span class="params">(string&amp; s, <span class="type">int</span> i, string&amp; p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.size(), n = p.size();</span><br><span class="line">    <span class="comment">// base case</span></span><br><span class="line">    <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">        <span class="keyword">return</span> i == m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == m) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n - j) % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (; j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录状态 (i, j)，消除重叠子问题</span></span><br><span class="line">    <span class="type">string</span> <span class="variable">key</span> <span class="operator">=</span> to_string(i) + <span class="string">&quot;,&quot;</span> + to_string(j);</span><br><span class="line">    <span class="keyword">if</span> (memo.count(key)) <span class="keyword">return</span> memo[key];</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>)</span><br><span class="line">               || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; n - <span class="number">1</span> &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前结果记入备忘录</span></span><br><span class="line">    memo[key] = res;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码中用了一个哈希表 memo 消除重叠子问题，因为正则表达算法的递归框架如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bool <span class="title function_">dp</span><span class="params">(string&amp; s, <span class="type">int</span> i, string&amp; p, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    dp(s, i, p, j + <span class="number">2</span>);     <span class="comment">// 1</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j);     <span class="comment">// 2</span></span><br><span class="line">    dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>那么，如果让你从 <code>dp(s, i, p, j)</code> 得到 <code>dp(s, i+2, p, j+2)</code>，至少有两条路径：1 -&gt; 2 -&gt; 2 和 3 -&gt; 3，那么就说明 (i+2, j+2) 这个状态存在重复，这就说明存在重叠子问题。</p>
<p>动态规划的时间复杂度为「状态的总数」*「每次递归花费的时间」，本题中状态的总数当然就是 i 和 j 的组合，也就是 M * N（M 为 s 的长度，N 为 p 的长度）；递归函数 dp 中没有循环（base case 中的不考虑，因为 base case 的触发次数有限），所以一次递归花费的时间为常数。二者相乘，总的时间复杂度为 O(MN)。</p>
<p>空间复杂度很简单，就是备忘录 memo 的大小，即 O(MN)。</p>
<p><strong>完整代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 备忘录 记录已经计算过的情况</span></span><br><span class="line">Map&lt;String, Boolean&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="comment">// 指针 i，j 从索引 0 开始移动</span></span><br><span class="line">    <span class="keyword">return</span> dp(s, <span class="number">0</span>, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dp</span><span class="params">(String s, <span class="type">int</span> i, String p, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s.length(), n = p.length();</span><br><span class="line">    <span class="comment">// p 已经匹配完，如果 s 也匹配结束，则可以成功匹配</span></span><br><span class="line">    <span class="keyword">if</span>(j == n) <span class="keyword">return</span> i == m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s 匹配完，p 没有匹配完，则 p 剩下的串必须为 x*y*z*...，即必须要偶数个，且偶数位必须为 * </span></span><br><span class="line">    <span class="keyword">if</span>(i == m)&#123;</span><br><span class="line">        <span class="comment">// 如果能匹配空串，一定是字符和 * 成对儿出现</span></span><br><span class="line">        <span class="keyword">if</span>((n - j) % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j + <span class="number">1</span> &lt; n; j += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j + <span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 备忘录，记录状态 (i, j)，消除重叠子问题</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> i + <span class="string">&quot;,&quot;</span> + j;</span><br><span class="line">    <span class="keyword">if</span>(memo.containsKey(key)) <span class="keyword">return</span> memo.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span> s.charAt(i), cp = p.charAt(j);</span><br><span class="line">    <span class="comment">// 当前位置可以匹配</span></span><br><span class="line">    <span class="keyword">if</span>(cs == cp || cp == <span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 1.1 通配符匹配 0 次或多次</span></span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>) || dp(s, i + <span class="number">1</span>, p, j);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 1.2 常规匹配 1 次</span></span><br><span class="line">            res = dp(s, i + <span class="number">1</span>, p, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前位置不能匹配</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; n - <span class="number">1</span> &amp;&amp; p.charAt(j + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            <span class="comment">// 2.1 通配符匹配 0 次</span></span><br><span class="line">            res = dp(s, i, p, j + <span class="number">2</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="comment">// 2.2 无法继续匹配</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录结果</span></span><br><span class="line">    memo.put(key, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="5-回溯算法专题总结"><a href="#5-回溯算法专题总结" class="headerlink" title="5.回溯算法专题总结"></a>5.回溯算法专题总结</h2><h3 id="1-回溯算法介绍"><a href="#1-回溯算法介绍" class="headerlink" title="1.回溯算法介绍"></a>1.回溯算法介绍</h3><p>​    <strong>回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案</strong>，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。</p>
<ul>
<li><p>解决的问题</p>
<ul>
<li>组合(无序)问题：N个数里面按一定规则找出k个数的集合</li>
<li>切割问题：一个字符串按一定规则有几种切割方式</li>
<li>子集问题：N个数的集合里有多少符合条件的子集</li>
<li>排列(有序)问题：N个数按一定规则全排列，有多少种排列方式</li>
<li>棋盘问题：N皇后，解数独等等</li>
</ul>
</li>
<li><p>理解回溯</p>
<blockquote>
<p>回溯法解决的问题可以抽象为==树形结构==。因为回溯解决的问题手上在集合中递归查找子集，<strong>集合的大小构成树的宽度，递归的深度构成树的深度</strong>，由于递归有终止条件，所有最后必然得到一颗高度有限的<strong>N叉树</strong></p>
</blockquote>
</li>
<li><p>回溯算法模版框架</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void backtracking(参数) &#123;</span><br><span class="line">    if (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); // 递归</span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>回溯搜索的遍历过程</p>
<p>​    回溯法一般是在集合中递归搜索，集合的大小构成了树的宽度，递归的深度构成的树的深度。</p>
</li>
</ul>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20221004183454450.png" alt="image-20221004183454450"></p>
<blockquote>
<p> for循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个for循环就执行多少次。</p>
<p> backtracking这里自己调用自己，实现递归。</p>
<p> 大家可以从图中看出<strong>for循环可以理解是横向遍历，backtracking（递归）就是纵向遍历</strong>，这样就把这棵树全遍历完了，一般来说，搜索叶子节点就是找的其中一个结果了。</p>
</blockquote>
<h3 id="组合-子集-与排列问题总结"><a href="#组合-子集-与排列问题总结" class="headerlink" title="组合(子集)与排列问题总结"></a>组合(子集)与排列问题总结</h3><ul>
<li>元素 无重复 且 不可重复选</li>
</ul>
<blockquote>
<p>组合：依次往右选取即可(使用start标记开始选取的范围)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line"> <span class="comment">// 回溯算法标准框架</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">     <span class="comment">// 做选择</span></span><br><span class="line">     track.addLast(nums[i]);</span><br><span class="line">     <span class="comment">// 注意参数</span></span><br><span class="line">     backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 撤销选择</span></span><br><span class="line">     track.removeLast();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>排列：每次都从第一个元素开始选取，使用used数组标记元素是否已经使用，确保每个元素只使用一次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">     <span class="comment">// 剪枝逻辑</span></span><br><span class="line">     <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 做选择</span></span><br><span class="line">     used[i] = <span class="literal">true</span>;</span><br><span class="line">     track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">     backtrack(nums);</span><br><span class="line">     <span class="comment">// 撤销选择</span></span><br><span class="line">     track.removeLast();</span><br><span class="line">     used[i] = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>元素 有重复 且 不可重复选取</p>
<blockquote>
<p>组合：元素有重复，对数组进行排序，跳过与之前元素重复的值即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line"><span class="comment">/* 组合/子集问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line"> <span class="comment">// 回溯算法标准框架</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">     <span class="comment">// 剪枝逻辑，跳过值相同的相邻树枝</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;<span class="comment">// i == start时，元素第一次选用，不需要判重复</span></span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 做选择</span></span><br><span class="line">     track.addLast(nums[i]);</span><br><span class="line">     <span class="comment">// 注意参数</span></span><br><span class="line">     backtrack(nums, i + <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 撤销选择</span></span><br><span class="line">     track.removeLast();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排列：对数组排序，固定重复元素在排列中的相对位置 ==难点==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(nums);</span><br><span class="line"><span class="comment">/* 排列问题回溯算法框架 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">     <span class="comment">// 剪枝逻辑</span></span><br><span class="line">     <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 剪枝逻辑，固定相同的元素在排列中的相对位置</span></span><br><span class="line">     <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !used[i - <span class="number">1</span>]) &#123; <span class="comment">// 保证相同的元素在排列中被选取的顺序与排序后的顺序相同</span></span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 做选择</span></span><br><span class="line">     used[i] = <span class="literal">true</span>;</span><br><span class="line">     track.addLast(nums[i]);</span><br><span class="line"></span><br><span class="line">     backtrack(nums);</span><br><span class="line">     <span class="comment">// 撤销选择</span></span><br><span class="line">     track.removeLast();</span><br><span class="line">     used[i] = <span class="literal">false</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>元素无重复可重复选</p>
<blockquote>
<p>组合：类似无重复不可重复选的情况，只需要将传递 i+1 改为传递 i 即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start)</span> &#123;</span><br><span class="line"> <span class="comment">// 回溯算法标准框架</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">     <span class="comment">// 做选择</span></span><br><span class="line">     track.addLast(nums[i]);</span><br><span class="line">     <span class="comment">// 注意参数</span></span><br><span class="line">     backtrack(nums, i);</span><br><span class="line">     <span class="comment">// 撤销选择</span></span><br><span class="line">     track.removeLast();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>排列：不需要任何操作，遍历整棵树即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">     <span class="comment">// 做选择</span></span><br><span class="line">     track.addLast(nums[i]);</span><br><span class="line">     backtrack(nums);</span><br><span class="line">     <span class="comment">// 撤销选择</span></span><br><span class="line">     track.removeLast();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</blockquote>
<h3 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2.==组合问题=="></a>2.==组合问题==</h3><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><ul>
<li>题目描述</li>
</ul>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240308140746234.png" alt="image-20240308140746234" style="zoom:80%;" align="left">

<ul>
<li><p>递归搜索的树形结构</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20221004190017150.png" alt="image-20221004190017150"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存所有结果的list</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//保存单次结果的list，主要用于回溯每一种结果</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    backtracking(<span class="number">1</span>,n,k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 当前可加入元素的起始下限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 数值可取的上限</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> k 还需要取的元素个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> startIndex,<span class="type">int</span> n,<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="comment">//元素个数满足需求时，得到一组解</span></span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//此处需要深拷贝原list，因为回溯处理会改变原list的值</span></span><br><span class="line">        List&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">        res.add(list1);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归构建一组解</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    剪枝优化：优化前 i&lt;=n, 优化后 i&lt;=n-k+1</span></span><br><span class="line"><span class="comment">    原理：如果 n = 7, k = 4，从 5 开始搜索就已经没有意义了，这是因为：</span></span><br><span class="line"><span class="comment">        即使把 5 选上，后面的数只有 6 和 7，一共就 3 个候选数，凑不出 4 个数的组合。</span></span><br><span class="line"><span class="comment">        因此，搜索起点有上界</span></span><br><span class="line"><span class="comment">    可以归纳出：</span></span><br><span class="line"><span class="comment">    搜索起点的上界(startIndex) + 接下来要选择的元素个数(k) - 1 = n</span></span><br><span class="line"><span class="comment">    整理得到：</span></span><br><span class="line"><span class="comment">    搜索起点的上界 = n - k + 1</span></span><br><span class="line"><span class="comment">    所以，我们的剪枝过程就是：把 i &lt;= n 改成 i &lt;= n - k + 1 ：</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=startIndex;i&lt;=n-k+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        list.add(i);<span class="comment">//加入当前元素</span></span><br><span class="line">        k--;<span class="comment">//需要的元素个数-1</span></span><br><span class="line"></span><br><span class="line">        backtracking(i+<span class="number">1</span>,n,k);<span class="comment">//递归查找下一个元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//回溯处理，还原list和k</span></span><br><span class="line">        k++;</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合总和III-—-元素无重复不可重复选"><a href="#组合总和III-—-元素无重复不可重复选" class="headerlink" title="组合总和III — 元素无重复不可重复选"></a>组合总和III — <strong>元素无重复不可重复选</strong></h3><ul>
<li><p>问题描述</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240308143422192.png" alt="image-20240308143422192" style="zoom:80%;" align="left"></li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：本题在上一题的剪枝方法上增加一层k值和n值的判断，当二者有一个&lt;0时则当前组合一定不符合条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum3</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    bt(<span class="number">1</span>, n, k, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bt</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> sum, <span class="type">int</span> count, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sum &lt;= <span class="number">0</span> || count &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">0</span> &amp;&amp; count == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cur; i &lt;= sum &amp;&amp; i &lt;= <span class="number">9</span>; i++)&#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        bt(i + <span class="number">1</span>, sum - i, count - <span class="number">1</span>, list);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h3><ul>
<li><p>题目</p>
<blockquote>
<p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。</p>
<p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HashMap&lt;Character,<span class="type">char</span>[]&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();<span class="comment">//记录数字字符与字母字符的映射</span></span><br><span class="line"><span class="keyword">static</span> List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">    map.put(<span class="string">&#x27;2&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;3&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;f&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;4&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;5&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;j&#x27;</span>,<span class="string">&#x27;k&#x27;</span>,<span class="string">&#x27;l&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;6&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;m&#x27;</span>,<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;7&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;p&#x27;</span>,<span class="string">&#x27;q&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;s&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;8&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;v&#x27;</span>&#125;);</span><br><span class="line">    map.put(<span class="string">&#x27;9&#x27;</span>,<span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;z&#x27;</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] tempCh = <span class="keyword">new</span> <span class="title class_">char</span>[digits.length()];</span><br><span class="line">    backtracking(digits,<span class="number">0</span>,tempCh);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String digits, <span class="type">int</span> index,<span class="type">char</span>[] ch)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == digits.length())&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">String</span>(ch));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//得到当前数字字符对应的字母字符</span></span><br><span class="line">    <span class="type">char</span>[] curCh = map.get(digits.charAt(index));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;curCh.length;i++)&#123;</span><br><span class="line">        ch[index] = curCh[i];</span><br><span class="line">        index++;</span><br><span class="line">        backtracking(digits,index,ch);</span><br><span class="line">        index--;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组合总和-—-元素无重复可重复选"><a href="#组合总和-—-元素无重复可重复选" class="headerlink" title="组合总和 — 元素无重复可重复选"></a>组合总和 — 元素无重复可重复选</h3><ul>
<li><p>题目</p>
</li>
<li><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240308144621149.png" alt="image-20240308144621149" style="zoom: 80%;" align="left"></li>
<li><p>如何保证最后得到是组合而不是排列</p>
<blockquote>
<p>对数组元素进行排序，然后递归时元素下标不+1，这样可以保证元素可以重复选取，且每次得到的结果的顺序的固定的，每种元素选择完成后再也不会被选择。</p>
<p>如果每次递归时下标都从0开始遍历，则会出现排列的结果</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存所有可行解</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//递归过程中保存当前解，主要用于回溯</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">//对数组进行排序用于剪枝，当数组有序后，若target值小于当前candidates[i]，则i之后的解都不用尝试</span></span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    bt(candidates,<span class="number">0</span>,target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bt</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> index,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剪枝：candidates[i]&lt;=target</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length&amp;&amp;candidates[i]&lt;=target;i++)&#123;</span><br><span class="line">        <span class="comment">//由于元素可重复，则递归时，下一个选择的元素仍然可为当前元素，所有index不用+1</span></span><br><span class="line">        list.add(candidates[i]);</span><br><span class="line">        bt(candidates, i, target - candidates[i], list);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="组合总和II-—-元素重复不可重复选"><a href="#组合总和II-—-元素重复不可重复选" class="headerlink" title="组合总和II — 元素重复不可重复选"></a>组合总和II — 元素重复不可重复选</h3><ul>
<li><p>题目描述</p>
<blockquote>
<p>给定一个数组 candidates(元素存在重复) 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p>
<p>candidates 中的每个数字在每个组合中只能使用一次。</p>
<p>说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。</p>
<p>示例 1: 输入: candidates = [10,1,2,7,6,1,5], target = 8, 所求解集为: [ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6] ]</p>
<p>示例 2: 输入: candidates = [2,5,2,1,2], target = 5, 所求解集为: [  [1,2,2],  [5] ]</p>
</blockquote>
</li>
<li><p>剪枝分析</p>
<blockquote>
<p>本题目数组元素存在重复，但是最后的结果不能存在重复的组合。即如果某个元素存在多个，在相同位置不能取该元素多次。</p>
<p>方法：先对数组元素排序，则相同元素都排在一起。假设当前回溯进入时传入的i的起始下标为index</p>
<p>则可以通过判断 i != index &amp;&amp; candidates[i] == candidates[i-1] 来得知是否在相同位置取了相同元素</p>
<ol>
<li><p><strong>i  != index</strong>  若i==index，则说明当前位置是第一次取值，则不可能当前位置取了相同的数</p>
</li>
<li><p><strong>candidates[i] == candidates[i-1]</strong> 前面的不等条件符合时，说明不是第一次取值，然后通过candidates[i] == candidates[i-1] 可知当前值等于前一个值，则会出现一个位置取了相同元素</p>
</li>
</ol>
<p>通过以上方法则可成功剪枝</p>
</blockquote>
</li>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存所有可行解</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">//递归过程中保存当前解，主要用于回溯</span></span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum2</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    Arrays.sort(candidates);</span><br><span class="line">    backtracking(candidates,<span class="number">0</span>,target);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] candidates,<span class="type">int</span> index,<span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剪枝：candidates[i]&lt;=target</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=index;i&lt;candidates.length&amp;&amp;candidates[i]&lt;=target;i++)&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        关键剪枝：本题数组元素重复但是最后结果不能重复，即相同位置不能取相同元素，但不同位置可以取相同元素</span></span><br><span class="line"><span class="comment">        剪枝方法：i!=index &amp;&amp; candidates[i] == candidates[i-1]</span></span><br><span class="line"><span class="comment">        分析:candidates[i] == candidates[i-1]表示当前元素与前一个元素相同，此处无异议</span></span><br><span class="line"><span class="comment">            1.当i=index &amp;&amp; candidates[i] == candidates[i-1]时，</span></span><br><span class="line"><span class="comment">            一定是不同位置取到了相同元素，因为此时是当前递归函数第一次进入for循环，当前位置是第一次取值，所以不是同一位置重复</span></span><br><span class="line"><span class="comment">            2.i !=index &amp;&amp; candidates[i] == candidates[i-1],时，此事for循环进行了多次，当前位置尝试过多个值，所以是相同位置重复，所以需要剪枝</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>(i!=index &amp;&amp; candidates[i] == candidates[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        list.add(candidates[i]);</span><br><span class="line">        target -= candidates[i];</span><br><span class="line">        backtracking(candidates,i+<span class="number">1</span>,target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        target += candidates[i];</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-切割问题"><a href="#3-切割问题" class="headerlink" title="3.==切割问题=="></a>3.==切割问题==</h3><blockquote>
<p>问题类型：切割问题。<br>切割问题类似组合问题。<br>例如对于字符串abcdef：<br>组合问题：选取一个a之后，在bcdef中再去选取第二个，选取b之后在cdef中在选组第三个…..。<br>切割问题：切割一个a之后，在bcdef中再去切割第二段，切割b之后在cdef中在切割第三段…..。<br>对于字符串abcdefg，第一段切割可选的类型有：a,ab,abc,abcd…等等</p>
</blockquote>
<h3 id="分割回文串"><a href="#分割回文串" class="headerlink" title="分割回文串"></a>分割回文串</h3><ul>
<li>题目</li>
</ul>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240308152723915.png" alt="image-20240308152723915" style="zoom:80%;" align="left">

<ul>
<li><p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">partition</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() == <span class="number">1</span>) &#123;</span><br><span class="line">        list.add(s);</span><br><span class="line">        res.add(list);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    backtracking(s,<span class="number">0</span>,len);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断回文：依次比较首部元素和尾部元素即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> str.length()-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(begin &lt; end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(begin) != str.charAt(end))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        begin++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s,<span class="type">int</span> beginIndex,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//当前需要选择字符串的起始下标到达给定字符串末尾时，则得到一组解</span></span><br><span class="line">    <span class="keyword">if</span>(beginIndex == len)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=beginIndex;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">//截取字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(beginIndex,i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//若当前字符串为回文字符串，则进行下一段字符串的选取</span></span><br><span class="line">        <span class="keyword">if</span>(check(str))&#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">            backtracking(s,i+<span class="number">1</span>,len);</span><br><span class="line">            list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="复原IP地址"><a href="#复原IP地址" class="headerlink" title="复原IP地址"></a>复原IP地址</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240308152835628.png" alt="image-20240308152835628" style="zoom: 67%;" align="left">

<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length() &gt; <span class="number">12</span>) <span class="keyword">return</span> res;</span><br><span class="line">    backtracking(s,<span class="number">0</span>,s.length());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断是否符合ip地址的格式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str.length() == <span class="number">2</span> &amp;&amp; str.charAt(<span class="number">0</span>) != <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str.length() == <span class="number">3</span> &amp;&amp; str.charAt(<span class="number">0</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp; Integer.valueOf(str) &lt;= <span class="number">255</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(String s, <span class="type">int</span> beginIndex,<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="comment">//给定字符串刚好用完且list中只包含4个数字串时才符合最后结果</span></span><br><span class="line">    <span class="keyword">if</span>(beginIndex == len &amp;&amp; list.size() == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="comment">//使用StringBuilder比String构建结果字符串快</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;list.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != list.size() -<span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(list.get(i));</span><br><span class="line">                sb.append(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sb.append(list.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">String</span>(sb));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//剪枝：ip地址只包含四个数字字符串</span></span><br><span class="line">    <span class="keyword">if</span>(list.size() &gt;= <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//剪枝：新字符串的字符个数不大于3个</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=beginIndex;i&lt;beginIndex+<span class="number">3</span> &amp;&amp; i&lt;len;i++)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> s.substring(beginIndex,i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(check(str))&#123;</span><br><span class="line">            list.add(str);</span><br><span class="line">            backtracking(s,i+<span class="number">1</span>,len);</span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="4-子集问题-—-迭代函数中添加一个元素时就可以当做一组解"><a href="#4-子集问题-—-迭代函数中添加一个元素时就可以当做一组解" class="headerlink" title="4.==子集问题== — 迭代函数中添加一个元素时就可以当做一组解"></a>4.==子集问题== — 迭代函数中添加一个元素时就可以当做一组解</h3><blockquote>
<p>如果把 子集问题、组合问题、分割问题都抽象为一棵树的话，那么组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！<br>即遍历递归树的时候，把所有节点都记录下来，就是要求的子集集合。<br>注意：求取子集问题，不需要任何剪枝！因为子集就是要遍历整棵树。</p>
</blockquote>
<h3 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240308153255753.png" alt="image-20240308153255753" style="zoom:80%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    bt(<span class="number">0</span>, nums, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bt</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[] nums, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index == nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; nums.length; i++)&#123;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        <span class="comment">//将所有子集加入结果list</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        </span><br><span class="line">        bt(i + <span class="number">1</span>, nums, list);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="子集II"><a href="#子集II" class="headerlink" title="子集II"></a>子集II</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240309112549188.png" alt="image-20240309112549188" style="zoom:80%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    backtracking(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> beginIndex)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(beginIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=beginIndex;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//树层去重，同一位置相同元素不能取两次</span></span><br><span class="line">        <span class="keyword">if</span>(i != beginIndex &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        <span class="comment">//将所有子集加入结果list</span></span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line"></span><br><span class="line">        backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="非递减子序列-—-数组不可排序，树层去重在迭代函数内部使用used数组"><a href="#非递减子序列-—-数组不可排序，树层去重在迭代函数内部使用used数组" class="headerlink" title="非递减子序列 — 数组不可排序，树层去重在迭代函数内部使用used数组"></a>非递减子序列 — 数组不可排序，树层去重在迭代函数内部使用used数组</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240309121650574.png" alt="image-20240309121650574" style="zoom:80%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：题目需要求递增子序列，则不能对原数组进行排序；此外结果list中不能包含相同解，则需要对树层去重。</span></span><br><span class="line"><span class="comment">    前面几道题目中对树层去重都是先对数组排序，再根据比较先后元素来进行去重，此问题不能使用该方法</span></span><br><span class="line"><span class="comment">去重方法：由于不能排序，且数组元素大小在[-100,100]，则可在每一层创建一个大小为201的数组</span></span><br><span class="line"><span class="comment">    例如；flag[100+100] = flag[200] = 0,，即数值100在该层未使用过，若=1则表明已经使用，需要去重</span></span><br><span class="line"><span class="comment">        即使用flag[num[i]+100]来标记当前nums[i]是否被使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">static</span> List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    backtracking(nums,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> beginIndex)</span>&#123;</span><br><span class="line">    <span class="comment">//元素已经使用完，即已经遍历到根节点，返回</span></span><br><span class="line">    <span class="keyword">if</span>(beginIndex &gt;= nums.length) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记数组</span></span><br><span class="line">    <span class="type">int</span>[] flag = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">201</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=beginIndex;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="comment">//(list.size() !=0 &amp;&amp; nums[i] &lt; list.get(list.size()-1) 表明当前元素与list中的元素不是递增关系</span></span><br><span class="line">        <span class="comment">//flag[nums[i]+100] == 1 表明当前nums[i] 在该层已经使用</span></span><br><span class="line">        <span class="keyword">if</span>((!list.isEmpty() &amp;&amp; nums[i] &lt; list.get(list.size()-<span class="number">1</span>)) || flag[nums[i]+<span class="number">100</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        flag[nums[i]+<span class="number">100</span>] = <span class="number">1</span>;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(list.size() &gt; <span class="number">1</span>)res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        backtracking(nums,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//flag[nums[i]] = 0;</span></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-排列问题-—-N个数按一定规则全排列，有多少种排列方式"><a href="#5-排列问题-—-N个数按一定规则全排列，有多少种排列方式" class="headerlink" title="5.==排列问题== — N个数按一定规则全排列，有多少种排列方式"></a>5.==排列问题== — N个数按一定规则全排列，有多少种排列方式</h3><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240309123653332.png" alt="image-20240309123653332" style="zoom:67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//树枝去重：使用flag数组标记树枝中哪些元素已经被使用</span></span><br><span class="line">    <span class="type">int</span>[] flag = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">21</span>];</span><br><span class="line">    backtracking(nums,flag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] flag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag[nums[i]+<span class="number">10</span>] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line">        flag[nums[i]+<span class="number">10</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        backtracking(nums,flag);</span><br><span class="line"></span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        flag[nums[i]+<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="全排列II-—-数组元素重复的排列问题，树枝树层都要去重"><a href="#全排列II-—-数组元素重复的排列问题，树枝树层都要去重" class="headerlink" title="全排列II — 数组元素重复的排列问题，树枝树层都要去重"></a>全排列II — 数组元素重复的排列问题，树枝树层都要去重</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240309123329047.png" alt="image-20240309123329047" style="zoom: 67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">难点：本题需要同时进行树枝去重和树层去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="comment">//创建flag数组用于标记元素的使用情况</span></span><br><span class="line">    <span class="type">int</span>[] flag = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    <span class="comment">//排序是排列问题去重的关键</span></span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">    backtracking(nums,flag);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span>[] flag)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == nums.length)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        <span class="comment">//树枝去重：flag[i] == 1 表明 nums[i] 在当前树枝已经使用过</span></span><br><span class="line">        <span class="keyword">if</span>(flag[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        树层去重：nums[i] == nums[i-1]说明当前元素与前一个元素相同</span></span><br><span class="line"><span class="comment">        由于回溯算法相当于树的深度优先遍历，则nums[i-1]在取nums[i]之前已经被使用过，此时若nums[i] == nums[i-1] &amp;&amp; flag[i-1]==0</span></span><br><span class="line"><span class="comment">        则说明存在树层重复，即同一位置取了相同的值，则需要去重</span></span><br><span class="line"><span class="comment">        关键点：flag[i-1]==0 表明nums[i-1]之前已经经历过一次回溯，即先被选择(flag[i] = 1),后面因为回溯又被撤销(flag[i] = 0)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span>((i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; flag[i-<span class="number">1</span>]==<span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        flag[i] = <span class="number">1</span>;</span><br><span class="line">        list.add(nums[i]);</span><br><span class="line"></span><br><span class="line">        backtracking(nums,flag);</span><br><span class="line"></span><br><span class="line">        flag[i] = <span class="number">0</span>;</span><br><span class="line">        list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="重新安排行程"><a href="#重新安排行程" class="headerlink" title="重新安排行程"></a>重新安排行程</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20240309150631270.png" alt="image-20240309150631270"></p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：基本回溯思路就是求组合问题，难点在于如何求得最近路径(字母小的路径优先选择)</span></span><br><span class="line"><span class="comment">实现最小路径的方法：关键在于对每个起始站点的所有终点站进行排序，然后回溯时优先选择字母小的终点站，感觉有点类似贪心</span></span><br><span class="line"><span class="comment">选择的数据结构：</span></span><br><span class="line"><span class="comment">    1.使用一个HashMap，其key存放起始车站，其value存放key对应的所有终点站</span></span><br><span class="line"><span class="comment">    2.1中的value使用TreeMap数据结构，该数据结构可以自动排序，从而达到字母小的终点站优先选择</span></span><br><span class="line"><span class="comment">        TreeMap中key存放终点站，value存放可以达到该站点的次数(即相同车牌可能有多张，则该终点站可以去多次)</span></span><br><span class="line"><span class="comment">此外：对于只需要求出一组解的回溯算法，让回溯函数有返回值即可，即若已经求出解，则无需再进行回溯</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Map&lt;String,Map&lt;String,Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findItinerary</span><span class="params">(List&lt;List&lt;String&gt;&gt; tickets)</span> &#123;</span><br><span class="line">    <span class="comment">//处理tickets</span></span><br><span class="line">    <span class="keyword">for</span>(List&lt;String&gt; ticket:tickets)&#123;</span><br><span class="line">        Map&lt;String,Integer&gt; tempMap;</span><br><span class="line">        <span class="comment">//map不包含key为ticket.get(0)的键，则新增</span></span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(ticket.get(<span class="number">0</span>)))&#123;</span><br><span class="line">            tempMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">            tempMap.put(ticket.get(<span class="number">1</span>),<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//map包含key为ticket.get(0)的键，则更新</span></span><br><span class="line">            tempMap = map.get(ticket.get(<span class="number">0</span>));</span><br><span class="line">            tempMap.put(ticket.get(<span class="number">1</span>),tempMap.getOrDefault(ticket.get(<span class="number">1</span>),<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(ticket.get(<span class="number">0</span>),tempMap);</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">&quot;JFK&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tickets.size()+<span class="number">1</span>;</span><br><span class="line">    backtracking(<span class="string">&quot;JFK&quot;</span>,len,list);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">backtracking</span><span class="params">(String startLoc,<span class="type">int</span> len,List&lt;String&gt; list)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(list.size() == len)&#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//map中有可能不存在该key，防止空指针异常</span></span><br><span class="line">    <span class="keyword">if</span>(map.containsKey(startLoc))&#123;</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String,Integer&gt; tempMap:map.get(startLoc).entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> tempMap.getValue();</span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                list.add(tempMap.getKey());</span><br><span class="line">                tempMap.setValue(count-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(backtracking(tempMap.getKey(),len,list)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                list.remove(list.size()-<span class="number">1</span>);</span><br><span class="line">                tempMap.setValue(count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-贪心算法专题总结"><a href="#6-贪心算法专题总结" class="headerlink" title="6.贪心算法专题总结"></a>6.贪心算法专题总结</h2><h3 id="分发饼干"><a href="#分发饼干" class="headerlink" title="分发饼干"></a>分发饼干</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230905105220673.png" alt="image-20230905105220673" style="zoom: 80%;" align="left">

<p>思路</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">思路：对饼干数组s和孩子数组g进行排序</span><br><span class="line">使用贪心算法尽可能使更多的孩子得到满足</span><br></pre></td></tr></table></figure>

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findContentChildren</span><span class="params">(<span class="type">int</span>[] g, <span class="type">int</span>[] s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g);</span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="type">int</span> <span class="variable">gIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//饼干尺寸和孩子胃口都从小到大排序，尽可能满足所有孩子</span></span><br><span class="line">        <span class="keyword">while</span>(gIndex &lt; g.length &amp;&amp; sIndex &lt; s.length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[sIndex] &gt;= g[gIndex])&#123;</span><br><span class="line">                sum++;</span><br><span class="line">                sIndex++;</span><br><span class="line">                gIndex++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                sIndex++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a>摆动序列</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230905105637812.png" alt="image-20230905105637812" style="zoom:80%;" align="left">



<h4 id="贪心解法"><a href="#贪心解法" class="headerlink" title="贪心解法"></a>贪心解法</h4><p>思路</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/20201124174327597.png" alt="376.摆动序列" style="zoom: 33%;" align="left">

<p><strong>局部最优：删除单调坡度上的节点（不包括单调坡度两端的节点），那么这个坡度就可以有两个局部峰值</strong>。</p>
<p><strong>整体最优：整个序列有最多的局部峰值，从而达到最长摆动序列</strong>。</p>
<p>局部最优推出全局最优，并举不出反例，那么试试贪心！</p>
<p><strong>实际操作上，其实连删除的操作都不用做，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）</strong></p>
<p><strong>这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点</strong></p>
<p>在计算是否有峰值的时候，大家知道遍历的下标 i ，计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]），如果<code>prediff &lt; 0 &amp;&amp; curdiff &gt; 0</code> 或者 <code>prediff &gt; 0 &amp;&amp; curdiff &lt; 0</code> 此时就有波动就需要统计。</p>
<p>这是我们思考本题的一个大题思路，但本题要考虑三种情况：</p>
<ol>
<li>情况一：上下坡中有平坡</li>
<li>情况二：数组首尾两端</li>
<li>情况三：单调坡中有平坡</li>
</ol>
<p><strong>情况一：上下坡中有平坡</strong></p>
<p>例如 [1,2,2,2,1]这样的数组，如图：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/20230106170449.png" alt="img" style="zoom:33%;">

<p>它的摇摆序列长度是多少呢？ <strong>其实是长度是 3</strong>，也就是我们在删除的时候 要不删除左面的三个 2，要不就删除右边的三个 2。</p>
<p>如图，可以统一规则，删除左边的三个 2：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/20230106172613.png" alt="img" style="zoom:33%;">

<p>在图中，当 i 指向第一个 2 的时候，<code>prediff &gt; 0 &amp;&amp; curdiff = 0</code> ，当 i 指向最后一个 2 的时候 <code>prediff = 0 &amp;&amp; curdiff &lt; 0</code>。</p>
<p>如果我们采用，删左面三个 2 的规则，那么 当 <code>prediff = 0 &amp;&amp; curdiff &lt; 0</code> 也要记录一个峰值，因为他是把之前相同的元素都删掉留下的峰值。</p>
<p>所以我们记录峰值的条件应该是： <code>(preDiff &lt;= 0 &amp;&amp; curDiff &gt; 0) || (preDiff &gt;= 0 &amp;&amp; curDiff &lt; 0)</code>，为什么这里允许 prediff == 0 ，就是为了 上面我说的这种情况。</p>
<p><strong>情况二：数组首尾两端</strong></p>
<p>所以本题统计峰值的时候，数组最左面和最右面如何统计呢？</p>
<p>题目中说了，如果只有两个不同的元素，那摆动序列也是 2。</p>
<p>例如序列[2,5]，如果靠统计差值来计算峰值个数就需要考虑数组最左面和最右面的特殊情况。</p>
<p>因为我们在计算 prediff（nums[i] - nums[i-1]） 和 curdiff（nums[i+1] - nums[i]）的时候，至少需要三个数字才能计算，而数组只有两个数字。</p>
<p>这里我们可以写死，就是 如果只有两个元素，且元素不同，那么结果为 2。</p>
<p>不写死的话，如何和我们的判断规则结合在一起呢？</p>
<p>可以假设，数组最前面还有一个数字，那这个数字应该是什么呢？</p>
<p>之前我们在 讨论 情况一：相同数字连续 的时候， prediff = 0 ，curdiff &lt; 0 或者 &gt;0 也记为波谷。</p>
<p>那么为了规则统一，针对序列[2,5]，可以假设为[2,2,5]，这样它就有坡度了即 preDiff = 0，如图：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/20201124174357612.png" alt="376.摆动序列1" style="zoom:67%;" align="left">

<p>针对以上情形，result 初始为 1（默认最右面有一个峰值），此时 curDiff &gt; 0 &amp;&amp; preDiff &lt;= 0，那么 result++（计算了左面的峰值），最后得到的 result 就是 2（峰值个数为 2 即摆动序列长度为 2）</p>
<p>经过以上分析后，我们可以写出如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">            preDiff = curDiff;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>情况三：单调坡度有平坡</strong></p>
<p>在版本一中，我们忽略了一种情况，即 如果在一个单调坡度上有平坡，例如[1,2,2,2,3,4]，如图：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/20230108171505.png" alt="img" style="zoom:33%;" align="left">

<p>图中，我们可以看出，版本一的代码在三个地方记录峰值，但其实结果因为是 2，因为 单调中的平坡 不能算峰值（即摆动）。</p>
<p>之所以版本一会出问题，是因为我们实时更新了 prediff。</p>
<p>那么我们应该什么时候更新 prediff 呢？</p>
<p>我们只需要在 这个坡度 摆动变化的时候，更新 prediff 就行，这样 prediff 在 单调区间有平坡的时候 就不会发生变化，造成我们的误判。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preDiff</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 前一对差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 记录峰值个数，序列默认序列最右边有一个峰值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            curDiff = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="comment">// 出现峰值</span></span><br><span class="line">            <span class="keyword">if</span> ((preDiff &lt;= <span class="number">0</span> &amp;&amp; curDiff &gt; <span class="number">0</span>) || (preDiff &gt;= <span class="number">0</span> &amp;&amp; curDiff &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">                result++;</span><br><span class="line">                preDiff = curDiff; <span class="comment">// 注意这里，只在摆动变化的时候更新prediff</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="状态dp解法"><a href="#状态dp解法" class="headerlink" title="状态dp解法"></a>状态dp解法</h4><p>很容易可以发现，对于我们当前考虑的这个数，要么是作为山峰（即 nums[i] &gt; nums[i-1]），要么是作为山谷（即 nums[i] &lt; nums[i - 1]）。</p>
<ul>
<li>设 dp 状态<code>dp[i][0]</code>，表示考虑前 i 个数，第 i 个数作为山峰的摆动子序列的最长长度</li>
<li>设 dp 状态<code>dp[i][1]</code>，表示考虑前 i 个数，第 i 个数作为山谷的摆动子序列的最长长度</li>
</ul>
<p>则转移方程为：</p>
<ul>
<li><code>dp[i][0] = max(dp[i][0], dp[j][1] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &lt; nums[i]</code>，表示将 nums[i]接到前面某个山谷后面，作为山峰。</li>
<li><code>dp[i][1] = max(dp[i][1], dp[j][0] + 1)</code>，其中<code>0 &lt; j &lt; i</code>且<code>nums[j] &gt; nums[i]</code>，表示将 nums[i]接到前面某个山峰后面，作为山谷。</li>
</ul>
<p>初始状态：</p>
<p>由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：<code>dp[0][0] = dp[0][1] = 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">wiggleMaxLength</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 初始化：每个元素可以以自己为波峰或波谷，则默认计入1</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 遍历前面元素</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j]) dp[i][<span class="number">1</span>] = Math.max(dp[i][<span class="number">1</span>], dp[j][<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[j]) dp[i][<span class="number">0</span>] = Math.max(dp[i][<span class="number">0</span>], dp[j][<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(dp[n - <span class="number">1</span>][<span class="number">0</span>], dp[n - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>











































<h2 id="7-栈与队列专题总结"><a href="#7-栈与队列专题总结" class="headerlink" title="7.栈与队列专题总结"></a>7.栈与队列专题总结</h2><blockquote>
<p>核心原则：<strong>及时移除无用数据，保证队列/栈的有序性</strong>。</p>
</blockquote>
<h3 id="方法论-1"><a href="#方法论-1" class="headerlink" title="方法论"></a>方法论</h3><h4 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h4><ul>
<li><p>为什么使用单调栈</p>
<p><strong>对于一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了</strong>，时间复杂度为 <code>O(n)</code></p>
</li>
<li><p>单调栈的原理</p>
<p>本质是空间换时间，因为在遍历的过程中需要<strong>用一个栈来记录右边第一个比当前元素高/低的元素</strong>，优点是<strong>只需要遍历一次</strong>。</p>
</li>
<li><p>单调栈存放的元素是什么</p>
<p>栈内存放元素的可以是数据本身也可以是数组下标，当需要计算的结果与值本身相关时则保存值，而与下标相关相关时则保存下标，例如求下标差(每日温度)等等</p>
</li>
<li><p>单调栈内的元素的顺序</p>
<p>规定顺序为 <strong>栈头到栈底的顺序</strong>，例如对于单调递减栈，即stack.peek()为栈内最小元素。此时若达到一个元素i，若元素i的值大于栈顶元素，则栈顶元素右边第一个比其大的值就是i，记录结果后，将栈顶元素弹出，若此时栈内没有比i小的元素，则将i入栈，保持递增。</p>
</li>
<li><p>使用单调栈(以单调递减栈为例)主要有三种判断条件</p>
<ul>
<li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况—T[i]入栈</li>
<li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况—T[i]入栈</li>
<li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况—T[i]为栈顶元素要找到结果，记录后弹出所有比T[i]小的元素，最后T[i]入栈</li>
</ul>
</li>
</ul>
<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>优先队列：PriorityQueue</p>
<ol>
<li><p>原理：通过完全二叉树（complete binary tree）实现的小顶堆（任意一个非叶子节点的权值，都不大于其左右子节点的权值），即队头为最小元素</p>
</li>
<li><p>作用：保证每次取出的元素都是队列中权值最小的（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。<br> 这里牵涉到了大小关系，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较（Comparator，类似于C++的仿函数）。</p>
</li>
<li><p>常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span>; <span class="comment">//在队尾插入元素，插入失败时抛出false，并调整堆结构</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>; <span class="comment">//获取队头元素并删除，并返回，失败时前者抛出null，再调整堆结构</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">peek</span><span class="params">()</span>；<span class="comment">//返回队头元素（不删除），失败时前者抛出null</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>; <span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>; <span class="comment">//获取队列中元素个数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>; <span class="comment">//清空队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(Object o)</span>; <span class="comment">//判断队列中是否包含指定元素（从队头到队尾遍历）</span></span><br><span class="line"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span>; <span class="comment">//迭代器</span></span><br></pre></td></tr></table></figure></li>
<li><p>应用：topK问题<br>topK问题是指：从海量数据中寻找最大的前k个数据，比如从1亿个数据中，寻找最大的1万个数。<br>使用优先队列，能够很好的解决这个问题。先使用前1万个数构建最小优先队列，以后每取<br>一个数，都与队头元素进行比较，若大于队头元素，就将队头元素删除，并将该元素添加到<br>优先队列中；若小于队头元素，则将该元素丢弃掉。如此往复，直至所有元素都访问完。最<br>后优先队列中的1万个元素就是最大的1万个元素。</p>
</li>
</ol>
<h3 id="单调栈-1"><a href="#单调栈-1" class="headerlink" title="单调栈"></a>单调栈</h3><h4 id="739-每日温度-—-基本单调栈"><a href="#739-每日温度-—-基本单调栈" class="headerlink" title="739.每日温度 — 基本单调栈"></a>739.每日温度 — 基本单调栈</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230802113629853.png" alt="image-20230802113629853" style="zoom:67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关键点:找到当前温度右边第一个比其大的温度</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lens</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[lens];</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;lens; i++)&#123;</span><br><span class="line">        <span class="comment">//由于栈递增，栈顶温度是最小温度，如果今天温度大于栈顶温度，则今天即为大于栈顶那一天温度的右边第一天</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">            <span class="comment">//栈顶元素找到其右边第一个比自己大的数</span></span><br><span class="line">            res[stack.peek()] = i-stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="901-股票价格跨度"><a href="#901-股票价格跨度" class="headerlink" title="901.股票价格跨度"></a>901.股票价格跨度</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230802155451842.png" alt="image-20230802155451842" style="zoom:67%;" align="left">



<p><strong>思路</strong></p>
<p>保存所有出现过的股票价格，利用单调栈找到左边第一个比今天价格高的股票价格</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;Integer&gt; stack;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">// 保存出现的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StockSpanner</span><span class="params">()</span> &#123;</span><br><span class="line">    stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">(<span class="type">int</span> price)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; price &gt;= list.get(stack.peekLast()))&#123;<span class="comment">// 查找栈内第一个大于当前元素的位置</span></span><br><span class="line">        stack.pollLast();</span><br><span class="line">    &#125;</span><br><span class="line">    res = stack.isEmpty() ? index + <span class="number">1</span> : index - stack.peekLast(); </span><br><span class="line">&#125;</span><br><span class="line">list.add(price);</span><br><span class="line">stack.addLast(index);</span><br><span class="line"><span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="1124-表现良好的最长时间段—-单调递减栈求最长"><a href="#1124-表现良好的最长时间段—-单调递减栈求最长" class="headerlink" title="1124.表现良好的最长时间段— ==单调递减栈求最长=="></a>1124.表现良好的最长时间段— ==单调递减栈求最长==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803095240870.png" alt="image-20230803095240870" style="zoom: 80%;" align="left">

<p>思路</p>
<p>前缀和 + 单调栈</p>
<p>「劳累天数大于不劳累天数」等价于「劳累天数减去不劳累天数大于 0」。</p>
<p>那么把劳累的一天视作nums[i] = 1，不劳累的一天视作nums[i] = -1，则问题变为：</p>
<p>计算nums的最长子数组，其元素和大于0.</p>
<p>既然说到子数组的元素和，那么利用前缀和s，将问题变为：</p>
<p>找到两个下标i和j，满足j &lt; i且s[j] &lt; s[i]，最大化i - j的值。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803102940076.png" alt="image-20230803102940076" style="zoom:80%;" align="left">

<blockquote>
<p>注意：通常的单调栈题目是求最近或最远，本题求的是最长，不能单纯的套用模版</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> hours.length, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] s = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//前缀和数组</span></span><br><span class="line">    Deque&lt;Integer&gt; st = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//其中存储数组下标j</span></span><br><span class="line">    st.push(<span class="number">0</span>);<span class="comment">//装入s[0]</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n; ++j)&#123;</span><br><span class="line">        <span class="comment">//构造前缀和数组</span></span><br><span class="line">        s[j] = s[j - <span class="number">1</span>] + (hours[j - <span class="number">1</span>] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//构造单调递减栈(栈底元素最大，栈顶元素最小)</span></span><br><span class="line">        <span class="comment">//为什么要单调递减：假设栈底元素为j，后一个元素装入更大的设为m，遍历数组时发现一个n大于m，则其一定大于j，而j的下标比m小，离n更远，则m不可能为解。只要装入更小的z，后续遍历找到比j小的值，其可能与z一起得到更优解</span></span><br><span class="line">        <span class="keyword">if</span>(s[j] &lt; s[st.peek()]) st.push(j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i&gt;<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!st.isEmpty() &amp;&amp; s[i] &gt; s[st.peek()])&#123;</span><br><span class="line">            ans = Math.max(ans, i - st.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="862-和至少为-k-最短子数组-—-单调递增队列-求最短"><a href="#862-和至少为-k-最短子数组-—-单调递增队列-求最短" class="headerlink" title="862.和至少为 k 最短子数组 — ==单调递增队列==求最短"></a>862.和至少为 k 最短子数组 — ==单调递增队列==求最短</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803112443686.png" alt="image-20230803112443686" style="zoom:67%;" align="left">

<p><strong>思路</strong></p>
<p>前缀和 + 单调队列</p>
<p>求子数组和我们可以马上想到借助前缀和来实现，但是题目要求得到最短子数组则需要借助单调队列来实现</p>
<p>单调队列优化过程：</p>
<p>优化1：<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803112753686.png" alt="image-20230803112753686" style="zoom:67%;"></p>
<p>即每次遍历到一个元素 s[i]，若队头元素满足 s[i] - s[q.peekFirst()] &gt;= k ，则计算一次结果，然后弹出队头元素，因为即使后续再来的元素满足 s[m] - s[q.peekFirst()] &gt;= k (有m &gt; i)，m - q.peekFirst() 也不可能小于 i - q.peekFirst()。此时便弹出没有任何作用的队头元素</p>
<p>优化2：<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803113338948.png" alt="image-20230803113338948" style="zoom:67%;"></p>
<p>优化2可以保证队列单调递增。</p>
<blockquote>
<p>注意：求前缀和时使用int定义会溢出，需要使用long来接收前缀和。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230803114003275.png" alt="image-20230803114003275" style="zoom:80%;" align="left">

<p>-10^5^ * 10^5^=-10^10^ &lt; -2147483648 ≈ -2*10^9^ </p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">long</span>[] preSum = <span class="keyword">new</span> <span class="title class_">long</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//计算前缀和，preSum[i]保存的是[0,i-1]的前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        preSum[i] = preSum[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//单调队列</span></span><br><span class="line">    Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">curS</span> <span class="operator">=</span> preSum[i];</span><br><span class="line">        <span class="comment">//优化1：从队头弹出满足s[i] - s[j] &gt;= k的 s[j],且更新最短长度res</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; curS - preSum[q.peekFirst()] &gt;= k)&#123;</span><br><span class="line">            res = Math.min(res, i - q.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//优化2：从队尾弹出所有小于s[i]的s[j],保证队列单调递增</span></span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty() &amp;&amp; preSum[q.peekLast()] &gt;= curS)</span><br><span class="line">            q.pollLast();</span><br><span class="line"></span><br><span class="line">        q.addLast(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == n+<span class="number">1</span> ? -<span class="number">1</span>:res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="402-移掉K位数字"><a href="#402-移掉K位数字" class="headerlink" title="402.移掉K位数字"></a>402.移掉K位数字</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230805163206554.png" alt="image-20230805163206554" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<p>对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于<code>A = 1axxx，B = 1bxxx</code>，如果 a&gt;b 则 A &gt; B 。<br>基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230805163331576.png" alt="image-20230805163331576" style="zoom:67%;" align="left">

<p>让我们从一个简单的例了开始。给定一个数字序列，例如 425 ，如果要求我们只删除一个数字，那么从左到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始, 2 小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4 (即42，45）开头的。相反，如果移掉 4，留下 2，我们得到的是以 2 开头的组合 (即25)，这明显小于任何留下数字 4 的组合。因此我们应该移掉数字 4。如果不移掉数字 4，则之后无论移掉什么数字，都不会得到最小数。<br>基于上述分析，我们可以得出「删除一个数字」的贪心策略:</p>
<p>给定一个长度为n的数字序列 <code>[D0 D1 D2 ...Dn-1]</code>，从左往右找到第一个位置 i(i&gt;0) 使得 <code>Di&lt;Di-1</code>，并删去 Di-1; 如果不存在，说明整个数字序列单调不降，删去最后一个数字即可,</p>
<p>考虑从左往右增量的构造最后的答案。我们可以<strong>用一个栈维护当前的答案序列</strong>，栈中的元素代表截止到当前位置，删除不超过 k 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。</p>
<p>因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到</p>
<ul>
<li>栈为空</li>
<li>或者新的栈顶元素不大于当前数字</li>
<li>或者我们已经删除了 k 位数字</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(num.length() &lt;= k) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">    <span class="comment">// 虽然使用单调栈保存数据，但是考虑到最后要生成结果字符串，选择双端队列保存数据</span></span><br><span class="line">    Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; num.length(); i++)&#123;</span><br><span class="line">        <span class="comment">// 选择数字生成单调不减的队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> num.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">// 当前字符小于栈顶元素，为了保持栈单调不降，弹出栈顶元素</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; c &lt; deque.peek() &amp;&amp; k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            deque.poll();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若栈内只有一个元素且为0，则其为前导0，直接弹出且不消耗k</span></span><br><span class="line">        <span class="keyword">if</span>(deque.size() == <span class="number">1</span> &amp;&amp; deque.peek() == <span class="number">0</span>) deque.poll();</span><br><span class="line">        deque.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k未消耗完时，说明栈内数字从栈底到栈顶保存递增，我们弹出剩下的k个数字即可</span></span><br><span class="line">    <span class="comment">// 注意此时可能将所有数字都弹出，栈内为空</span></span><br><span class="line">    <span class="keyword">while</span>(k &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        deque.poll();</span><br><span class="line">        k--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty()) sb.append(deque.pollLast());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316.去除重复字母"></a>316.去除重复字母</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230805172000813.png" alt="image-20230805172000813" style="zoom:80%;" align="left">



<p>思路</p>
<p>本题主要有两个要求</p>
<ol>
<li><p>去除重复元素，使每个元素只出现一次</p>
</li>
<li><p>返回结果的字典序最小</p>
</li>
</ol>
<p>首先考虑要求二，使用单调栈维护栈底到栈顶的字符递增(或单调不减)即可。</p>
<p>对于要求一：</p>
<ul>
<li>考虑字符<code>s[i]</code>时，如果已经存在于栈中，则不能加入字符<code>s[i]</code>。为此，需要记录每个字符是否出现在栈中。</li>
<li>在弹出栈顶字符时，如果字符串在后面的位置上不存在该字符，则不能弹出栈顶字符。为此，需要记录每个字符的剩余数量，当这个值为0时，就不能弹出栈顶元素。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录字符是否存在于栈中</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">// 记录字符串中每个字符的个数</span></span><br><span class="line">        <span class="type">int</span>[] num = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            num[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Character&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="comment">// 当前字符不存在于栈中才考虑加入</span></span><br><span class="line">            <span class="keyword">if</span>(!visited[ch - <span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                <span class="comment">// 当前字符小于栈顶元素，且后面还存在相同的栈顶元素时，可将栈顶元素弹出。</span></span><br><span class="line">                <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; num[deque.peekLast() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; deque.peekLast() &gt;= ch)&#123;</span><br><span class="line"></span><br><span class="line">                    visited[deque.peekLast() - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                    deque.pollLast();</span><br><span class="line">                &#125;</span><br><span class="line">                deque.addLast(ch);</span><br><span class="line">                visited[ch - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 字符遍历完后数量需要-1</span></span><br><span class="line">            num[ch - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">            sb.append(deque.pollFirst());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42.接雨水"></a>42.接雨水</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230805173059627.png" alt="image-20230805173059627" style="zoom:67%;" align="left">



<p><strong>思路 — 单调栈</strong></p>
<p>我们使用栈保存每堵墙(保存对应的数组下标，因为要计算宽度)。</p>
<p>当遍历墙的高度的时候，如果当前高度小于栈顶的墙高度，说明这里会有积水，我们将墙的高度的下标入栈。</p>
<p>如果当前高度大于栈顶的墙的高度，说明之前的积水到这里停下，我们可以计算下有多少积水了。计算完，就把当前的墙继续入栈，作为新的积水的墙。</p>
<p>总体原则就是：</p>
<p>1.当前遍历的墙高度小于等于栈顶墙高度，则直接入栈，继续往后遍历</p>
<p>2.如果当前遍历的墙高度高于栈顶墙高度，则可以计算一次积水，我们将栈顶弹出并将其高度记为h，此时其左边的栈内元素称为新栈顶，我们取新栈顶墙高度与当前遍历墙高度中的较小值min，min - h即为当前积水的高度，我们还需要拿到积水的宽度，即当前遍历墙下标记为current，新栈顶下标记为 left，则宽度为 distance =  current - left - 1。则新增积水为 distance * (min - h)。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">// 保存数组下标</span></span><br><span class="line">    <span class="comment">// 当前遍历墙下标</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(current &lt; n)&#123;</span><br><span class="line">        <span class="comment">// 当前遍历墙高度高于栈顶高度，则可能有积水</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; height[current] &gt; height[stack.peek()])&#123;</span><br><span class="line">            <span class="comment">// 弹出栈顶元素，拿到其高度用于计算积水量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> height[stack.pop()];</span><br><span class="line">            <span class="comment">// 如果栈此时为空，则无法产生积水，进入下一轮循环</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) <span class="keyword">continue</span>;</span><br><span class="line">	    <span class="comment">// 计算积水的宽度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">distance</span> <span class="operator">=</span> current - stack.peek() - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 取新栈顶与当前遍历值中的较小值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(height[current], height[stack.peek()]);</span><br><span class="line">            <span class="comment">// 计算积水量</span></span><br><span class="line">            res += distance * (min - h);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(current);</span><br><span class="line">        current++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="239-滑动窗口最大值-—-单调队列"><a href="#239-滑动窗口最大值-—-单调队列" class="headerlink" title="239.滑动窗口最大值 — 单调队列"></a>239.滑动窗口最大值 — 单调队列</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230807105742521.png" alt="image-20230807105742521" style="zoom: 80%;" align="left">



<p><strong>思路 — 单调队列</strong></p>
<p>遍历数组，将 数 存放在双向队列中，并用 L,R 来标记窗口的左边界和右边界。队列中保存的并不是真的 数，而是该数值对应的数组下标位置，并且数组中的数要从大到小排序。如果当前遍历的数比队尾的值大，则需要弹出队尾值，直到队列重新满足从大到小的要求。刚开始遍历时，L 和 R 都为 0，有一个形成窗口的过程，此过程没有最大值，L 不动，R 向右移。当窗口大小形成时，L 和 R 一起向右移，每次移动时，判断队首的值的数组下标是否在 [L,R] 中，如果不在则需要弹出队首的值，当前窗口的最大值即为队首的数。</p>
<p>示例</p>
<p>输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3<br>输出: [3,3,5,5,6,7]</p>
<p>解释过程中队列中都是具体的值，方便理解，具体见代码。<br>初始状态：L=R=0,队列:{}<br>i=0,nums[0]=1。队列为空,直接加入。队列：{1}<br>i=1,nums[1]=3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：{1(元素3的下标，为了便于观察，后面示例直接使用元素值来代替)}<br>i=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：{3,-1}。此时窗口已经形成，L=0,R=2，result=[3]<br>i=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：{3,-1,-3}。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]<br>i=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：{5}。此时L=2,R=4，有效。result=[3,3,5]<br>i=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：{5,3}。此时L=3,R=5，有效。result=[3,3,5,5]<br>i=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：{6}。此时L=4,R=6，有效。result=[3,3,5,5,6]<br>i=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：{7}。此时L=5,R=7，有效。result=[3,3,5,5,6,7]</p>
<blockquote>
<p>tips</p>
<ul>
<li>单调队列也可以存值，题解中存的是下标。</li>
<li>如果存值的话，每次只有新元素 <code>大于</code> 队列尾部的元素时，才去移除队列尾部的元素</li>
<li>窗口左侧移出去的元素如果等于队列头部的元素，则<code>removeFirst</code>。</li>
</ul>
<p>举个例子： <code>&quot;543321&quot; ，k=3</code></p>
<ul>
<li>队列存<code>值</code>的情况下，如果不将两个3都加入，当第一个3被移出时，会导致321的最大值变为2，因为3已经被移出了，因此存值的话，需要新的元素大于队列尾部元素再去移除队列尾部的元素。</li>
<li>队列存<code>下标</code>的情况下，就可以只存一个3（存第二个），因为通过下标就能判断出移出的是第一个3还是第二个3。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列存下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">// 双向队列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 滑动窗口最边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 结果数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 为了保持双向队列单调递减，当当前元素大于队尾元素时，弹出队尾元素</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty() &amp;&amp; nums[i] &gt; nums[queue.peekLast()])&#123;</span><br><span class="line">                queue.pollLast();</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;<span class="comment">// 窗口内的值已经到达上限，取最大值的同时还需要缩减窗口</span></span><br><span class="line">                <span class="comment">// 取当前窗口内的最大值</span></span><br><span class="line">                res[index++] = nums[queue.peekFirst()];</span><br><span class="line">                <span class="comment">// 如果队头的元素下标在不在窗口范围内，需要弹出</span></span><br><span class="line">                <span class="keyword">if</span>(queue.peekFirst() == left) queue.pollFirst();</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列存值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n - k + <span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[i] &gt; queue.peekLast())&#123;</span><br><span class="line">            queue.pollLast();</span><br><span class="line">        &#125;</span><br><span class="line">        queue.addLast(nums[i]);</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)&#123;</span><br><span class="line">            res[index++] = queue.peekFirst();</span><br><span class="line">            <span class="keyword">if</span>(nums[left] == queue.peekFirst()) queue.pollFirst();</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="优先队列-1"><a href="#优先队列-1" class="headerlink" title="优先队列"></a>优先队列</h3><h4 id="347-前-k-个高频元素"><a href="#347-前-k-个高频元素" class="headerlink" title="347.前 k 个高频元素"></a>347.前 k 个高频元素</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230807113747063.png" alt="image-20230807113747063" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<p>使用哈希记录每个值以及值出现的频次，然后使用大根堆拿到前 k 个频次最高的值</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">//结果数组</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="comment">//key保存数组元素，value保存该元素在数组中出现频率</span></span><br><span class="line">    HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">        map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Map.Entry&lt;Integer,Integer&gt;&gt; entris = map.entrySet();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据map的value值，构建一个具有k个元素的大顶堆(父节点&gt;=左右子节点),比较器中(o1-o2:小顶堆，o2-o1:大顶堆)</span></span><br><span class="line">    <span class="comment">//升序：(o1,o2) -&gt; (o1 - o2) 降序：(o1,o2) -&gt; (o2 - o1)</span></span><br><span class="line">    PriorityQueue&lt;Map.Entry&lt;Integer,Integer&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(k,(o1,o2) -&gt; o2.getValue() - o1.getValue());</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : entris)&#123;</span><br><span class="line">        queue.offer(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//优先队列的头节点即为当前所有元素中出现频次最大的元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)&#123;</span><br><span class="line">        res[i] = queue.poll().getKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈的括号应用"><a href="#栈的括号应用" class="headerlink" title="栈的括号应用"></a>栈的括号应用</h3><h4 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32.最长有效括号"></a>32.最长有效括号</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230807114053719.png" alt="image-20230807114053719" style="zoom:80%;" align="left">

<p>思路</p>
<p>使用栈模拟括号匹配，同时使用Mark数组记录配对成功的括号，成功配对的置为0，无法配对的置为1，最后计算Mark数组中最长的连续0长度即可</p>
<ul>
<li>例如: “()(()”的mark为[0, 0, 1, 0, 0]</li>
<li>再例如: “)()((())”的mark为[1, 0, 0, 1, 0, 0, 0, 0]</li>
<li>经过这样的处理后, 此题就变成了寻找最长的连续的0的长度</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] mark = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 左括号入栈</span></span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;(&#x27;</span>) stack.push(i);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 遇到右括号但是栈中没有左括号，则当前括号无法匹配，Mark数组中对应位置置为1</span></span><br><span class="line">            <span class="keyword">if</span>(stack.isEmpty()) mark[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 栈中有左括号，直接弹出进行匹配，同时Mark数组中对应两个位置置为0(数组默认值即为0)</span></span><br><span class="line">            <span class="keyword">else</span> stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 处理栈中剩下的括号，全部为无法匹配的括号，Mark数组中对应位置全部置为1</span></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        mark[stack.peek()] = <span class="number">1</span>;</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最长连续0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mark[i] == <span class="number">1</span>)&#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">        <span class="keyword">if</span>(len &gt; res) res = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="8-图论专题总结"><a href="#8-图论专题总结" class="headerlink" title="8.图论专题总结"></a>8.图论专题总结</h2><h3 id="图理论"><a href="#图理论" class="headerlink" title="图理论"></a>图理论</h3><p>「图 Graph」是一种非线性数据结构，由「顶点 Vertex」和「边 Edge」组成。我们可以将图 G 抽象地表示为一组顶点 V 和一组边 E 的集合。</p>
<p>如果我们把「顶点」看作节点，把「边」看作连接各个节点的指针，则可将「图」看作是一种从「链表」拓展而来的数据结构。<strong>相较于线性关系（链表）和分治关系（树），网络关系（图）的自由度更高，从而更为复杂</strong>。</p>
<p>根据<strong>边是否具有方向</strong>，可分为「无向图 Undirected Graph」和「有向图 Directed Graph」。</p>
<p>根据<strong>所有顶点是否连通</strong>，可分为「连通图 Connected Graph」和「非连通图 Disconnected Graph」。</p>
<blockquote>
<ul>
<li><p>对于连通图，从某个顶点出发，可以到达其余任意顶点；</p>
</li>
<li><p>对于非连通图，从某个顶点出发，至少有一个顶点无法到达；</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814111441975.png" alt="image-20230814111441975" style="zoom:50%;"></li>
</ul>
</blockquote>
<p><strong>图常用术语</strong></p>
<ul>
<li>「邻接 Adjacency」：当两顶点之间存在边相连时，称这两顶点“邻接”。在上图中，顶点 1 的邻接顶点为顶点 2、3、5。</li>
<li>「路径 Path」：从<strong>顶点 A 到顶点 B 经过的边构成的序列</strong>被称为从 A 到 B 的“路径”。在上图中，边序列 1-5-2-4 是顶点 1 到顶点 4 的一条路径。</li>
<li>「度 Degree」表示<strong>一个顶点拥有的边数</strong>。对于有向图，「入度 In-Degree」表示有多少条边指向该顶点，「出度 Out-Degree」表示有多少条边从该顶点指出。</li>
</ul>
<p><strong>图的表示</strong></p>
<p>图的常用表示方法包括<strong>「邻接矩阵(时间性能优秀)」</strong>和<strong>「邻接表(空间性能优秀)」</strong>。以下使用无向图进行举例。</p>
<p>邻接矩阵</p>
<p>设图的顶点数量为n，<strong>「邻接矩阵Adjacency Matrix」</strong>使用一个<code>n × n</code>大小的矩阵来表示图，每一行(列)代表一个顶点，矩阵元素代表边，用1或0表示两个顶点之间是否存在边。<br>如图所示，设邻接矩阵为M、顶点列表为V，那么矩阵元素<code>M[i][j] = 1</code>表示顶点<code>V[i]</code>到顶点<code>V[j]</code>之间存在边，反之<code>M[i][j] = 0</code>表示两顶点之间无边。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814111617769.png" alt="image-20230814111617769" style="zoom: 50%;" align="left">

<p>邻接矩阵特性</p>
<blockquote>
<ul>
<li>顶点不能与自身相连，因此邻接矩阵主对角线元素没有意义。</li>
<li>对于无向图，两个方向的边等价，此时邻接矩阵关于主对角线对称。</li>
<li>将邻接矩阵的元素从 1 , 0 替换为权重，则可表示有权图。</li>
<li>使用邻接矩阵表示图时，我们可以直接访问矩阵元素以获取边，因此增删查操作的效率很高，时间复杂度均为 O(1) 。然而，矩阵的空间复杂度为 O(n^2) ，内存占用较多。</li>
</ul>
</blockquote>
<p>邻接表</p>
<p>「邻接表 Adjacency List」使用 n 个链表来表示图，链表节点表示顶点。第 i 条链表对应顶点 i ，其中存储了该顶点的所有邻接顶点（即与该顶点相连的顶点）。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814111719366.png" alt="image-20230814111719366" style="zoom:50%;" align="left">

<p>特性</p>
<blockquote>
<p>邻接表仅存储实际存在的边，而边的总数通常远小于 <code>n^2</code>，因此它更加节省空间。然而，在邻接表中需要通过遍历链表来查找边，因此其时间效率不如邻接矩阵。</p>
</blockquote>
<h3 id="方法论-—-BFS-—-解决两个点之间的最短路径问题。"><a href="#方法论-—-BFS-—-解决两个点之间的最短路径问题。" class="headerlink" title="方法论 — BFS — 解决两个点之间的最短路径问题。"></a>方法论 — BFS — 解决两个点之间的最短路径问题。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start, Node target)</span>&#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start); <span class="comment">// 标记起点已经遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录扩散的步数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(! q.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="keyword">while</span>(sz &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="comment">// 判断当前节点是否符合情况</span></span><br><span class="line">            <span class="keyword">if</span>(cur is target)&#123;</span><br><span class="line">                <span class="keyword">return</span> step;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将当前节点的相邻节点加入队列</span></span><br><span class="line">            <span class="keyword">for</span>(Node x : cur.adj())&#123;</span><br><span class="line">                 <span class="keyword">if</span>(x not in visited)&#123;</span><br><span class="line">                     q.offer(x);</span><br><span class="line">                     visited.add(x);</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="判断二分图-—-染色法"><a href="#判断二分图-—-染色法" class="headerlink" title="判断二分图 — 染色法"></a>判断二分图 — 染色法</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230814135104616.png" alt="image-20230814135104616" style="zoom:80%;" align="left">



<p><strong>方法 — 染色法</strong></p>
<blockquote>
<p>对于图中的任意两个节点 u 和  v，如果它们之间有一条边直接相连，那么 u 和 v 必须属于不同的集合。</p>
<p>如果给定的无向图连通，那么我们就可以任选一个节点开始，给它染成<code>红色(colorNum = 1)</code>。随后我们对整个图进行遍历，将该节点直接相连的所有节点染成<code>绿色(colorNum = 2)</code>，表示这些节点不能与起始节点属于同一个集合。我们再将这些绿色节点直接相连的所有节点染成红色，以此类推，==直到无向图中的每个节点均被染色==。</p>
<p>如果我们能够成功染色，那么红色和绿色的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功染色，即在染色的过程中，某一时刻访问到了一个已经染色的节点，并且它的颜色与我们将要给它染上的颜色不相同，也就说明这个无向图不是一个二分图。</p>
<p>算法的流程如下：</p>
<ul>
<li><p>我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；</p>
</li>
<li><p>在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况：</p>
<ul>
<li>如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历；</li>
<li>如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 false 作为答案。</li>
</ul>
</li>
<li><p>当遍历结束时，说明给定的无向图是二分图，返回 true 作为答案。</p>
</li>
</ul>
<p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历</p>
<p>注意：题目中给定的无向图不一定保证连通（存在孤点），因此我们需要进行多次遍历，直到每一个节点都被染色，或确定答案为 false 为止。每次遍历开始时，我们任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。</p>
</blockquote>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DFS</span></span><br><span class="line"><span class="type">boolean</span> valid; <span class="comment">// 标记是否为二分图</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">    <span class="comment">//所有结点初始颜色为0，即未染色</span></span><br><span class="line">    <span class="type">int</span>[] color = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">    <span class="comment">//深度优先搜索遍历所有节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(color[i] == <span class="number">0</span> &amp;&amp; valid)&#123;</span><br><span class="line">            dfs(i, <span class="number">1</span>, color, graph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> cur, <span class="type">int</span>[] color, <span class="type">int</span>[][] graph)</span>&#123;</span><br><span class="line">    color[node] = cur;</span><br><span class="line">    <span class="comment">//遍历当前节点的所有相邻节点，未染色的染色对立颜色，已经染色的判断是否符合条件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> next : graph[node])&#123;</span><br><span class="line">        <span class="comment">// 如果当前节点连接的节点未染色，则对其连接节点进行dfs染色</span></span><br><span class="line">        <span class="keyword">if</span>(color[next] == <span class="number">0</span>)&#123;</span><br><span class="line">            dfs(next, <span class="number">3</span> - curColor, color, graph);</span><br><span class="line">            <span class="keyword">if</span>(!valid) <span class="keyword">return</span> ;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">// 如果当前节点连接的节点已经染色且二者颜色相同，则说明不能划分二分图</span></span><br><span class="line">            <span class="keyword">if</span>(color[next] == curColor)&#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBipartite</span><span class="params">(<span class="type">int</span>[][] graph)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        <span class="type">int</span>[] color = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;<span class="comment">// 防止图不连通，遍历每个节点</span></span><br><span class="line">            <span class="keyword">if</span>(color[j] == <span class="number">0</span>)&#123;<span class="comment">// 当前节点未染色，则该连通分量未遍历</span></span><br><span class="line">                color[j] = <span class="number">1</span>;<span class="comment">// 第一个点置为颜色1</span></span><br><span class="line">                queue.add(j);</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty())&#123;<span class="comment">// BFS遍历所有邻接点</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                        <span class="type">int</span> <span class="variable">curColor</span> <span class="operator">=</span> color[cur];</span><br><span class="line">                        <span class="keyword">for</span>(<span class="type">int</span> next : graph[cur])&#123;</span><br><span class="line">                            <span class="keyword">if</span>(color[next] == curColor) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 当前节点的邻接点与其颜色一样，则无法形成二分图</span></span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(color[next] == <span class="number">0</span>)&#123;<span class="comment">// 节点未染色，则对其染色，还有一种情况邻接点为当前节点的另外一种颜色，说明已经成功染色，则不需要加入队列进行广搜</span></span><br><span class="line">                                queue.add(next);</span><br><span class="line">                                color[next] = <span class="number">3</span> - curColor;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="方法论-–-网格类问题的-DFS-遍历方法"><a href="#方法论-–-网格类问题的-DFS-遍历方法" class="headerlink" title="方法论 – 网格类问题的 DFS 遍历方法"></a>方法论 – 网格类问题的 DFS 遍历方法</h3><p><strong>网格问题的基本概念</strong></p>
<p>我们首先明确一下网格结构是如何定义的，以方便我们后面的讨论。</p>
<p>网格问题是由 m×n 个小方格组成一个网格，每个小方格与其上下左右四个方格认为是相邻的，要在这样的网格上进行某种搜索。</p>
<p>例如岛屿问题就是一类典型的网格问题。每个格子中的数字可能是 0 或者 1。我们把数字为 0 的格子看成海洋格子，数字为 1 的格子看成陆地格子，这样相邻的陆地格子就连接成一个岛屿。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230816144031628.png" alt="image-20230816144031628" style="zoom: 80%;" align="left">

<p>在这样一个设定下，就出现了各种岛屿问题的变种，包括岛屿的数量、面积、周长等。不过这些问题，基本都可以用 DFS 遍历来解决。</p>
<p><strong>DFS的基本结构</strong></p>
<p>网格结构要比二叉树结构稍微复杂一些，它其实是一种简化版的图结构。要写好网格上的 DFS 遍历，我们首先要理解二叉树上的 DFS 遍历方法，再类比写出网格结构上的 DFS 遍历。我们写的二叉树 DFS 遍历一般是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问两个相邻结点：左子结点、右子结点</span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    traverse(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，二叉树的 DFS 有两个要素：<strong>「访问相邻结点」</strong>和<strong>「判断 base case」</strong>。</p>
<p>第一个要素是<strong>访问相邻结点</strong>。二叉树的相邻结点非常简单，只有左子结点和右子结点两个。二叉树本身就是一个递归定义的结构：一棵二叉树，它的左子树和右子树也是一棵二叉树。那么我们的 DFS 遍历只需要递归调用左子树和右子树即可。</p>
<p>第二个要素是 <strong>判断 base case</strong>。一般来说，二叉树遍历的 base case 是 root == null。这样一个条件判断其实有两个含义：一方面，这表示 root 指向的子树为空，不需要再往下遍历了。另一方面，在 root == null 的时候及时返回，可以让后面的 root.left 和 root.right 操作不会出现空指针异常。</p>
<p><strong>对于</strong>网格上的 DFS，我们完全可以参考二叉树的 DFS，写出网格 DFS 的两个要素：</p>
<p>首先，网格结构中的格子有多少相邻结点？答案是上下左右四个。对于格子 (r, c) 来说（r 和 c 分别代表行坐标和列坐标），四个相邻的格子分别是 (r-1, c)、(r+1, c)、(r, c-1)、(r, c+1)。换句话说，网格结构是「四叉」的。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230816144122194.png" alt="image-20230816144122194" style="zoom:67%;" align="left">

<p>其次，网格 DFS 中的 base case 是什么？从二叉树的 base case 对应过来，应该是网格中不需要继续遍历、grid[r] [c] 会出现数组下标越界异常的格子，也就是那些超出网格范围的格子。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230816144148675.png" alt="image-20230816144148675" style="zoom:67%;" align="left">

<p>这一点稍微有些反直觉，坐标竟然可以临时超出网格的范围？这种方法我称为「先污染后治理」—— 甭管当前是在哪个格子，先往四个方向走一步再说，如果发现走出了网格范围再赶紧返回。这跟二叉树的遍历方法是一样的，先递归调用，发现 root == null 再返回。</p>
<p>这样，我们得到了网格 DFS 遍历的框架代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="comment">// 如果坐标 (r, c) 超出了网格范围，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>如何避免重复遍历</strong></p>
<p>网格结构的 DFS 与二叉树的 DFS 最大的不同之处在于，遍历中可能遇到遍历过的结点。这是因为，网格结构本质上是一个「图」，我们可以把每个格子看成图中的结点，每个结点有向上下左右的四条边。在图中遍历时，自然可能遇到重复遍历结点。</p>
<p>如何避免这样的重复遍历呢？答案是标记已经遍历过的格子。以岛屿问题为例，我们需要在所有值为 1 的陆地格子上做 DFS 遍历。每走过一个陆地格子，就把格子的值改为 2，这样当我们遇到 2 的时候，就知道这是遍历过的格子了。也就是说，每个格子可能取三个值：</p>
<ul>
<li>0 —— 海洋格子</li>
<li>1 —— 陆地格子（未遍历过）</li>
<li>2 —— 陆地格子（已遍历过）</li>
</ul>
<p>我们在框架代码中加入避免重复遍历的语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 base case</span></span><br><span class="line">    <span class="keyword">if</span> (!inArea(grid, r, c)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个格子不是岛屿，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (grid[r][c] != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    grid[r][c] = <span class="number">2</span>; <span class="comment">// 将格子标记为「已遍历过」</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问上、下、左、右四个相邻结点</span></span><br><span class="line">    dfs(grid, r - <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r + <span class="number">1</span>, c);</span><br><span class="line">    dfs(grid, r, c - <span class="number">1</span>);</span><br><span class="line">    dfs(grid, r, c + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断坐标 (r, c) 是否在网格中</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> &lt;= r &amp;&amp; r &lt; grid.length </span><br><span class="line">        	&amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230816144340563.png" alt="image-20230816144340563" style="zoom:80%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] col = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dfs(i, j, grid);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;2&#x27;</span> || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + row[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j + col[k];</span><br><span class="line">        <span class="keyword">if</span>(check(x, y, grid)) dfs(x, y, grid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid.length &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid[<span class="number">0</span>].length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="最短的桥"><a href="#最短的桥" class="headerlink" title="最短的桥"></a>最短的桥</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230816141926662.png" alt="image-20230816141926662" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<blockquote>
<p>题目中给我们透露出了如下几个关键的信息：</p>
<blockquote>
<p>1&gt; grid 中恰有2个岛。那么对于后续我们对岛屿编号的时候，其实只需要针对1个岛屿就可以了。<br>2&gt; 将任意数量的 0 变为 1 ，以使两座岛连接起来，变成一座岛。并且返回必须翻转的 0 的最小数目。</p>
</blockquote>
<p>那么由于0代表水域，1代表陆地，我们要区分两个岛屿，所以，在遍历grid矩阵的时候，只要第一次发现了某个格子为1，则开始将发现的新大陆进行编号，即：将1变为2。在次过程中，我们采用深度遍历的方式寻找整个岛，在深度遍历的过程中，如果我们发现了某个格子为0，则说明我们已经遍历到了岛屿的边缘部分，则将其也赋值为2，即：将0变为2，与此同时，将这个“边缘的格子”放入到双向队列Deque&lt;int[]&gt; edges中，edges中保存着int[]数组，队列中的每个数组长度都是2，即：int[0]保存这个 “边缘的格子”的行，int[1]保存这个 “边缘的格子”的列。</p>
<p>遍历完整个岛屿之后，我们除了将其赋值为2之外，在队列edges中还保存了这个岛屿的所有“边缘格子”，那么下一步骤，我们就需要开启while循环，即：每次循环都根据edges中保存的这个岛屿的所有“边缘格子”对外进行一层的岛屿扩充操作。即：从edges中出队列每个“边缘格子”，再分别从上/下/右/左，四个方向去查看相邻的格子，如果发现是0，则表明是新的一层边缘格子，将其赋值为2，并将其加入到队列edges中，用于下一次while循环。</p>
<p>在对外一层层的扩展岛屿操作过程中，只要发现有“边缘格子”的四周出现了1，则说明已经与另一个岛屿接壤了，直接返回扩展层数即可。具体操作，如下图所示：</p>
<p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230816142040926.png" alt="image-20230816142040926"></p>
</blockquote>
<p><strong>代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下左右四个方向</span></span><br><span class="line"><span class="type">int</span>[] row = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] col = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">findIsland</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestBridge</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">    Deque&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(); <span class="comment">// 保存岛屿周围val为0的边缘格子</span></span><br><span class="line">    <span class="comment">// 步骤1 DFS：为其中一个岛屿打标记(将岛内所有格子val置为2)，并将岛屿边缘格子加入队列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; !findIsland &amp;&amp; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;<span class="comment">// 找到其中一个岛屿的1个格子</span></span><br><span class="line">                dfs(i, j, grid, queue); <span class="comment">// 使用深度优先处理该岛屿的格子，递归处理可以全部处理完</span></span><br><span class="line">                findIsland = <span class="literal">true</span>; <span class="comment">// 处理完完退出最外层循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2 BFS：利用边界格子队列，一层一层往外扩展岛屿，直到遇到val=1，则说明遇到其他岛屿</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123; <span class="comment">// while每循环一次，则说明扩散完一层</span></span><br><span class="line">        res++; <span class="comment">// 由于是边缘格子开始扩散，其原值就是0，所以也算一层</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>] + row[k];</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>] + col[k];</span><br><span class="line">                <span class="keyword">if</span>(check(x, y, grid.length))&#123;</span><br><span class="line">                     <span class="comment">// 遇到val = 1，说明该格子已经邻接另外一个岛屿，返回结果</span></span><br><span class="line">                    <span class="keyword">if</span>(grid[x][y] == <span class="number">1</span>) <span class="keyword">return</span> res;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(grid[x][y] == <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">// 遇到val=0，将其加入边缘格子队列，用于下一轮BFS</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数主要用于给其中一个岛屿的所有格子的val置为2，并将其邻接的val=0的格子加入队列同时也要将val置为2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid, Deque&lt;<span class="type">int</span>[]&gt; queue)</span>&#123;</span><br><span class="line">    <span class="comment">//该格子已经处理，直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">// 边缘格子加入队列</span></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i + row[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j + col[k];</span><br><span class="line">        <span class="keyword">if</span>(check(x, y, grid.length))&#123;</span><br><span class="line">            dfs(x, y, grid, queue);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查该格子位置是否合理</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; n &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="课程表-—-拓扑排序"><a href="#课程表-—-拓扑排序" class="headerlink" title="课程表 — 拓扑排序"></a>课程表 — 拓扑排序</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817104416194.png" alt="image-20230817104416194" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<ul>
<li><p>本题可约化为： 课程安排图是否是 **有向无环图(DAG)**。即课程间规定了前置条件，但不能构成任何环路，否则课程前置条件将不成立。</p>
</li>
<li><p>思路是通过 <strong>拓扑排序</strong> 判断此课程安排图是否是 有向无环图(DAG) 。 <strong>拓扑排序原理</strong>： 对 DAG 的顶点进行排序，使得对每一条有向边 (u,v)，均有 u（在排序记录中）比 v 先出现。亦可理解为对某点 v 而言，只有当 v 的所有源点均出现了，v 才能出现。</p>
</li>
<li><p>通过课程前置条件列表 prerequisites 可以得到课程安排图的 <strong>邻接表 adjacency</strong>，以降低算法时间复杂度</p>
</li>
</ul>
<p><strong>方法</strong>：入度表(广度优先遍历BFS)</p>
<p>算法流程：</p>
<ol>
<li><p>统计课程安排图中每个节点的入度，生成 <strong>入度表 indegrees</strong>。</p>
</li>
<li><p>借助一个<strong>队列 queue</strong>，将所有<strong>入度为 0 的节点入队</strong>。</p>
</li>
<li><p>当 queue 非空时，依次将队首节点出队，在课程安排图中删除此节点 pre：</p>
<ul>
<li><p>并不是真正从邻接表中删除此节点 pre，而是将此节点对应所有邻接节点 cur 的入度 −1，即 indegrees[cur] -= 1。</p>
</li>
<li><p>当入度 −1后邻接节点 cur 的入度为 0，说明 cur 所有的前驱节点已经被 “删除”，此时将 cur 入队。</p>
</li>
</ul>
</li>
<li><p>在每次 pre 出队时，执行 numCourses–；</p>
<ul>
<li>若整个课程安排图是有向无环图（即可以安排），则所有节点一定都入队并出队过，即完成拓扑排序。换个角度说，若课程安排图中存在环，一定有节点的入度始终不为 0。</li>
<li>因此，拓扑排序出队次数等于课程个数，返回 numCourses == 0 判断课程是否可以成功安排。</li>
</ul>
</li>
</ol>
<p>复杂度分析：</p>
<ul>
<li>时间复杂度 O(N+M)： 遍历一个图需要访问所有节点和所有临边，N 和 M 分别为节点数量和临边数量；</li>
<li>空间复杂度 O(N+M)： 为建立邻接表所需额外空间，adjacency 长度为 N ，并存储 M 条临边的数据。</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canFinish</span><span class="params">(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites)</span> &#123;</span><br><span class="line">    <span class="comment">// 入度表： 记录每个结点的入度数，每次节点的前置节点出队时，入度-1</span></span><br><span class="line">    <span class="type">int</span>[] inDegrees = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">    <span class="comment">// 邻接表: 记录节点的后置节点，节点出队后，通过邻接表获取所有后置节点，将其入度-1</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历队列：节点无前置节点时入队，出队时代表遍历当前节点。</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化邻接表， 方便后面直接在对应位置赋值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; numCourses; i++)&#123;</span><br><span class="line">        adjacency.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建邻接表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] pre : prerequisites)&#123;</span><br><span class="line">        <span class="comment">// 统计每个结点的入度 (1,0)表示修课程1之前要修课程0，则课程0是课程1的前置课程，即课程1入度+1</span></span><br><span class="line">        inDegrees[pre[<span class="number">0</span>]]++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 邻接表赋值， 保存一个结点的所有入度相关结点：pre[1] -&gt; pre[0]</span></span><br><span class="line">        adjacency.get(pre[<span class="number">1</span>]).add(pre[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将所有入度为0的结点存入队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队，BFS拓扑排序</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">pre</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        numCourses--;</span><br><span class="line">        <span class="keyword">for</span>(Integer cur : adjacency.get(pre))&#123; <span class="comment">// 获取以pre为前置结点的所有结点</span></span><br><span class="line">            inDegrees[cur]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegrees[cur] == <span class="number">0</span>) &#123; <span class="comment">// 若入度为0， 该cur完了所有前置课程，放入队列</span></span><br><span class="line">                queue.offer(cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numCourses == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="方法论-—-并查集"><a href="#方法论-—-并查集" class="headerlink" title="方法论 — 并查集"></a>方法论 — 并查集</h3><p><strong>思路引入</strong></p>
<ul>
<li>如果事物 a 和 b 有共同点，可以把它们划分到同一集合，同一类。</li>
<li>规定：把同一个类的 a、b 看作是相连的节点，不相连的节点不是一类。</li>
<li>现在有人问你，a 和 b 是否相连（是否同一类）？你回答：“节点 a 指向 节点 b”。</li>
<li>你不止告诉他两个节点相连，还说出了指向信息。</li>
</ul>
<p><strong>向 树 靠拢</strong></p>
<ul>
<li>同属一个集合的 a 和 b ，是相连的点，还让 a 指向 b ，就把连接关系升级了一下</li>
<li>这有点给问题增加难度的意味，解决问题的同时，顺带解决了一些无关的问题。</li>
<li>这是为了便于构建出树，判断节点是否在同一个树中，比较容易。</li>
<li>假如现在来了同类 c，要加入这个集合，我们将 c 指向 b ，就把 c 加入到同一个树中。</li>
<li>当然也可以让 b 指向 c，或让 c 指向 a。只是我们<strong>约定：让新来的指向根节点</strong></li>
</ul>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817114906597.png" alt="image-20230817114906597" style="zoom:67%;" align="left">

<p><strong>维护一个 parent 数组</strong></p>
<ul>
<li>一个数组其实可以映射成树，用【索引值】指向【元素值】描述指向关系，即<code>parent[i] = i</code></li>
<li>如下图，节点 0 ~ 5 是 roots 数组的索引，它们各自对应的元素值是父节点的值</li>
<li>特别的，元素值 -1 代表：该节点没有父节点，自己就是根节点，如下图节点0和2</li>
<li>这个 roots 数组，就是一个存放每个节点的 “父亲” 的数组</li>
<li>所以，roots 数组可以映射出若干颗树，树描述了节点的连接关系，一棵树是一个集合</li>
<li>约定 roots 元素初始值都为 -1，代表所有节点都是散落的，都还没有父节点，等待被归类</li>
</ul>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817114930557.png" alt="image-20230817114930557" style="zoom:67%;" align="left">

<p><strong>设计 union 方法</strong></p>
<ul>
<li>我们目标是：对节点进行归类，把属于同一类的节点，合并到一个树中</li>
<li>设计方法: union(x, y) ，已知两个节点 x, y 是一类，合并它们所在的树</li>
<li>约定：让 x 的根节点 指向 y 的根节点，那么 x 和 y 节点就同处一棵树了。<ul>
<li>即roots[x_root] = y_root，索引为儿子，值为父亲，让 x 的根节点（x_root）指向 y 的根节点（y_root）</li>
<li>可见，只需修改 roots 数组元素，就实现了树的合并，因为 roots 数组被抽象成树了<br><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817115009508.png" alt="image-20230817115009508"></li>
</ul>
</li>
<li>union函数中，需要封装一个 findRoot(x)：返回 x 的根节点，通过一直找父节点，直到尽头，就找到了根节点</li>
<li>如果 findRoot(x) == findRoot(y)，则说明 x、y 的根节点相同，在同一棵树</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">findRoot</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x != parent[x])&#123;</span><br><span class="line">        x = parent[x];<span class="comment">// 依次查找父类</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> findRoot(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> findRoot(y);</span><br><span class="line">    parent[rootX] = rootY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>findRoot方法的设计缺陷</strong></p>
<ul>
<li>没有考虑路径长度的问题，比如 x 所在的树很高，y 所在的树很低，合并时：</li>
<li>让 x_root 指向 y_root 会导致合并后的新树高度变大，导致之后 findRoot 的效率变慢</li>
</ul>
<p><strong>改进</strong> — <strong>路径压缩</strong></p>
<p>有「隔代压缩」与「完全压缩」。</p>
<ul>
<li><p>「隔代压缩」性能比较高，虽然压缩不完全，不过多次执行「隔代压缩」也能达到「完全压缩」的效果，我本人比较偏向使用「隔代压缩」的写法。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/9.gif" alt="img" style="zoom: 33%;" align="left"></li>
<li><p>「完全压缩」需要借助系统栈，使用递归的写法。或者先找到当前结点的根结点，然后把沿途上所有的结点都指向根结点，得遍历两次。<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817115551296.png" alt="image-20230817115551296"></p>
</li>
</ul>
<p><strong>并查集代码模版</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span>&#123;</span><br><span class="line">    <span class="comment">// 节点 x 的父节点是 parent[x]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">    <span class="comment">// 连通分量的个数</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 构造函数，n 为图的节点总数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.count = n; <span class="comment">// 初始连通分量为节点个数 </span></span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="comment">// 每个节点的父节点指针初始都指向自己</span></span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到节点 x 的根节点</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="comment">// 隔代压缩</span></span><br><span class="line">        <span class="keyword">while</span> (x != parent[x])&#123;</span><br><span class="line">            parent[x] = parent[parent[x]];</span><br><span class="line">            x = parent[x];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 彻底压缩</span></span><br><span class="line">        <span class="keyword">if</span> (parent[x] != x)&#123;</span><br><span class="line">            parent[x] = find(parent[x])</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="comment">// 合并节点，让x的根节点指向y的根节点</span></span><br><span class="line">        parent[rootX] = rootY;</span><br><span class="line">        <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnected</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">// 判断两个结点是否连通</span></span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="等式方程的可满足性"><a href="#等式方程的可满足性" class="headerlink" title="等式方程的可满足性"></a>等式方程的可满足性</h3><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817114750687.png" alt="image-20230817114750687"></p>
<p><strong>思路</strong></p>
<p>构建并查集数组，将所有的等式两边的元素加入并查集，然后遍历不等式，如果当前不等式两边的元素在并查集中可以连通，则无法构成等式。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] parent;</span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equationsPossible</span><span class="params">(String[] equations)</span> &#123;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) parent[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">        <span class="comment">// 遍历等式，构建并查集</span></span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">            union(str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>, str.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历不等式，检查不等式两边元素是否连通</span></span><br><span class="line">    <span class="keyword">for</span>(String str : equations)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">1</span>) == <span class="string">&#x27;!&#x27;</span> &amp;&amp; isConnect(str.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>, str.charAt(<span class="number">3</span>) - <span class="string">&#x27;a&#x27;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">// 隔代压缩</span></span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">    parent[rootX] = rootY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="冗余连接-–-并查集找多余边"><a href="#冗余连接-–-并查集找多余边" class="headerlink" title="冗余连接 – 并查集找多余边"></a>冗余连接 – 并查集找多余边</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230817122139901.png" alt="image-20230817122139901" style="zoom:80%;" align="left">

<p><strong>思路</strong></p>
<p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 n 个节点，则这棵树有 n−1 条边。这道题中的图在树的基础上多了一条附加的边，因此边的数量也是 n。<br>树是一个连通且无环的无向图，在树中多了一条附加的边之后就会出现环，因此附加的边即为导致环出现的边。<br>可以通过并查集寻找附加的边。初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</p>
<ul>
<li><p>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</p>
</li>
<li><p>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p>
</li>
</ul>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] parent;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] findRedundantConnection(<span class="type">int</span>[][] edges) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) parent[i] = i;</span><br><span class="line">    <span class="comment">// 遍历所有的边，此时所有节点还不属于同一个连通分量</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span>[] edge : edges)&#123;</span><br><span class="line">        <span class="comment">// 两个顶点不属于相同的连通分量, 将两个顶点加入同一个连通分量</span></span><br><span class="line">        <span class="keyword">if</span>(!isConnect(edge[<span class="number">0</span>], edge[<span class="number">1</span>]))&#123;</span><br><span class="line">            union(edge[<span class="number">0</span>],edge[<span class="number">1</span>]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//  两个顶点属于相同的连通分量，当前边导致环出现</span></span><br><span class="line">            <span class="keyword">return</span> edge;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x != parent[x])&#123;</span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">    parent[rootX] = rootY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="kruskal算法与并查集的关系"><a href="#kruskal算法与并查集的关系" class="headerlink" title="kruskal算法与并查集的关系"></a>kruskal算法与并查集的关系</h3><p>并查集主要用于从所有点中选出边进行相连。</p>
<p>但是最小生成树的问题需要保持权重最小且只有一个连通分量。</p>
<p>所以需要对所有的边根据权重进行排序，同时记录连通分量的个数。</p>
<p>如果最后连通分量只有一个，则可以生成最小生成树。</p>
<p>==注意==：由于并查集中parent数组下标0的位置并没有用到，所以连通分量等于2时才是正解。</p>
<h3 id="最低成本联通所有城市-—-并查集实现kruskal算法解决最小生成树问题"><a href="#最低成本联通所有城市-—-并查集实现kruskal算法解决最小生成树问题" class="headerlink" title="最低成本联通所有城市 — ==并查集实现kruskal算法解决最小生成树问题=="></a>最低成本联通所有城市 — ==并查集实现kruskal算法解决最小生成树问题==</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230914095202986.png" alt="image-20230914095202986" style="zoom: 50%;" align="left">

<p><strong>思路 — 最小生成树问题</strong></p>
<p>最小生成树，就是图中若干边的集合（我们后文称这个集合为<code>mst</code>，最小生成树的英文缩写），你要保证这些边<br>1、包含图中的所有节点。<br>2、形成的结构是树结构（即不存在环）。<br>3、权重和最小。</p>
<p>有之前题目的铺垫，前两条其实可以很容易地利用 Union-Find 算法做到，关键在于第 3 点，如何保证得到的这棵生成树是权重和最小的。</p>
<p>这里就用到了贪心思路：<br><strong>将所有边按照权重从小到大排序，从权重最小的边开始遍历，如果这条边和<code>mst</code>中的其它边不会形成环，则这条边是最小生成树的一部分，将它加入<code>mst</code>集合；否则，这条边不是最小生成树的一部分，不要把它加入<code>mst</code>集合</strong>。</p>
<p>这样，最后<code>mst</code>集合中的边就形成了最小生成树。</p>
<p><strong>最后说下 Kruskal 算法的复杂度分析：</strong></p>
<p>假设一幅图的节点个数为<code>V</code>，边的条数为<code>E</code>，首先需要<code>O(E)</code>的空间装所有边，而且 Union-Find 算法也需要<code>O(V)</code>的空间，所以 Kruskal 算法总的空间复杂度就是<code>O(V + E)</code>。</p>
<p>时间复杂度主要耗费在排序，需要<code>O(ElogE)</code>的时间，Union-Find 算法所有操作的复杂度都是<code>O(1)</code>，套一个 for 循环也不过是<code>O(E)</code>，所以总的时间复杂度为<code>O(ElogE)</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> parent;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"><span class="type">int</span> <span class="title function_">minimumCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] connections)</span> &#123;</span><br><span class="line">    count = n;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) parent[i] = i;</span><br><span class="line">    <span class="comment">// 城市编号为 1...n，所以初始化大小为 n + 1</span></span><br><span class="line">    <span class="comment">//UF uf = new UF(n + 1);</span></span><br><span class="line">    <span class="comment">// 对所有边按照权重从小到大排序</span></span><br><span class="line">    Arrays.sort(connections, (a, b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">    <span class="comment">// 记录最小生成树的权重之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mst</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : connections) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 若这条边会产生环，则不能加入 mst</span></span><br><span class="line">        <span class="keyword">if</span> (isConnect(u, v)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若这条边不会产生环，则属于最小生成树</span></span><br><span class="line">        mst += weight;</span><br><span class="line">        union(u, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保证所有节点都被连通</span></span><br><span class="line">    <span class="comment">// 按理说 uf.count() == 1 说明所有节点被连通</span></span><br><span class="line">    <span class="comment">// 但因为节点 0 没有被使用，所以 0 会额外占用一个连通分量</span></span><br><span class="line">    <span class="keyword">return</span> count() == <span class="number">2</span> ? mst : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到节点 x 的根节点</span></span><br><span class="line"><span class="keyword">public</span>  <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="comment">// 隔代压缩</span></span><br><span class="line">    <span class="keyword">while</span> (x != parent[x])&#123;</span><br><span class="line">        parent[x] = parent[parent[x]];</span><br><span class="line">        x = parent[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">    <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">    <span class="comment">// 合并节点，让x的根节点指向y的根节点</span></span><br><span class="line">    parent[rootX] = rootY;</span><br><span class="line">    <span class="comment">// 两个连通分量合并成一个连通分量</span></span><br><span class="line">    count--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断两个结点是否连通</span></span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="连接所有点的最小费用-—-kruskal"><a href="#连接所有点的最小费用-—-kruskal" class="headerlink" title="连接所有点的最小费用  — ==kruskal=="></a>连接所有点的最小费用  — ==kruskal==</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230914095940037.png" alt="image-20230914095940037" style="zoom: 50%;" align="left">

<p><strong>Kruskal算法思路</strong></p>
<p>很显然这也是一个标准的最小生成树问题：每个点就是无向加权图中的节点，边的权重就是曼哈顿距离，连接所有点的最小费用就是最小生成树的权重和。</p>
<p>所以解法思路就是先生成所有的边以及权重，然后对这些边执行 Kruskal 算法。</p>
<p>坐标系中每个点都是一个二元组，按理来说应该使用五元组表示一条带权重的边，但是这种表示不利于使用并查集。所以使用points数组中的索引代表每个坐标点。即使用三元组来表示一条带权重的边。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] parent;</span><br><span class="line"><span class="type">int</span> count;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostConnectPoints</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> points.length;</span><br><span class="line">    parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    count = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) parent[i] = i;</span><br><span class="line">    <span class="comment">// 使用优先队列每次选出权重最小的边加入最小生成树</span></span><br><span class="line">    PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">// 构建所有节点之间带权重值的边</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> Math.abs(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]) + Math.abs(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]);</span><br><span class="line">            pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j, val&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span>[] cur = pq.poll();</span><br><span class="line">        <span class="keyword">if</span>(!isConnect(cur[<span class="number">0</span>], cur[<span class="number">1</span>]))&#123;</span><br><span class="line">            union(cur[<span class="number">0</span>], cur[<span class="number">1</span>]);</span><br><span class="line">            res += cur[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(parent[x] != x) parent[x] = find(parent[x]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parent[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    parent[find(x)] = find(y);</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isConnect</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="除法求值"><a href="#除法求值" class="headerlink" title="除法求值"></a>除法求值</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230914102517251.png" alt="image-20230914102517251" style="zoom: 80%;" align="left">

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230914102530815.png" alt="image-20230914102530815" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<blockquote>
<p>除法求值这道问题，刚开始看到这道题，从人的思维来看的话，很想小学时期做的那些等值代换的问题，给你一些值变量值的关系，最后抛出一个全新的式子，利用之前给出的关系式求出未知式子的答案。而本题与之的唯一的区别就是我们要转变人的思维而编程计算机的思维（我这句不是废话哦，与本题的题解主题是呼应的哦），用代码写出这种问题的解法。</p>
<p>其实我上面说了，我们作为人，第一次看到这个题目是从人的主观思维感受出发的，我就是感受到小学时期的这种题目，而题目的思路来源在哪呢？</p>
<p>答案正是来源于这样的思维，我们知道，我们是提交代码不是提交自己脑子想的哪些东西，正因如此，需要我上面所说的思维的转变，而要想转变到计算机思维上去最关键的是什么呢？——正是本次的主题——抽象思维，计算机思维的一个很微妙而重要的特点就是抽象思维，而本题就可以利用这样的抽象思维去求解。我们思考如何刻画出题目给出的这些关系，<strong>其实无非就是告诉你a和b、b和c的关系，然后求出a和c的关系呗，告诉的是俩者之间的关系，对应到计算机抽象思维中是什么，就是图啊，两者之间的关系不就是两个节点之间的连接嘛，如果是简单的对等关系，就是无权图，如果有指向性要求，那就是有向无权图，如果不是简单的对等关系，有类似本题的这样的关系，那不就是带权图嘛。</strong>好嘞，第一个问题解决了，刻画所给关系就是建图，那第二个问题怎么解决呢？其实也很简单，既然图都建好了，那图中所用的那些方法无非就是DFS、BFS这些嘛，而寻找新的对应关系刚好就映射了图的搜索问题。好了，这个问题已经解决了，其实这个问题的难度根本不在所讨论的什么各种方法之间的难度，难就难在把这个图有条有序地建立起来，这个图合适地构建出来了，什么深搜、广搜、Floyd、带权并查集的解法都没什么值得提的了。</p>
<p>既然是带权图，而且本题显然是无向的，同时所给的节点的标志是string，不是常规int，所以我们要额外增加一个hash映射的操作，至于搜索，那么BFS和DFS都是可以的，还有就是因为是除法关系，所以更新我们采用的利用权值的乘法来实现的，ratio数组表示的是ida于i的比值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span>[] calcEquation(List&lt;List&lt;String&gt;&gt; equations, <span class="type">double</span>[] values, List&lt;List&lt;String&gt;&gt; queries) &#123;</span><br><span class="line">        <span class="comment">// 节点编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nvars</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 保存所有节点名称与编号的映射</span></span><br><span class="line">        Map&lt;String, Integer&gt; variables = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 图中边的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> equations.size();</span><br><span class="line">        <span class="comment">// 给所有结点编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!variables.containsKey(equations.get(i).get(<span class="number">0</span>)))&#123;</span><br><span class="line">                variables.put(equations.get(i).get(<span class="number">0</span>), nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!variables.containsKey(equations.get(i).get(<span class="number">1</span>)))&#123;</span><br><span class="line">                variables.put(equations.get(i).get(<span class="number">1</span>), nvars++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于每个点，存储其直接连接到的所有点及对应的权值</span></span><br><span class="line">        List&lt;Pair&gt;[] edges = <span class="keyword">new</span> <span class="title class_">List</span>[nvars];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;nvars; i++)&#123;</span><br><span class="line">            edges[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">va</span> <span class="operator">=</span> variables.get(equations.get(i).get(<span class="number">0</span>)), vb = variables.get(equations.get(i).get(<span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 存储有向边及其权值</span></span><br><span class="line">            edges[va].add(<span class="keyword">new</span> <span class="title class_">Pair</span>(vb, values[i]));</span><br><span class="line">            <span class="comment">// 存储其倒数</span></span><br><span class="line">            edges[vb].add(<span class="keyword">new</span> <span class="title class_">Pair</span>(va,<span class="number">1.0</span> / values[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">queriesCount</span> <span class="operator">=</span> queries.size();</span><br><span class="line">        <span class="type">double</span>[] ret = <span class="keyword">new</span> <span class="title class_">double</span>[queriesCount];</span><br><span class="line">        <span class="comment">// 遍历待求值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queriesCount; i++)&#123;</span><br><span class="line">            List&lt;String&gt; query = queries.get(i);</span><br><span class="line">            <span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> -<span class="number">1.0</span>;</span><br><span class="line">            <span class="keyword">if</span>(variables.containsKey(query.get(<span class="number">0</span>)) &amp;&amp; variables.containsKey(query.get(<span class="number">1</span>)))&#123;</span><br><span class="line">                <span class="comment">// 得到待求解值的两个端点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">ia</span> <span class="operator">=</span> variables.get(queries.get(<span class="number">0</span>)), ib = variables.get(queries.get(<span class="number">1</span>));</span><br><span class="line">                <span class="comment">// 端点相等则返回1</span></span><br><span class="line">                <span class="keyword">if</span>(ia == ib)&#123;</span><br><span class="line">                    result = <span class="number">1.0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    Queue&lt;Integer&gt; points = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">                    points.offer(ia);</span><br><span class="line">                    <span class="type">double</span>[] ratios = <span class="keyword">new</span> <span class="title class_">double</span>[nvars];</span><br><span class="line">                    Arrays.fill(ratios, -<span class="number">1.0</span>);</span><br><span class="line">                    ratios[ia] = <span class="number">1.0</span>;</span><br><span class="line">                    <span class="comment">// BFS</span></span><br><span class="line">                    <span class="keyword">while</span> (!points.isEmpty() &amp;&amp; ratios[ib] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> points.poll();</span><br><span class="line">                        <span class="keyword">for</span> (Pair pair : edges[x])&#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> pair.index;</span><br><span class="line">                            <span class="type">double</span> <span class="variable">val</span> <span class="operator">=</span> pair.value;</span><br><span class="line">                            <span class="keyword">if</span>(ratios[y] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                                ratios[y] = ratios[x] * val;</span><br><span class="line">                                points.offer(y);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    result = ratios[ib];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret[i] = result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pair</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">double</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pair</span><span class="params">(<span class="type">int</span> index, <span class="type">double</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="01矩阵-—-BFS"><a href="#01矩阵-—-BFS" class="headerlink" title="01矩阵 — ==BFS=="></a>01矩阵 — ==BFS==</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230914112023425.png" alt="image-20230914112023425" style="zoom:80%;" align="left">

<p>思路</p>
<p>将所有的<code>0</code>入队，然后从各个 0 开始向1扩散，每个1都是被其最近的0扩散到的。扩散的时候可以设置dist[ ] [ ]数组来记录扩散距离同时标记是否访问。对于本题可以在原数组上进行修改，在前面入队0的过程中，将所有遇到的1标记为-1，表示还未访问的1。</p>
<p>然后将所有的0(下标为(x, y))出队，然后将当前0四周所有的1的值改为matrix[x] [y]+1。表示距离+1。同时将该处理过的值加入队列</p>
<p>当所有的0四周的1都处理完成后，开始处理所有的1四周的1，距离也是 matrix[x] [y]+1，其实也就是2。处理完后也加入队列，以此类推…</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] matrix)&#123;</span><br><span class="line">    <span class="comment">// 首先将所有的 0 都入队，并且将 1 的位置设置成 -1，表示该位置是 未被访问过的 1</span></span><br><span class="line">    Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                matrix[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] dx = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] dy = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">int</span>[] point = queue.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>], y = point[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dx[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dy[i];</span><br><span class="line">            <span class="comment">// 如果邻域的点是 -1，表示这个点是未被访问过的 1</span></span><br><span class="line">            <span class="comment">// 所以这个点到 0 的距离就可以更新成 matrix[x][y] + 1。</span></span><br><span class="line">            <span class="keyword">if</span>(newX &gt;= <span class="number">0</span> &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= <span class="number">0</span> &amp;&amp; newY &lt; n &amp;&amp; matrix[newX][newY] == -<span class="number">1</span>)&#123;</span><br><span class="line">                matrix[newX][newY] = matrix[x][y] + <span class="number">1</span>;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;newX, newY&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="打开转盘所-—-双向BFS-已知起点与终点"><a href="#打开转盘所-—-双向BFS-已知起点与终点" class="headerlink" title="打开转盘所 — 双向BFS(已知起点与终点)"></a>打开转盘所 — 双向BFS(已知起点与终点)</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915095255624.png" alt="image-20230915095255624" style="zoom: 67%;" align="left">



<h3 id="Dijkstra算法-—-求带权有向图中一点到其他所有点的最短路径"><a href="#Dijkstra算法-—-求带权有向图中一点到其他所有点的最短路径" class="headerlink" title="==Dijkstra算法== — 求带权有向图中一点到其他所有点的最短路径"></a>==Dijkstra算法== — 求带权有向图中一点到其他所有点的最短路径</h3><p><strong>从二叉树层序遍历和BFS算法开始</strong></p>
<p>二叉树层序遍历</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，层序遍历这棵二叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历二叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先来思考一个问题，注意二叉树的层级遍历 <code>while</code> 循环里面还套了个 <code>for</code> 循环，为什么要这样？</p>
<p><code>while</code> 循环和 <code>for</code> 循环的配合正是这个遍历框架设计的巧妙之处：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915163412907.png" alt="image-20230915163412907" style="zoom:50%;" align="left">

<p><strong><code>while</code> 循环控制一层一层往下走，<code>for</code> 循环利用 <code>sz</code> 变量控制从左到右遍历每一层二叉树节点</strong>。</p>
<p>注意我们代码框架中的 <code>depth</code> 变量，其实就记录了当前遍历到的层数。换句话说，每当我们遍历到一个节点 <code>cur</code>，都知道这个节点属于第几层。</p>
<p>算法题经常会问二叉树的最大深度呀，最小深度呀，层序遍历结果呀，等等问题，所以记录下来这个深度 <code>depth</code> 是有必要的。</p>
<p>基于二叉树的遍历框架，我们又可以扩展出==多叉树的层序遍历框架==：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵多叉树的根节点，层序遍历这棵多叉树</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从上到下遍历多叉树的每一层</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">// 从左到右遍历每一层的每个节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur, depth);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将下一层节点放入队列</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode child : cur.children) &#123;</span><br><span class="line">                q.offer(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于多叉树的遍历框架，我们又可以扩展出 ==BFS（广度优先搜索）的算法框架==：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入起点，进行 BFS 搜索</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BFS</span><span class="params">(Node start)</span> &#123;</span><br><span class="line">    Queue&lt;Node&gt; q; <span class="comment">// 核心数据结构</span></span><br><span class="line">    Set&lt;Node&gt; visited; <span class="comment">// 避免走回头路</span></span><br><span class="line">    </span><br><span class="line">    q.offer(start); <span class="comment">// 将起点加入队列</span></span><br><span class="line">    visited.add(start);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 记录搜索的步数</span></span><br><span class="line">    <span class="keyword">while</span> (q not empty) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">        <span class="comment">/* 将当前队列中的所有节点向四周扩散一步 */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            printf(<span class="string">&quot;从 %s 到 %s 的最短距离是 %s&quot;</span>, start, cur, step);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 将 cur 的相邻节点加入队列 */</span></span><br><span class="line">            <span class="keyword">for</span> (Node x : cur.adj()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x not in visited) &#123;</span><br><span class="line">                    q.offer(x);</span><br><span class="line">                    visited.add(x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        step++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意，我们的 BFS 算法框架也是 <code>while</code> 循环嵌套 <code>for</code> 循环的形式，也用了一个 <code>step</code> 变量记录 <code>for</code> 循环执行的次数，无非就是多用了一个 <code>visited</code> 集合记录走过的节点，防止走回头路罢了</strong>。</p>
<p>为什么这样呢？</p>
<p>所谓「无权图」，与其说每条「边」没有权重，不如说每条「边」的权重都是 1，从起点 <code>start</code> 到任意一个节点之间的路径权重就是它们之间「边」的条数，那可不就是 <code>step</code> 变量记录的值么？</p>
<p>再加上 BFS 算法利用 <code>for</code> 循环一层一层向外扩散的逻辑和 <code>visited</code> 集合防止走回头路的逻辑，当你每次从队列中拿出节点 <code>cur</code> 的时候，从 <code>start</code> 到 <code>cur</code> 的最短权重就是 <code>step</code> 记录的步数。</p>
<p>但是，到了「加权图」的场景，事情就没有这么简单了，因为你不能默认每条边的「权重」都是 1 了，这个权重可以是任意正数（Dijkstra 算法要求不能存在负权重边），比如下图的例子：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915164209647.png" alt="image-20230915164209647" style="zoom: 50%;" align="left">

<p>如果沿用 BFS 算法中的 <code>step</code> 变量记录「步数」，显然红色路径一步就可以走到终点，但是这一步的权重很大；正确的最小权重路径应该是绿色的路径，虽然需要走很多步，但是路径权重依然很小。</p>
<p>其实 Dijkstra 和 BFS 算法差不多，不过在讲解 Dijkstra 算法框架之前，我们首先需要对之前的框架进行如下改造：</p>
<p><strong>想办法去掉 <code>while</code> 循环里面的 <code>for</code> 循环</strong>。</p>
<p>为什么？有了刚才的铺垫，这个不难理解，刚才说 <code>for</code> 循环是干什么用的来着？</p>
<p>是为了让二叉树一层一层往下遍历，让 BFS 算法一步一步向外扩散，因为这个层数 <code>depth</code>，或者这个步数 <code>step</code>，在之前的场景中有用。</p>
<p>但现在我们想解决「加权图」中的最短路径问题，「步数」已经没有参考意义了，「路径的权重之和」才有意义，所以这个 <code>for</code> 循环可以被去掉。</p>
<p>怎么去掉？就拿二叉树的层级遍历来说，其实你可以直接去掉 <code>for</code> 循环相关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树的每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        printf(<span class="string">&quot;我不知道节点 %s 在第几层&quot;</span>, cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(cur.right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但问题是，没有 <code>for</code> 循环，你也没办法维护 <code>depth</code> 变量了。</p>
<p>如果你想同时维护 <code>depth</code> 变量，让每个节点 <code>cur</code> 知道自己在第几层，可以想其他办法，比如新建一个 <code>State</code> 类，记录每个节点所在的层数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 记录 node 节点的深度</span></span><br><span class="line">    <span class="type">int</span> depth;</span><br><span class="line">    TreeNode node;</span><br><span class="line"></span><br><span class="line">    State(TreeNode node, <span class="type">int</span> depth) &#123;</span><br><span class="line">        <span class="built_in">this</span>.depth = depth;</span><br><span class="line">        <span class="built_in">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一棵二叉树的根节点，遍历这棵二叉树所有节点</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">levelTraverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Queue&lt;State&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(root, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树的每一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">cur_node</span> <span class="operator">=</span> cur.node;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur_depth</span> <span class="operator">=</span> cur.depth;</span><br><span class="line">        printf(<span class="string">&quot;节点 %s 在第 %s 层&quot;</span>, cur_node, cur_depth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将子节点放入队列</span></span><br><span class="line">        <span class="keyword">if</span> (cur_node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(cur_node.left, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur_node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            q.offer(<span class="keyword">new</span> <span class="title class_">State</span>(cur_node.right, cur_depth + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样，我们就可以不使用 <code>for</code> 循环也确切地知道每个二叉树节点的深度了。</p>
<p><strong>如果你能够理解上面这段代码，我们就可以来看 Dijkstra 算法的代码框架了</strong>。</p>
<p><strong>Dijkstra算法框架</strong></p>
<p>函数签名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离 </span></span><br><span class="line"><span class="comment">// 返回值为一个disTo数组，数组中记录start点到其他节点的最短路径</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;Integer&gt;[] graph);</span><br></pre></td></tr></table></figure>

<p>输入是一幅图 <code>graph</code> 和一个起点 <code>start</code>，返回是一个记录最短路径权重的数组。</p>
<p>比方说，输入起点 <code>start = 3</code>，函数返回一个 <code>int[]</code> 数组，假设赋值给 <code>distTo</code> 变量，那么从起点 <code>3</code> 到节点 <code>6</code> 的最短路径权重的值就是 <code>distTo[6]</code>。</p>
<p>是的，标准的 Dijkstra 算法会把从起点 <code>start</code> 到所有其他节点的最短路径都算出来。</p>
<p>当然，如果你的需求只是计算从起点 <code>start</code> 到某一个终点 <code>end</code> 的最短路径，那么在标准 Dijkstra 算法上稍作修改就可以更高效地完成这个需求，这个我们后面再说。</p>
<p><strong>其次，我们也需要一个 <code>State</code> 类来辅助算法的运行</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点的 id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 从 start 节点到当前节点的距离</span></span><br><span class="line">    <span class="type">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    State(<span class="type">int</span> id, <span class="type">int</span> distFromStart) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似刚才二叉树的层序遍历，我们也需要用 <code>State</code> 类记录一些额外信息，也就是使用 <code>distFromStart</code> 变量记录从起点 <code>start</code> 到当前这个节点的距离。</p>
<p>刚才说普通 BFS 算法中，根据 BFS 的逻辑和无权图的特点，第一次遇到某个节点所走的步数就是最短距离，所以用一个 <code>visited</code> 数组防止走回头路，每个节点只会经过一次。</p>
<p>加权图中的 Dijkstra 算法和无权图中的普通 BFS 算法不同，在 Dijkstra 算法中，你第一次经过某个节点时的路径权重，不见得就是最小的，所以对于同一个节点，我们可能会经过多次，而且每次的 <code>distFromStart</code> 可能都不一样，比如下图：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915164353252.png" alt="image-20230915164353252" style="zoom:50%;" align="left">

<p>我会经过节点 <code>5</code> 三次，每次的 <code>distFromStart</code> 值都不一样，那我取 <code>distFromStart</code> 最小的那次，不就是从起点 <code>start</code> 到节点 <code>5</code> 的最短路径权重了么？</p>
<p>好了，明白上面的几点，我们可以来看看 Dijkstra 算法的代码模板。</p>
<p><strong>其实，Dijkstra 可以理解成一个带 dp table（或者说备忘录）的 BFS 算法，伪码如下</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回节点 from 到节点 to 之间的边的权重</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">weight</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入节点 s 返回 s 的相邻节点</span></span><br><span class="line">List&lt;Integer&gt; <span class="title function_">adj</span><span class="params">(<span class="type">int</span> s)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一幅图和一个起点 start，计算 start 到其他节点的最短距离</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;Integer&gt;[] graph) &#123;</span><br><span class="line">    <span class="comment">// 图中节点的个数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> graph.length;</span><br><span class="line">    <span class="comment">// 记录最短路径的权重，你可以理解为 dp table</span></span><br><span class="line">    <span class="comment">// 定义：distTo[i] 的值就是节点 start 到达节点 i 的最短路径权重</span></span><br><span class="line">    <span class="type">int</span>[] distTo = <span class="keyword">new</span> <span class="title class_">int</span>[V];</span><br><span class="line">    <span class="comment">// 求最小值，所以 dp table 初始化为正无穷</span></span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// base case，start 到 start 的最短距离就是 0</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，distFromStart 较小的排在前面</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从起点 start 开始进行 BFS</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line">	<span class="comment">// 一个节点可能被添加多次，每次计算的最短路径都不同，所以在这里要过滤掉不是最短路径的其他选择</span></span><br><span class="line">        <span class="keyword">if</span> (curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="comment">// 已经有一条更短的路径到达 curNode 节点了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 curNode 的相邻节点装入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> nextNodeID : adj(curNodeID)) &#123;</span><br><span class="line">            <span class="comment">// 看看从 curNode 达到 nextNode 的距离是否会更短</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">distToNextNode</span> <span class="operator">=</span> distTo[curNodeID] + weight(curNodeID, nextNodeID);</span><br><span class="line">            <span class="keyword">if</span> (distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp table</span></span><br><span class="line">                distTo[nextNodeID] = distToNextNode;</span><br><span class="line">                <span class="comment">// 将这个节点以及距离放入队列</span></span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对上述代码的while循环内代码的理解</p>
<p>假设图为：<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915164641703.png" alt="image-20230915164641703" style="zoom:33%;"></p>
<p>我们要计算节点1到节点6的最短距离。<br>从队列中弹出节点1后，我们会把节点2,3,4到节点1的距离更新，此时会将(2,3), (3,3), (4,3)加入队列。<br>然后下一轮依次弹出2,3,4节点，计算到节点5的距离，由于节点1由2,3,4到节点5的距离依次为6,5,4。<br>所以队列中会依次存入(5,6),(5,5),(5,4)。这三个都是保存节点5的路径数据。<br>由于我们要计算到节点6的最短距离，所以需要过滤掉(5,6)，(5,5)两组数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们会先弹出(2,3)然后计算出到节点5的距离(5,6),然后弹出(3,3)得到(5,5),然后弹出(4,3)得到(5,4)</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> nextNodeID : adj(curNodeID)) &#123;</span><br><span class="line">         <span class="comment">// 看看从 curNode 达到 nextNode 的距离是否会更短</span></span><br><span class="line">         <span class="type">int</span> <span class="variable">distToNextNode</span> <span class="operator">=</span> distTo[curNodeID] + weight(curNodeID, nextNodeID);</span><br><span class="line">         <span class="keyword">if</span> (distTo[nextNodeID] &gt; distToNextNode) &#123;<span class="comment">// 这一步，(5,6),(5,5),(5,4)都会加入队列</span></span><br><span class="line">             <span class="comment">// 更新 dp table</span></span><br><span class="line">             distTo[nextNodeID] = distToNextNode;</span><br><span class="line">             <span class="comment">// 将这个节点以及距离放入队列</span></span><br><span class="line">             pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述执行完后，队列中会有(5,6),(5,5),(5,4)，我们假设是先弹出(5,4)进行计算，得到disTo[5]的值为4</span></span><br><span class="line"><span class="comment">// 后续的(5,5),(5,6)都会被下面这一步过滤掉</span></span><br><span class="line"><span class="keyword">if</span> (curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="comment">// 已经有一条更短的路径到达 curNode 节点了</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="网络延迟时间—Dijkstra"><a href="#网络延迟时间—Dijkstra" class="headerlink" title="网络延迟时间—Dijkstra"></a>网络延迟时间—Dijkstra</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915142636543.png" alt="image-20230915142636543" style="zoom: 80%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 节点编号是从 1 开始的，所以要一个大小为 n + 1 的邻接表</span></span><br><span class="line">    List&lt;<span class="type">int</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">LinkedList</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        graph[i] = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : times) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> edge[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// from -&gt; List&lt;(to, weight)&gt;</span></span><br><span class="line">        <span class="comment">// 邻接表存储图结构，同时存储权重信息</span></span><br><span class="line">        graph[from].add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;to, weight&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动 dijkstra 算法计算以节点 k 为起点到其他节点的最短路径</span></span><br><span class="line">    <span class="type">int</span>[] distTo = dijkstra(k, graph);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到接收时间最长的节点，只要接收时间最长的节点收到信号后，所有节点都已经收到信号</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; distTo.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (distTo[i] == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="comment">// 有节点不可达，返回 -1</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, distTo[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">    <span class="comment">// 图节点的 id</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="comment">// 从 start 节点到当前节点的距离</span></span><br><span class="line">    <span class="type">int</span> distFromStart;</span><br><span class="line"></span><br><span class="line">    State(<span class="type">int</span> id, <span class="type">int</span> distFromStart) &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.distFromStart = distFromStart;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入一个起点 start，计算从 start 到其他节点的最短距离</span></span><br><span class="line"><span class="type">int</span>[] dijkstra(<span class="type">int</span> start, List&lt;<span class="type">int</span>[]&gt;[] graph) &#123;</span><br><span class="line">    <span class="comment">// 定义：distTo[i] 的值就是起点 start 到达节点 i 的最短路径权重</span></span><br><span class="line">    <span class="type">int</span>[] distTo = <span class="keyword">new</span> <span class="title class_">int</span>[graph.length];</span><br><span class="line">    Arrays.fill(distTo, Integer.MAX_VALUE);</span><br><span class="line">    <span class="comment">// base case，start 到 start 的最短距离就是 0</span></span><br><span class="line">    distTo[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优先级队列，distFromStart 较小的排在前面。比如遇到(5,5),(5,6),(5,4)会优先计算(5,4)，然后将(5,5),(5,6)过滤掉</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a.distFromStart - b.distFromStart;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 从起点 start 开始进行 BFS</span></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">curState</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNodeID</span> <span class="operator">=</span> curState.id;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curDistFromStart</span> <span class="operator">=</span> curState.distFromStart;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (curDistFromStart &gt; distTo[curNodeID]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 curNode 的相邻节点装入队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] neighbor : graph[curNodeID]) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextNodeID</span> <span class="operator">=</span> neighbor[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">distToNextNode</span> <span class="operator">=</span> distTo[curNodeID] + neighbor[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 更新 dp table</span></span><br><span class="line">            <span class="keyword">if</span> (distTo[nextNodeID] &gt; distToNextNode) &#123;</span><br><span class="line">                distTo[nextNodeID] = distToNextNode;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextNodeID, distToNextNode));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> distTo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="概率最大的路径"><a href="#概率最大的路径" class="headerlink" title="概率最大的路径"></a>概率最大的路径</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915182239200.png" alt="image-20230915182239200" style="zoom:50%;" align="left">

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230915182252067.png" alt="image-20230915182252067" style="zoom:50%;" align="left">



<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">maxProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">double</span>[] succProb, <span class="type">int</span> start_node, <span class="type">int</span> end_node)</span> &#123;</span><br><span class="line">    List&lt;<span class="type">double</span>[]&gt;[] graph = <span class="keyword">new</span> <span class="title class_">List</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) graph[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++)&#123;</span><br><span class="line">        <span class="comment">// 无向图就是双向图</span></span><br><span class="line">        graph[edges[i][<span class="number">0</span>]].add(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;edges[i][<span class="number">1</span>], succProb[i]&#125;);</span><br><span class="line">        graph[edges[i][<span class="number">1</span>]].add(<span class="keyword">new</span> <span class="title class_">double</span>[]&#123;edges[i][<span class="number">0</span>], succProb[i]&#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 优先级队列，probFromStart 较大的排在前面</span></span><br><span class="line">    Queue&lt;State&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;State&gt;((a, b) -&gt; Double.compare(b.startToPro, a.startToPro));</span><br><span class="line"></span><br><span class="line">    pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(start_node, <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span>[] proTo = <span class="keyword">new</span> <span class="title class_">double</span>[n];</span><br><span class="line">    Arrays.fill(proTo, -<span class="number">1.0</span>);</span><br><span class="line">    proTo[start_node] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.isEmpty())&#123;</span><br><span class="line">        <span class="type">State</span> <span class="variable">cur</span> <span class="operator">=</span> pq.poll();</span><br><span class="line">        <span class="type">int</span> <span class="variable">curId</span> <span class="operator">=</span> cur.index;</span><br><span class="line">        <span class="type">double</span> <span class="variable">curProToStart</span> <span class="operator">=</span> cur.startToPro;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(curId == end_node)&#123;</span><br><span class="line">            <span class="keyword">return</span> curProToStart;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curProToStart &lt; proTo[curId]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">double</span>[] next : graph[curId])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">nextId</span> <span class="operator">=</span> (<span class="type">int</span>)next[<span class="number">0</span>];</span><br><span class="line">            <span class="type">double</span> <span class="variable">nextToStart</span> <span class="operator">=</span> next[<span class="number">1</span>] * curProToStart;</span><br><span class="line">            <span class="keyword">if</span>(nextToStart  &gt; proTo[nextId])&#123;</span><br><span class="line">                proTo[nextId] = nextToStart;</span><br><span class="line">                pq.offer(<span class="keyword">new</span> <span class="title class_">State</span>(nextId, nextToStart));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">State</span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">double</span> startToPro;</span><br><span class="line"></span><br><span class="line">    State(<span class="type">int</span> index, <span class="type">double</span> startToPro)&#123;</span><br><span class="line">        <span class="built_in">this</span>.index = index;</span><br><span class="line">        <span class="built_in">this</span>.startToPro = startToPro;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="floyd算法-多源最短路问题"><a href="#floyd算法-多源最短路问题" class="headerlink" title="==floyd算法== - 多源最短路问题"></a>==floyd算法== - 多源最短路问题</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231114152230685.png" alt="image-20231114152230685" style="zoom: 50%;" align="left">

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231114152249919.png" alt="image-20231114152249919" style="zoom:50%;" align="left">

<p><strong>基本分析</strong></p>
<p>预处理图中任意两点 i 和 j 的最短距离 dist，那么统计每个点 i 在图中有多少满足 dist[j]≤distanceThresholddist 的点 j 即为答案。</p>
<p>于是问题转换为：如何求解给定图中，任意两点的最短距离。即求多源最短路径问题 — floyd算法。</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20231114155159460.png" alt="image-20231114155159460" style="zoom: 67%;" align="left">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheCity</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] edges, <span class="type">int</span> distanceThreshold)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] g = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="comment">// 初始化邻接矩阵，图为无向带权图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">// 图中的边带权重，初始化时使用0x3f3f3f3f代替默认的最大值</span></span><br><span class="line">            g[i][j] = i == j ? <span class="number">0</span> : <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存图，无向图的两边端点都需要存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">        g[a][b] = g[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算任意两点的最短路径</span></span><br><span class="line">    floyd(g);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计答案</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>, cnt = n + <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j &amp;&amp; g[i][j] &lt;= distanceThreshold) cur++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur &lt;= cnt) &#123;</span><br><span class="line">            cnt = cur; ans = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">(<span class="type">int</span>[][] g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> g.length;</span><br><span class="line">    <span class="comment">// floyd 基本流程为三层循环: [枚举中转点 - 枚举起点 - 枚举终点] =&gt; 松弛操作  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>; p &lt; n; p++) &#123; <span class="comment">// p为中转点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// i为起点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123; <span class="comment">// j为终点</span></span><br><span class="line">                g[i][j] = Math.min(g[i][j], g[i][p] + g[p][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="9-设计模拟专题总结"><a href="#9-设计模拟专题总结" class="headerlink" title="9.设计模拟专题总结"></a>9.设计模拟专题总结</h2><h3 id="1-二维数组相关模拟"><a href="#1-二维数组相关模拟" class="headerlink" title="1.二维数组相关模拟"></a>1.二维数组相关模拟</h3><h4 id="59-螺旋矩阵II-顺时针填充矩阵"><a href="#59-螺旋矩阵II-顺时针填充矩阵" class="headerlink" title="59.螺旋矩阵II_==顺时针填充矩阵=="></a>59.螺旋矩阵II_==顺时针填充矩阵==</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230726105509747.png" alt="image-20230726105509747" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>生成一个 n×n 空矩阵 mat，随后模拟整个向内环绕的填入过程：</p>
<ol>
<li><p>定义当前左右上下边界 left, right , up, down，初始值 num = 1，迭代终止值 tar = n * n；</p>
</li>
<li><p>当 num &lt;= tar 时，始终按照 从左到右 从上到下 从右到左 从下到上 填入顺序循环，每次填入后：</p>
<ul>
<li><p>执行 num += 1：得到下一个需要填入的数字；</p>
</li>
<li><p>更新边界：例如从左到右填完后，上边界 up += 1，相当于上边界向内缩 1。</p>
</li>
</ul>
</li>
<li><p><strong>使用num &lt;= tar而不是l &lt; r || t &lt; b作为迭代条件，是为了解决当n为奇数时，矩阵中心数字无法在迭代过程中被填充的问题。</strong></p>
</li>
</ol>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] generateMatrix1(<span class="type">int</span> n)&#123;</span><br><span class="line">    <span class="comment">//定义上下左右边界</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">0</span>, down = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 当前需要填充的数字</span></span><br><span class="line">    <span class="type">int</span>[][] res = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">while</span>(curNum &lt;= n * n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(up &lt;= down)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++)&#123;</span><br><span class="line">                res[up][i] = curNum;</span><br><span class="line">                curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            up++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> up; i &lt;= down; i++)&#123;</span><br><span class="line">                res[i][right] = curNum;</span><br><span class="line">                curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(up &lt;= down)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> right; i &gt;= left; i--)&#123;</span><br><span class="line">                res[down][i] = curNum;</span><br><span class="line">                curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            down--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> down; i &gt;= up; i--)&#123;</span><br><span class="line">                res[i][left] = curNum;</span><br><span class="line">                curNum++;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48.旋转图像"></a>48.旋转图像</h4><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230726112124532.png" alt="image-20230726112124532" style="zoom:80%;" align="left">



<p><strong>思路</strong></p>
<p>按正对角线交换数组元素，再翻转每行元素(或者按照正中间一列交换数组元素)</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727151224371.png" alt="image-20230727151224371" style="zoom:67%;" align="left">

<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230727151233692.png" alt="image-20230727151233692" style="zoom: 67%;" align="left">

<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">       <span class="comment">// 按主对角线交换元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n ; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[j][i];</span><br><span class="line">                matrix[j][i] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">// 每行翻转</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[i][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[i][n - j - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h3><h4 id="LRU-最近最久未使用淘汰算法"><a href="#LRU-最近最久未使用淘汰算法" class="headerlink" title="LRU 最近最久未使用淘汰算法"></a>LRU 最近最久未使用淘汰算法</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230807120926395.png" alt="image-20230807120926395"></p>
<p><strong>方法一：自定义方法实现 — 借助哈希链表按插入顺序排序的方式</strong></p>
<p><strong>算法描述</strong></p>
<p>首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key) </code>方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p>
<p>注意，get 和 put 方法必须都是 O(1) 的时间复杂度。</p>
<p><strong>算法设计</strong></p>
<p>分析上面的操作过程，要让 put 和 get 方法的时间复杂度为 O(1)，我们可以总结出 cache 这个数据结构必要的条件：</p>
<p>1、显然 cache 中的元素必须有时序，以区分最近使用的和久未使用的数据，当容量满了之后要删除最久未使用的那个元素腾位置。</p>
<p>2、我们要在 cache 中快速找某个 key 是否已存在并得到对应的 val；</p>
<p>3、每次访问 cache 中的某个 key，需要将这个元素变为最近使用的，也就是说 cache 要支持在任意位置快速插入和删除元素。</p>
<p>那么，什么数据结构同时符合上述条件呢？哈希表查找快，但是数据无固定顺序；链表有顺序之分，插入删除快，但是查找慢。所以结合一下，形成一种新的数据结构：哈希链表 LinkedHashMap。</p>
<p>LRU 缓存算法的核心数据结构就是哈希链表，双向链表和哈希表的结合体。这个数据结构长这样：</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; cache;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="comment">// 哈希链表的构造函数中有一个参数 accessOrder 其决定元素的存放顺序是按插入顺序还是读取顺序，默认值false为按照插入顺序</span></span><br><span class="line">        cache = <span class="keyword">new</span> <span class="title class_">LinkedHashMap</span>&lt;&gt;(); </span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(key)) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 元素被访问，需要修改其优先级</span></span><br><span class="line">        makeRecently(key);</span><br><span class="line">        <span class="keyword">return</span> cache.get(key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(cache.containsKey(key))&#123;</span><br><span class="line">            cache.put(key, value);</span><br><span class="line">            <span class="comment">// 元素被访问，需要修改其优先级</span></span><br><span class="line">            makeRecently(key);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cache.size() &gt;= capacity)&#123;</span><br><span class="line">            <span class="comment">// 链表头部就是最久未使用的 key</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">deleteKey</span> <span class="operator">=</span> cache.keySet().iterator().next();</span><br><span class="line">            cache.remove(deleteKey);</span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 将新的 key 添加链表尾部</span></span><br><span class="line">        cache.put(key, value);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeRecently</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="comment">// 删除 key，重新插入到队尾</span></span><br><span class="line">        cache.remove(key);</span><br><span class="line">        cache.put(key,val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>方式二 — 借助哈希链表按读取顺序排序</p>
<p><strong>LinkedHashMap介绍</strong></p>
<p><code>HashMap</code>的底层是 <strong>数组 + 链表 + 红黑树</strong>，同时其内部数据是无序。而<code>LinkedHashMap</code>相较于<code>HashMap</code>提供了<strong>数组元素有序</strong>的功能。</p>
<p>LinkedHashMap的有序可以按两种顺序排列，一种是按照 <strong>插入</strong>的顺序，一种是按照 <strong>读取</strong> 的顺序(题目的示例就是告诉我们要按照读取的顺序进行排序 )。而其内部是靠 建立一个<strong>双向链表</strong> 来维护这个顺序的，在每次插入、删除后，都会调用一个函数来进行 双向链表的维护 ，准确的来说，是有三个函数来做这件事，这三个函数都统称为 回调函数 ，这三个函数分别是：</p>
<ul>
<li><code>void afterNodeAccess(Node&lt;K,V&gt; p) &#123; &#125;</code> — 对于LRU无需改写<br>其作用就是在访问元素之后，将该元素放到双向链表的尾巴处(所以这个函数只有在按照读取的顺序的时候才会执行)，之所以提这个，是建议大家去看看，如何优美的实现在双向链表中将指定元素放入链尾！</li>
<li><code>void afterNodeRemoval(Node&lt;K,V&gt; p) &#123; &#125;</code> — 对于LRU无需改写<br>其作用就是在删除元素之后，将元素从双向链表中删除，还是非常建议大家去看看这个函数的，很优美的方式在双向链表中删除节点！</li>
<li><code>void afterNodeInsertion(boolean evict) &#123; &#125;</code> — 题目提供 capacity 变量，则移除元素的临界条件需要改写<br>这个才是我们题目中会用到的，在插入新元素之后，需要回调函数判断是否需要移除一直不用的某些元素！</li>
</ul>
<h4 id="LFU-最近最少使用淘汰算法"><a href="#LFU-最近最少使用淘汰算法" class="headerlink" title="LFU 最近最少使用淘汰算法"></a>LFU 最近最少使用淘汰算法</h4><p><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230807155530895.png" alt="image-20230807155530895"></p>
<p><strong>思路</strong></p>
<blockquote>
<p>从实现难度上来说，LFU 算法的难度大于 LRU 算法，因为 LRU 算法相当于把数据按照时间排序，这个需求借助链表很自然就能实现，你一直从链表头部加入元素的话，越靠近头部的元素就是新的数据，越靠近尾部的元素就是旧的数据，我们进行缓存淘汰的时候只要简单地将尾部的元素淘汰掉就行了。</p>
<p>而 LFU 算法相当于是淘汰访问频次最低的数据，如果访问频次最低的数据有多条，需要淘汰最旧的数据。把数据按照访问频次进行排序，而且频次还会不断变化，这可不容易实现。</p>
</blockquote>
<p>根据 LFU 算法的逻辑，我们先列举出算法执行过程中的几个显而易见的事实：</p>
<p>1、调用<code>get(key)</code>方法时，要返回该<code>key</code>对应的<code>val</code>。</p>
<p>2、只要用<code>get</code>或者<code>put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</p>
<p>3、如果在容量满了的时候进行插入，则需要将<code>freq</code>最小的<code>key</code>删除，如果最小的<code>freq</code>对应多个<code>key</code>，则删除其中最旧的那一个。</p>
<p>我们希望能够在 O(1) 的时间内解决这些需求，可以使用基本数据结构来逐个击破：</p>
<p><strong>1、</strong>使用一个<code>HashMap</code>存储<code>key</code>到<code>val</code>的映射，就可以快速计算<code>get(key)</code>。</p>
<blockquote>
<p>HashMap&lt;Integer, Integer&gt; keyToVal;</p>
</blockquote>
<p><strong>2、</strong>使用一个<code>HashMap</code>存储<code>key</code>到<code>freq</code>的映射，就可以快速操作<code>key</code>对应的<code>freq</code>。</p>
<blockquote>
<p>HashMap&lt;Integer, Integer&gt; keyToFreq;</p>
</blockquote>
<p><strong>3、</strong>这个需求应该是 LFU 算法的核心，所以我们分开说。</p>
<p><strong>3.1、</strong>首先，肯定是需要<code>freq</code>到<code>key</code>的映射，用来找到<code>freq</code>最小的<code>key</code>。</p>
<p><strong>3.2、</strong>将<code>freq</code>最小的<code>key</code>删除，那你就得快速得到当前所有<code>key</code>最小的<code>freq</code>是多少。想要时间复杂度 O(1) 的话，肯定不能遍历一遍去找，那就用一个变量<code>minFreq</code>来记录当前最小的<code>freq</code>吧。</p>
<p><strong>3.3、</strong>可能有多个<code>key</code>拥有相同的<code>freq</code>，所以 <strong><code>freq</code>对<code>key</code>是一对多的关系</strong>，即一个<code>freq</code>对应一个<code>key</code>的列表。</p>
<p><strong>3.4、</strong>希望<code>freq</code>对应的<code>key</code>的列表是<strong>存在时序</strong>的，便于快速查找并删除最旧的<code>key</code>。</p>
<p><strong>3.5、</strong>希望**能够快速删除<code>key</code>列表中的任何一个<code>key</code>**，因为如果频次为<code>freq</code>的某个<code>key</code>被访问，那么它的频次就会变成<code>freq+1</code>，就应该从<code>freq</code>对应的<code>key</code>列表中删除，加到<code>freq+1</code>对应的<code>key</code>的列表中。</p>
<blockquote>
<p>HashMap&lt;Integer, LinkedHashSet<Integer>&gt; freqToKeys;<br><strong>int</strong> minFreq = 0;</Integer></p>
</blockquote>
<p>介绍一下这个<code>LinkedHashSet</code>，它满足我们 3.3，3.4，3.5 这几个要求。你会发现普通的链表<code>LinkedList</code>能够满足 3.3，3.4 这两个要求，但是由于普通链表不能快速访问链表中的某一个节点，所以无法满足 3.5 的要求。</p>
<p><code>LinkedHashSet</code>顾名思义，是链表和哈希集合的结合体。链表不能快速访问链表节点，但是插入元素具有时序；哈希集合中的元素无序，但是可以对元素进行快速的访问和删除。</p>
<p>那么，它俩结合起来就兼具了哈希集合和链表的特性，既可以在 O(1) 时间内访问或删除其中的元素，又可以保持插入的时序，高效实现 3.5 这个需求。</p>
<p>综上：我们可以写出 LFU 算法的基本框架</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    <span class="comment">// key 到 val 的映射，我们后文称为 KV 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToVal;</span><br><span class="line">    <span class="comment">// key 到 freq 的映射，我们后文称为 KF 表</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    <span class="comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span></span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="comment">// 记录最小的频次</span></span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line">    <span class="comment">// 记录 LFU 缓存的最大容量</span></span><br><span class="line">    <span class="type">int</span> cap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        keyToVal = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.cap = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码框架</strong></p>
<p>LFU 的逻辑不难理解，但是写代码实现并不容易，我们要维护<code>KV</code>表，<code>KF</code>表，<code>FK</code>表三个映射，特别容易出错。我们需要搞清楚映射关系，如果我们更新了某个<code>key</code>对应的<code>freq</code>，那么就要同步修改<code>KF</code>表和<code>FK</code>表，这样才不会出问题。</p>
<p>下面我们先来实现<code>get(key)</code>方法，逻辑很简单，返回<code>key</code>对应的<code>val</code>，然后增加<code>key</code>对应的<code>freq</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!keyToVal.containsKey(key)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加 key 对应的 freq</span></span><br><span class="line">    increaseFreq(key);</span><br><span class="line">    <span class="keyword">return</span> keyToVal.get(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>增加<code>key</code>对应的<code>freq</code>是 LFU 算法的核心，所以我们干脆直接抽象成一个函数<code>increaseFreq</code>，这样<code>get</code>方法看起来就简洁清晰了对吧。</p>
<p>下面来实现<code>increaseFreq</code>函数：</p>
<p>更新某个<code>key</code>的<code>freq</code>肯定会涉及<code>FK</code>表和<code>KF</code>表，所以我们分别更新这两个表就行了。</p>
<p>当<code>FK</code>表中<code>freq</code>对应的列表被删空后，需要删除<code>FK</code>表中<code>freq</code>这个映射。如果这个<code>freq</code>恰好是<code>minFreq</code>，说明<code>minFreq</code>变量需要更新。</p>
<p>能不能快速找到当前的<code>minFreq</code>呢？这里是可以的，因为我们刚才把<code>key</code>的<code>freq</code>加了 1 嘛，所以<code>minFreq</code>也加 1 就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">increaseFreq</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> keyToFreq.get(key);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.put(key, freq + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    <span class="comment">// 将 key 从 freq 对应的列表中删除</span></span><br><span class="line">    freqToKeys.get(freq).remove(key);</span><br><span class="line">    <span class="comment">// 将 key 加入 freq + 1 对应的列表中</span></span><br><span class="line">    freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">    freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 如果 freq 对应的列表空了，移除这个 freq</span></span><br><span class="line">    <span class="keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(freq);</span><br><span class="line">        <span class="comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span></span><br><span class="line">        <span class="keyword">if</span> (freq == <span class="built_in">this</span>.minFreq) &#123;</span><br><span class="line">            <span class="built_in">this</span>.minFreq++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面来实现<code>put(key, val)</code>方法，逻辑略微复杂，我们直接画个图来看：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230807155704784.png" alt="image-20230807155704784" style="zoom:80%;" align="left">

<p>看图可以直接写出<code>put</code>方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 若 key 已存在，修改对应的 val 即可 */</span></span><br><span class="line">    <span class="keyword">if</span> (keyToVal.containsKey(key)) &#123;</span><br><span class="line">        keyToVal.put(key, val);</span><br><span class="line">        <span class="comment">// key 对应的 freq 加一</span></span><br><span class="line">        increaseFreq(key);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* key 不存在，需要插入 */</span></span><br><span class="line">    <span class="comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.cap &lt;= keyToVal.size()) &#123;</span><br><span class="line">        removeMinFreqKey();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 插入 key 和 val，对应的 freq 为 1 */</span></span><br><span class="line">    <span class="comment">// 插入 KV 表</span></span><br><span class="line">    keyToVal.put(key, val);</span><br><span class="line">    <span class="comment">// 插入 KF 表</span></span><br><span class="line">    keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 插入 FK 表</span></span><br><span class="line">    freqToKeys.putIfAbsent(<span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">    freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">    <span class="comment">// 插入新 key 后最小的 freq 肯定是 1</span></span><br><span class="line">    <span class="built_in">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现<code>removeMinFreqKey</code>函数：</p>
<p>删除某个键<code>key</code>肯定是要同时修改三个映射表的，借助<code>minFreq</code>参数可以从<code>FK</code>表中找到<code>freq</code>最小的<code>keyList</code>，根据时序，其中第一个元素就是要被淘汰的<code>deletedKey</code>，操作三个映射表删除这个<code>key</code>即可。</p>
<p>但是有个细节问题，如果<code>keyList</code>中只有一个元素，那么删除之后<code>minFreq</code>对应的<code>key</code>列表就为空了，也就是<code>minFreq</code>变量需要被更新。如何计算当前的<code>minFreq</code>是多少呢？</p>
<p>实际上没办法快速计算<code>minFreq</code>，只能线性遍历<code>FK</code>表或者<code>KF</code>表来计算，这样肯定不能保证 O(1) 的时间复杂度。</p>
<p><strong>但是，其实这里没必要更新<code>minFreq</code>变量</strong>，因为你想想<code>removeMinFreqKey</code>这个函数是在什么时候调用？在<code>put</code>方法中插入新<code>key</code>时可能调用。而你回头看<code>put</code>的代码，插入新<code>key</code>时一定会把<code>minFreq</code>更新成 1，所以说即便这里<code>minFreq</code>变了，我们也不需要管它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeMinFreqKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// freq 最小的 key 列表</span></span><br><span class="line">    LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="built_in">this</span>.minFreq);</span><br><span class="line">    <span class="comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">deletedKey</span> <span class="operator">=</span> keyList.iterator().next();</span><br><span class="line">    <span class="comment">/* 更新 FK 表 */</span></span><br><span class="line">    keyList.remove(deletedKey);</span><br><span class="line">    <span class="keyword">if</span> (keyList.isEmpty()) &#123;</span><br><span class="line">        freqToKeys.remove(<span class="built_in">this</span>.minFreq);</span><br><span class="line">        <span class="comment">// 问：这里需要更新 minFreq 的值吗？</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 更新 KV 表 */</span></span><br><span class="line">    keyToVal.remove(deletedKey);</span><br><span class="line">    <span class="comment">/* 更新 KF 表 */</span></span><br><span class="line">    keyToFreq.remove(deletedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>完整代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LFUCache</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; ketToVal;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; keyToFreq;</span><br><span class="line">    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</span><br><span class="line">    <span class="type">int</span> minFreq;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LFUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        ketToVal = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        keyToFreq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        freqToKeys = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!ketToVal.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        increasedFreq(key);</span><br><span class="line">        <span class="keyword">return</span> ketToVal.get(key);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increasedFreq</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">freq</span> <span class="operator">=</span> keyToFreq.get(key);</span><br><span class="line">        keyToFreq.put(key,freq + <span class="number">1</span>);</span><br><span class="line">        LinkedHashSet&lt;Integer&gt; keySet = freqToKeys.get(freq);</span><br><span class="line">        freqToKeys.putIfAbsent(freq + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(freq + <span class="number">1</span>).add(key);</span><br><span class="line">        keySet.remove(key);</span><br><span class="line">        <span class="keyword">if</span>(keySet.isEmpty())&#123;</span><br><span class="line">            freqToKeys.remove(freq);</span><br><span class="line">            <span class="keyword">if</span>(freq == <span class="built_in">this</span>.minFreq)&#123;</span><br><span class="line">                <span class="built_in">this</span>.minFreq++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ketToVal.containsKey(key))&#123;</span><br><span class="line">            increasedFreq(key);</span><br><span class="line">            ketToVal.put(key,value);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ketToVal.size() &gt;= <span class="built_in">this</span>.capacity)&#123;</span><br><span class="line">            removeMinFreqKey();</span><br><span class="line">        &#125;</span><br><span class="line">        freqToKeys.putIfAbsent(<span class="number">1</span>,<span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;());</span><br><span class="line">        freqToKeys.get(<span class="number">1</span>).add(key);</span><br><span class="line">        ketToVal.put(key,value);</span><br><span class="line">        keyToFreq.put(key, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.minFreq = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeMinFreqKey</span><span class="params">()</span>&#123;</span><br><span class="line">        LinkedHashSet&lt;Integer&gt; keySet = freqToKeys.get(<span class="built_in">this</span>.minFreq);</span><br><span class="line">        <span class="type">int</span> <span class="variable">deleteKey</span> <span class="operator">=</span> keySet.iterator().next();</span><br><span class="line">        keySet.remove(deleteKey);</span><br><span class="line">        <span class="keyword">if</span>(keySet.isEmpty())&#123;</span><br><span class="line">            freqToKeys.remove(keySet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ketToVal.remove(deleteKey);</span><br><span class="line">        keyToFreq.remove(deleteKey);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LFUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LFUCache obj = new LFUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>



























<h2 id="10-零散专题总结"><a href="#10-零散专题总结" class="headerlink" title="10.零散专题总结"></a>10.零散专题总结</h2><h3 id="Pow-x-n-—-快速幂"><a href="#Pow-x-n-—-快速幂" class="headerlink" title="Pow(x, n) — 快速幂"></a>Pow(x, n) — 快速幂</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230825155900535.png" alt="image-20230825155900535" style="zoom:80%;" align="left">



<p>思路 — 快速幂</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230825160228539.png" alt="image-20230825160228539" style="zoom: 67%;" align="left">

<p>步骤：</p>
<p>例如求 x<del>0</del> 的9次方，9 的二进制为 1001。令 b  = 1001，初始状态 x = x<del>0</del>。</p>
<p>我们在while循环依次访问 b 的最后一位。</p>
<p>当前循环，b为 1001，最后一位为 1，则 **res *= x**。使x *= x，即x = x<del>0</del>^2^。b右移变成 100。进入下一次循环</p>
<p>当前循环，b为 100，最后一位为0。 res不操作。使x *= x，即x = x<del>0</del>^4^。b右移变成10。进入下一次循环</p>
<p>当前循环，b为 10，最后一位为0。 res不操作。使x *= x，即x = x<del>0</del>^8^。b变成1。进入下一次循环</p>
<p>当前循环，b为 1，最后一位为 1，则 **res *= x**。使x *= x，即x = x<del>0</del>^16^。b右移变成0。循环结束。</p>
<p>注意到：x^9^ = x^8+1^ = x^8^*x^1^。而我们的res在 x取x<del>0</del> 和 x取x<del>0</del>^8^时分别进行了一次操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0.0d</span>) <span class="keyword">return</span> <span class="number">0.0d</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>)&#123; <span class="comment">// 如果 b &lt; 0，则需要对x取倒数。因为 x ^（-2） =  (1/x)^2</span></span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;<span class="comment">// x取倒数后，b需要变成正数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>( b &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x; <span class="comment">// 最后一位为 1，则res需要操作</span></span><br><span class="line">            x *= x; <span class="comment">// x取平方</span></span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>; <span class="comment">// b右移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="筛素数-—-埃及筛"><a href="#筛素数-—-埃及筛" class="headerlink" title="筛素数 — 埃及筛"></a>筛素数 — 埃及筛</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230827160607800.png" alt="image-20230827160607800" style="zoom:67%;" align="left">



<p><strong>方法 — 埃及筛</strong></p>
<p>1.初始化长度为 n 的标记数组，数组初始化都为 true，表示当前所有数都为质数。</p>
<p>2.从 2 开始将当前数组的倍数全部标记为 合数(非素数)。标记到 $\sqrt{n}$ 时即可。过程如下：</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/1606932458-HgVOnW-Sieve_of_Eratosthenes_animation.gif" alt="Sieve_of_Eratosthenes_animation.gif" style="zoom:80%;" align="left">

<p>注意：每次查找当前素数 x 的倍数时，从 x^2^ 开始即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">    Arrays.fill(isPrime, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 从 2 开始枚举到 sqrt(n)</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i * i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 如果当前元素是素数</span></span><br><span class="line">        <span class="keyword">if</span>(isPrime[i])&#123;</span><br><span class="line">            <span class="comment">// 从 i*i开始，将 i 的倍数都设置为非素数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i * i; j &lt; n; j += i) isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计数，注意 1 既不是素数也不是合数。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(isPrime[i]) res++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="11-排序算法"><a href="#11-排序算法" class="headerlink" title="11.排序算法"></a>11.排序算法</h2><h3 id="1-快速排序-—-不稳定"><a href="#1-快速排序-—-不稳定" class="headerlink" title="1.快速排序 — 不稳定"></a>1.快速排序 — 不稳定</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] nums = &#123;<span class="number">11</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">Qsort(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> num : nums)&#123;</span><br><span class="line">   System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">Qsort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">       <span class="comment">// 数组长度为 1 时，退出递归</span></span><br><span class="line">       <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> ;</span><br><span class="line">       <span class="comment">// 防止遇到正序或逆序数组等极端情况， 随机将最左边元素与中间元素交换</span></span><br><span class="line">       swap(nums, left, (left + right) / <span class="number">2</span>);</span><br><span class="line">       <span class="comment">// 取数组最左边的数为基准元素</span></span><br><span class="line">       <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left;</span><br><span class="line">       <span class="type">int</span> <span class="variable">le</span> <span class="operator">=</span> left + <span class="number">1</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">re</span> <span class="operator">=</span> right;</span><br><span class="line">       <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">              <span class="comment">//使用&lt;=，最后 re 位于小于pivot那部分最后一个元素位置，le位于大于pivot那部分第一个元素</span></span><br><span class="line">               <span class="keyword">while</span>(le &lt;= re &amp;&amp; nums[le] &lt; nums[pivot]) le++;</span><br><span class="line">               <span class="keyword">while</span>(le &lt;= re &amp;&amp; nums[pivot] &lt; nums[re]) re--;</span><br><span class="line">               <span class="keyword">if</span>(le &gt; re) <span class="keyword">break</span>;</span><br><span class="line">               swap(nums, le,re);</span><br><span class="line">               <span class="comment">// 数组中存在重复元素时，交换完毕后需要修改下标，否则会陷入死循环</span></span><br><span class="line">               le++;</span><br><span class="line">               re--;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 执行完毕后 re位于小于pivot那部分最后一个元素位置，le位于大于pivot那部分第一个元素</span></span><br><span class="line">       swap(nums, pivot, re);</span><br><span class="line">       pivot = re;</span><br><span class="line">       <span class="comment">// 继续对左右部分进行递归快排</span></span><br><span class="line">       Qsort(nums, left, pivot - <span class="number">1</span>);</span><br><span class="line">       Qsort(nums, pivot + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[a];</span><br><span class="line">       nums[a] = nums[b];</span><br><span class="line">       nums[b] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-归并排序-先分割后合并-—-稳定"><a href="#2-归并排序-先分割后合并-—-稳定" class="headerlink" title="2.归并排序(先分割后合并) — 稳定"></a>2.归并排序(先分割后合并) — 稳定</h3><img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230924193550226.png" alt="image-20230924193550226" style="zoom:50%;" align="left">

<h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] temp; <span class="comment">// 辅助数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    temp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    mergeSort(<span class="number">0</span>, n - <span class="number">1</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 分割 得到各自有序的两个子数组</span></span><br><span class="line">    mergeSort(left, mid, nums);</span><br><span class="line">    mergeSort(mid + <span class="number">1</span>, right, nums);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并 有序的两个子数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) temp[i] = nums[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">l1</span> <span class="operator">=</span> left, l2 = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> left;</span><br><span class="line">    <span class="keyword">while</span>(index &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 &gt; mid) nums[index++] = temp[l2++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(l2 &gt; right) nums[index++] = temp[l1++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(temp[l1] &lt;= temp[l2]) nums[index++] = temp[l1++];</span><br><span class="line">        <span class="keyword">else</span> nums[index++] = temp[l2++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return nums;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="链表归并"><a href="#链表归并" class="headerlink" title="链表归并"></a>链表归并</h4><blockquote>
<p>注意：归并排序取快慢指针时，fast和slow不能从同一个节点开始，两种方式：</p>
<p>1.加入空头结点，二者都从空头结点开始</p>
<p>2.slow = head， fast= head.next</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ----- 分割 -----</span></span><br><span class="line">    <span class="comment">// fast取head时会栈溢出</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next, slow = head;</span><br><span class="line">    <span class="comment">// 找到链表的中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast!= <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将链表拆成两半</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> slow.next;</span><br><span class="line">    slow.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 左右继续递归</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> sortList(head);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> sortList(temp);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> h;</span><br><span class="line">     <span class="comment">// ----- 合并 -----</span></span><br><span class="line">    <span class="comment">// 合并两个有序链表</span></span><br><span class="line">    <span class="keyword">while</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (left.val &lt; right.val)&#123;</span><br><span class="line">            h.next = left;</span><br><span class="line">            left = left.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h.next = right;</span><br><span class="line">            right = right.next;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    h.next = left != <span class="literal">null</span> ? left : right;</span><br><span class="line">    <span class="keyword">return</span> res.next;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="3-堆排序-–-不稳定"><a href="#3-堆排序-–-不稳定" class="headerlink" title="3.堆排序 – 不稳定"></a>3.堆排序 – 不稳定</h3><blockquote>
<p>升序排序：构建大顶堆，大根堆堆顶为最大元素，每次将堆元素与数组无序部分的最后一个元素进行交换，使当前最大元素移动到应该在的位置，而堆由于新的堆顶元素不是最大，又会调整堆结构，找到新的最大元素使其移动到堆顶。</p>
</blockquote>
<p>堆逻辑上是一棵完全二叉树<br><strong>其任何一非叶节点的关键字不大于或者不小于其左右孩子节点的关键字。</strong><br>大顶堆：堆的每个父节点都大于其孩子节点，因此根节点为堆中最大值；<br>小顶堆：堆的每个父节点都小于其孩子节点，根节点为堆中最小值；</p>
<p><strong>堆的存储</strong>：</p>
<p>一般都用数组来表示堆，i结点的父结点下标就为(i – 1) / 2。它的左右子结点下标分别为2 * i+1和2 * i + 2。<br>如下为堆和其数组的表达(堆的根节点以下标0开始，层序遍历)</p>
<p><strong>建堆</strong></p>
<p>给定一个无序数组，将其转化为大顶堆(堆顶元素为数组最大元素)</p>
<img src="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/image-20230924233657493.png" alt="image-20230924233657493" style="zoom:50%;" align="left">

<p>堆排序思想：</p>
<p>将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样根节点会是n个元素中的次小值，将其与n-1的元素互换，剩下n-2个元素继续建堆。如此反复执行，便能得到一个有序序列了。(反之，降序则建立小顶堆)</p>
<p>总结下堆排序的基本思路：<br>　　a.将无序序列构建成一个堆，根据升序(大根堆) 降序(小根堆)需求选择对应堆结构;<br>　　b.将堆顶元素与末尾元素交换，将最大(小)元素”沉”到数组末端;<br>　　c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。</p>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用大根堆实现升序数组，每次找到数组中最大的元素将其浮到堆顶，然后换到数组最后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// 建堆，使数组满足大根堆的要求，父节点的值比左右子节点大</span></span><br><span class="line">    <span class="comment">// 只需要遍历 0 ~ len / 2 - 1的位置即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        adjust(nums, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次堆顶元素即可当前数组中的最大值，将其移动到未排序部分的最后即可</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">        <span class="comment">// 交换堆顶元素与当前无序数组部分的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">        nums[i] = temp;</span><br><span class="line">        <span class="comment">// 继续调整堆结构，找到当前部分的最大值</span></span><br><span class="line">        adjust(nums, <span class="number">0</span>, i);<span class="comment">// 注意堆大小为i，i之后的部分已经有序。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">adjust</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxIndex</span> <span class="operator">=</span> index;</span><br><span class="line">    <span class="comment">// 找到父节点，左节点，右节点中的最小值的索引</span></span><br><span class="line">    <span class="keyword">if</span>(l &lt; len &amp;&amp; nums[l] &gt; nums[maxIndex])&#123;<span class="comment">// 左节点小于父节点</span></span><br><span class="line">        maxIndex = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; len &amp;&amp; nums[r] &gt; nums[maxIndex])&#123;</span><br><span class="line">        maxIndex = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(maxIndex != index)&#123;<span class="comment">// 最小节点不是父节点，则交换父节点与最小节点的数据，使其满足堆结构</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[maxIndex];</span><br><span class="line">        nums[maxIndex] = nums[index];</span><br><span class="line">        nums[index] = temp;</span><br><span class="line"></span><br><span class="line">        adjust(nums, maxIndex, len);<span class="comment">// 继续调整最小子节点的所在节点的结构</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="n2排序"><a href="#n2排序" class="headerlink" title="n2排序"></a>n2排序</h3><h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><p>思路：每一轮选取未排定的部分中<strong>最小</strong>的部分交换到未排定部分的末尾，经过若干个步骤，就能排定整个数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; nums.length)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; nums[min]) min = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        nums[index] = nums[min];</span><br><span class="line">        nums[min] = temp;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="插入排序-—-稳定"><a href="#插入排序-—-稳定" class="headerlink" title="插入排序 — 稳定"></a>插入排序 — 稳定</h4><p>思路：每次将后半无序部分的一个数字插入前面有序部分的数组中，成为一个长度更长的有序数组，有限次操作以后，数组整体有序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp)&#123;</span><br><span class="line">            nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h4 id="冒泡排序-—-稳定"><a href="#冒泡排序-—-稳定" class="headerlink" title="冒泡排序 — 稳定"></a>冒泡排序 — 稳定</h4><p>基本思想：外层循环每一次经过两两比较，把每一轮无序数组中最小的元素放到了有序数组的末尾；<br>「冒泡排序」有个特点：在遍历的过程中，如果提前检测到数组是有序的，从而结束排序，而不像「选择排序」那样，即使输入数据是有序的，「选择排序」依然需要「傻乎乎」地走完所有的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sorted</span> <span class="operator">=</span> <span class="literal">true</span>;<span class="comment">// 是否发生过交换的标记</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> n - <span class="number">1</span>; j &gt; i; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; nums[j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">                nums[j - <span class="number">1</span>] = temp;</span><br><span class="line">                sorted = <span class="literal">false</span>;<span class="comment">// 发生一次交换则说明当前无序部分不是有序的</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sorted) <span class="keyword">break</span>;<span class="comment">// 如果遍历完无序部分为发生过排序，则说明无序部分是有序的，从而说明整个数组已经全部有序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>摘要提到是港区火车</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="http://example.com">milklatte</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="http://example.com/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/">http://example.com/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2024/04/29/Leetcode-%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98-1/" title="Leetc-图论专题-1"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next</div><div class="next_info">Leetc-图论专题-1</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">milklatte</div><div class="author-info__description">争取35岁退休</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/milklattee"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/milklattee" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:1030653994@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-number">1.</span> <span class="toc-text">算法与数据结构总结篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0-%E5%88%B7%E9%A2%98%E8%BF%9B%E5%BA%A6"><span class="toc-number">1.1.</span> <span class="toc-text">0.刷题进度</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%95%B0%E7%BB%84%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93-%E4%BA%8C%E5%88%86%EF%BC%8C%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%8C%E5%89%8D%E7%BC%80%E5%92%8C%EF%BC%8C%E5%B7%AE%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">1.数组专题总结(二分，滑动窗口，前缀和，差分)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E4%BA%8C%E5%88%86%E6%A8%A1%E7%89%88%E9%80%89%E7%94%A8-%E5%B7%A6%E9%97%AD%E5%8F%B3%E9%97%AD"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">方法论 — 二分模版选用&#x3D;&#x3D;左闭右闭&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-%E5%9F%BA%E6%9C%AC%E4%BA%8C%E5%88%86"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">704.二分查找_&#x3D;&#x3D;基本二分&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-%E6%9F%A5%E6%89%BE%E5%B7%A6%E5%8F%B3%E8%BE%B9%E7%95%8C"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">34. 在排序数组中查找元素的第一个和最后一个位置_&#x3D;&#x3D;查找左右边界&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#153-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-%E5%9C%A8%E4%B8%8D%E9%87%8D%E5%A4%8D%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">153. 寻找旋转排序数组中的最小值_&#x3D;&#x3D;在不重复旋转数组查找最小值&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#154-%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-%E5%9C%A8%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BE%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">154. 寻找旋转排序数组中的最小值_&#x3D;&#x3D;在存在重复元素的旋转数组查找最小值&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-%E5%9C%A8%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E6%9F%A5%E6%89%BEtarget"><span class="toc-number">1.2.1.6.</span> <span class="toc-text">33.搜索旋转排序数组_&#x3D;&#x3D;在旋转数组查找target&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%AF%BB%E6%89%BE%E7%AC%ACK%E4%B8%AA%E6%95%B0"><span class="toc-number">1.2.1.7.</span> <span class="toc-text">4.寻找两个有序数组的中位数_&#x3D;&#x3D;二分查找寻找第K个数&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#162-%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC"><span class="toc-number">1.2.1.8.</span> <span class="toc-text">162.寻找峰值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 双指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%E2%80%94-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">双指针—&#x3D;&#x3D;快慢指针&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8D%95%E7%9B%AE%E6%A0%87%E5%A4%B4%E9%83%A8%E5%BC%80%E5%A7%8B%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">27.移除元素_&#x3D;&#x3D;单目标头部开始双指针&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#844-%E6%AF%94%E8%BE%83%E5%90%AB%E9%80%80%E6%A0%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%A4%9A%E7%9B%AE%E6%A0%87%E5%B0%BE%E9%83%A8%E5%BC%80%E5%A7%8B%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">844.比较含退格的字符串_&#x3D;&#x3D;多目标尾部开始双指针&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9-%E9%A6%96%E5%B0%BE%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">977.有序数组的平方_&#x3D;&#x3D;首尾双指针&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E7%9B%9B%E6%B0%B4%E6%9C%80%E5%A4%9A%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">11.盛水最多的容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E6%B3%A8%E6%84%8F%E7%BB%93%E6%9E%9C%E5%88%A4%E6%96%AD%E7%9A%84%E8%BE%B9%E7%95%8C%E6%83%85%E5%86%B5"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2 滑动窗口_&#x3D;&#x3D;注意结果判断的边界情况&#x3D;&#x3D;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">代码框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">209.长度最小的子数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1658-%E5%B0%86-x-%E5%87%8F%E5%88%B0-0-%E7%9A%84%E6%9C%80%E5%B0%8F%E6%93%8D%E4%BD%9C%E6%95%B0"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">1658.将 x 减到 0 的最小操作数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">239.滑动窗口最大值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">904.水果成篮</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#76-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">76.最小覆盖子串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#567-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%88%97"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">567.字符串排列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-%E5%89%8D%E7%BC%80%E5%92%8C-%E6%B1%82%E4%BB%BB%E6%84%8F%E5%8C%BA%E9%97%B4%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.2.4.</span> <span class="toc-text">1.3 - 1 前缀和_求任意区间的区间和</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E6%95%B0%E7%BB%84%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">方法论 — 数组前缀和</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1590-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABp%E6%95%B4%E9%99%A4-%E5%89%8D%E7%BC%80%E5%92%8C-%E5%93%88%E5%B8%8C%E6%B1%82%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%8F%96%E4%BD%99"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">1590.使数组和能被p整除_前缀和+哈希求两数之和+取余</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1139-%E6%9C%80%E5%A4%A7%E7%9A%84%E4%BB%A51%E4%B8%BA%E8%BE%B9%E7%95%8C%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2-%E2%80%94-%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BA%8C%E4%BD%8D%E6%95%B0%E7%BB%84%E5%AF%B9%E6%AF%8F%E8%A1%8C%E6%AF%8F%E5%88%97%E6%B1%82%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">1139.最大的以1为边界的正方形 — &#x3D;&#x3D;二维前缀和&#x3D;&#x3D;(二位数组对每行每列求前缀和)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#304-%E4%BA%8C%E7%BB%B4%E5%8C%BA%E5%9F%9F%E5%92%8C%E6%A3%80%E7%B4%A2-%E2%80%94-%E7%9F%A9%E9%98%B5%E5%89%8D%E7%BC%80%E5%92%8C-%E5%8E%9F%E7%82%B9%E5%88%B0%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E5%92%8C"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">304.二维区域和检索 — &#x3D;&#x3D;矩阵前缀和&#x3D;&#x3D;(原点到当前位置的子矩阵和)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#528-%E6%8C%89%E6%9D%83%E9%87%8D%E9%9A%8F%E6%9C%BA%E9%80%89%E6%8B%A9-%E2%80%94-%E5%89%8D%E7%BC%80%E5%92%8C-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">528.按权重随机选择 — 前缀和+ 二分查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84-%E2%80%94-%E6%B1%82%E5%8F%AF%E5%8F%98%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E9%97%B4%E5%92%8C"><span class="toc-number">1.2.5.</span> <span class="toc-text">1.3 - 2 树状数组 — 求可变数组的区间和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-3-%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.2.6.</span> <span class="toc-text">1.3-3 线段树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.7.</span> <span class="toc-text">1.3 - 总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B7%AE%E5%88%86-%E2%80%94-%E5%AF%B9%E6%95%B0%E7%BB%84%E8%BF%9E%E7%BB%AD%E5%8C%BA%E9%97%B4%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%87%8F"><span class="toc-number">1.2.8.</span> <span class="toc-text">1.4 差分 — 对数组连续区间同时进行增减</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">方法论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%88%AA%E7%8F%AD%E9%A2%84%E5%AE%9A%E7%BB%9F%E8%AE%A1-%E2%80%94-%E5%B7%AE%E5%88%86%E6%95%B0%E7%BB%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">航班预定统计 — 差分数组的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E9%9B%B6%E6%95%A3"><span class="toc-number">1.2.9.</span> <span class="toc-text">1.5 零散</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#915-%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">915.分割数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97-%E2%80%94-%E6%95%B0%E7%BB%84%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">31.下一个排列 — 数组字典序的下一个排列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0-%E2%80%94-%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-number">1.2.9.3.</span> <span class="toc-text">41.缺失的第一个正数 — 原地哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#442-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0-%E2%80%94-%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-number">1.2.9.4.</span> <span class="toc-text">442.数组中重复的元素 — 原地哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#448-%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%80%E6%9C%89%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-%E2%80%94-%E5%8E%9F%E5%9C%B0%E5%93%88%E5%B8%8C"><span class="toc-number">1.2.9.5.</span> <span class="toc-text">448.找到数组中所有消失的数字 — 原地哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#43-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98"><span class="toc-number">1.2.9.6.</span> <span class="toc-text">43.字符串相乘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#581-%E6%9C%80%E7%9F%AD%E6%97%A0%E5%BA%8F%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.2.9.7.</span> <span class="toc-text">581.最短无序连续子数组</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">2.链表专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 理论知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0-%E2%80%94-%E8%99%9A%E6%8B%9F%E5%A4%B4%E8%8A%82%E7%82%B9dummy"><span class="toc-number">1.3.2.</span> <span class="toc-text">203.移除链表元素 — 虚拟头节点dummy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206-%E5%8F%8D%E8%BD%AC%E6%95%B4%E4%B8%AA%E9%93%BE%E8%A1%A8-%E2%80%94-%E5%8F%8D%E8%BD%AC%E5%85%A8%E9%83%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">206.反转整个链表 — 反转全部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92-%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86%E9%93%BE%E8%A1%A8-%E2%80%94-%E5%8F%8D%E8%BD%AC%E9%83%A8%E5%88%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">92.反转部分链表 — 反转部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8-%E2%80%93-%E6%AF%8Fk%E4%B8%AA%E5%8F%8D%E8%BD%AC"><span class="toc-number">1.3.5.</span> <span class="toc-text">25.k个一组翻转链表 – 每k个反转</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E8%8A%82%E7%82%B9-%E2%80%94-%E6%AF%8F%E4%B8%A4%E4%B8%AA%E5%8F%8D%E8%BD%AC%EF%BC%8C-%E7%AD%89%E4%BB%B7%E4%BA%8E%E4%B8%8A%E9%A2%98%E4%B8%ADk-2"><span class="toc-number">1.3.6.</span> <span class="toc-text">24.两两交换链表节点 — 每两个反转，&#x3D;&#x3D;等价于上题中k&#x3D;2&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.3.7.</span> <span class="toc-text">19.删除链表的倒数第 N 个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%9802-07-%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4-%E2%80%94-%E9%93%BE%E8%A1%A8%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.3.8.</span> <span class="toc-text">面试题02.07 链表相交 — 链表连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II-%E2%80%94-%E6%89%BE%E7%8E%AF%E5%85%A5%E5%8F%A3"><span class="toc-number">1.3.9.</span> <span class="toc-text">142.环形链表II — 找环入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E6%8E%92%E5%BA%8F-%E2%80%94-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.3.10.</span> <span class="toc-text">链表排序 — 归并排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E5%90%88%E5%B9%B6-k-%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">1.3.11.</span> <span class="toc-text">23.合并 k 个链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.</span> <span class="toc-text">3.二叉树专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E4%BF%9D%E5%AD%98%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%99%AE%E9%80%9A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">方法论-两个数组保存不含重复元素的普通二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%A3%E9%A2%98%E6%80%9D%E7%BB%B4%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.2.</span> <span class="toc-text">&#x3D;&#x3D;0.二叉树解题思维模式&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86"><span class="toc-number">1.4.3.</span> <span class="toc-text">1. 二叉树的递归与非递归遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-%E2%80%94-%E5%80%9F%E5%8A%A9%E6%A0%88"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.1 先序遍历 — 借助栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E2%80%94-%E5%80%9F%E5%8A%A9%E6%A0%88"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.2 后序遍历 — 借助栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E2%80%94-%E5%80%9F%E5%8A%A9%E6%A0%88"><span class="toc-number">1.4.6.</span> <span class="toc-text">1.3 中序遍历 — 借助栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-%E2%80%94-%E5%80%9F%E5%8A%A9%E9%98%9F%E5%88%97"><span class="toc-number">1.4.7.</span> <span class="toc-text">1.4 层序遍历 — 借助队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%85%88%E5%BA%8F%E9%80%92%E5%BD%92-dfs-%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.8.</span> <span class="toc-text">2.先序递归(dfs)解决问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.9.</span> <span class="toc-text">翻转二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84"><span class="toc-number">1.4.10.</span> <span class="toc-text">二叉树的所有路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%90%8E%E5%BA%8F%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.11.</span> <span class="toc-text">3. 后序递归解决问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-%E2%80%94-%E9%87%8D%E7%82%B9"><span class="toc-number">1.4.12.</span> <span class="toc-text">平衡二叉树 — 重点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">1.4.13.</span> <span class="toc-text">完全二叉树结点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%A4%9A%E6%A0%91%E9%80%92%E5%BD%92"><span class="toc-number">1.4.14.</span> <span class="toc-text">4.多树递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91"><span class="toc-number">1.4.15.</span> <span class="toc-text">相同的树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E5%A4%96%E4%B8%80%E9%A2%97%E6%A0%91%E7%9A%84%E5%AD%90%E6%A0%91"><span class="toc-number">1.4.16.</span> <span class="toc-text">另外一颗树的子树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.17.</span> <span class="toc-text">树的子结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.18.</span> <span class="toc-text">对称二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="toc-number">1.4.19.</span> <span class="toc-text">5.填充每一个节点的下一个右侧节点指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%B9%B3%E4%B8%BA%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.20.</span> <span class="toc-text">6.二叉树展平为链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.21.</span> <span class="toc-text">7.根据前序和中序构建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B9%E6%8D%AE%E5%89%8D%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.22.</span> <span class="toc-text">根据前序和后序构建二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.23.</span> <span class="toc-text">8.序列化与反序列化二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0"><span class="toc-number">1.4.24.</span> <span class="toc-text">寻找重复的数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.4.25.</span> <span class="toc-text">9.验证二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A0%A1%E9%AA%8C-%E9%AA%8C%E8%AF%81%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.4.26.</span> <span class="toc-text">二叉树的完全性校验(验证完全二叉树)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.4.27.</span> <span class="toc-text">10.不同的二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%BC%95%E5%AD%90%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-number">1.4.28.</span> <span class="toc-text">11. 引子：如何在二叉树中寻找一个元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-%E2%80%94-%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="toc-number">1.4.29.</span> <span class="toc-text">二叉树的最近公共祖先 — 两个节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%951%EF%BC%9A%E8%8B%A5%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A%E8%8A%82%E7%82%B9%E7%9A%84LCA%E5%91%A2"><span class="toc-number">1.4.30.</span> <span class="toc-text">扩展1：若寻找两个以上节点的LCA呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%952%EF%BC%9A%E8%8B%A5p%EF%BC%8Cq%E9%9C%80%E8%A6%81%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8%EF%BC%8C%E5%90%A6%E5%88%99%E8%BF%94%E5%9B%9Enull%EF%BC%9F"><span class="toc-number">1.4.31.</span> <span class="toc-text">扩展2：若p，q需要同时存在，否则返回null？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%953%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="toc-number">1.4.32.</span> <span class="toc-text">扩展3：二叉搜索树的最近公共祖先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AE%A1%E7%AE%97%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-number">1.4.33.</span> <span class="toc-text">12.计算完全二叉树节点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.4.34.</span> <span class="toc-text">13.二叉树的最大路径和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="toc-number">1.4.35.</span> <span class="toc-text">14.二叉树的直径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.5.</span> <span class="toc-text">4.动态规划专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E5%9F%BA%E6%9C%ACdp"><span class="toc-number">1.5.1.</span> <span class="toc-text">&#x3D;&#x3D;1&#x3D;&#x3D;.方法论 — 基本dp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.5.2.</span> <span class="toc-text">70.爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#746-%E4%BD%BF%E7%94%A8%E6%9C%80%E5%B0%8F%E8%8A%B1%E8%B4%B9%E7%88%AC%E6%A5%BC%E6%A2%AF"><span class="toc-number">1.5.3.</span> <span class="toc-text">746.使用最小花费爬楼梯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E8%B7%AF"><span class="toc-number">1.5.4.</span> <span class="toc-text">62.不同路径(机器人走路)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84II-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E8%B7%AF%E5%B8%A6%E9%9A%9C%E7%A2%8D"><span class="toc-number">1.5.5.</span> <span class="toc-text">63.不同路径II(机器人走路带障碍)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#343-%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">1.5.6.</span> <span class="toc-text">343.整数拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-01%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.7.</span> <span class="toc-text">&#x3D;&#x3D;2&#x3D;&#x3D;.方法论 — 01背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86"><span class="toc-number">1.5.8.</span> <span class="toc-text">分割等和子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1049-%E6%9C%80%E5%90%8E%E4%B8%80%E5%9D%97%E7%9F%B3%E5%A4%B4%E7%9A%84%E9%87%8D%E9%87%8FII"><span class="toc-number">1.5.9.</span> <span class="toc-text">1049.最后一块石头的重量II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#494-%E7%9B%AE%E6%A0%87%E5%92%8C"><span class="toc-number">1.5.10.</span> <span class="toc-text">494.目标和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%92%8C%E9%9B%B6"><span class="toc-number">1.5.11.</span> <span class="toc-text">一和零</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.12.</span> <span class="toc-text">&#x3D;&#x3D;3&#x3D;&#x3D;.方法论 — 完全背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2-%E2%80%94-%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%B1%82-%E8%A7%A3%E7%9A%84%E6%9E%81%E5%80%BC"><span class="toc-number">1.5.13.</span> <span class="toc-text">103.零钱兑换 — 完全背包求 解的极值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#279-%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="toc-number">1.5.14.</span> <span class="toc-text">279.完全平方数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#518-%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2II-%E2%80%94%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%B1%82%E7%BB%84%E5%90%88%E8%A7%A3%E4%B8%AA%E6%95%B0%E2%80%94%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98%E5%A4%96%E7%89%A9%E5%93%81%E5%86%85%E8%83%8C%E5%8C%85%EF%BC%8C%E5%8D%B3%E5%85%88%E6%8A%8A%E7%89%A9%E5%93%81%E5%9B%BA%E5%AE%9A"><span class="toc-number">1.5.15.</span> <span class="toc-text">518.零钱兑换II —完全背包求组合解个数—组合问题外物品内背包，即先把物品固定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98IV%E2%80%94%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%B1%82%E6%8E%92%E5%88%97%E8%A7%A3%E4%B8%AA%E6%95%B0%E2%80%94%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E5%A4%96%E8%83%8C%E5%8C%85%E5%86%85%E7%89%A9%E5%93%81%EF%BC%8C%E5%8D%B3%E5%85%88%E6%8A%8A%E8%83%8C%E5%8C%85%E5%9B%BA%E5%AE%9A"><span class="toc-number">1.5.16.</span> <span class="toc-text">104.组合问题IV—完全背包求排列解个数—排列问题外背包内物品，即先把背包固定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70-%E7%88%AC%E6%A5%BC%E6%A2%AF-%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E6%B1%82%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.17.</span> <span class="toc-text">70.爬楼梯(转化为完全背包求排列问题)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86"><span class="toc-number">1.5.18.</span> <span class="toc-text">139.单词拆分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85"><span class="toc-number">1.5.19.</span> <span class="toc-text">&#x3D;&#x3D;4&#x3D;&#x3D;.方法论 — 多重背包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E5%8C%85%E7%B3%BB%E5%88%97%E7%BB%93%E6%9D%9F"><span class="toc-number">1.5.20.</span> <span class="toc-text">背包系列结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E7%8A%B6%E6%80%81DP"><span class="toc-number">1.5.21.</span> <span class="toc-text">&#x3D;&#x3D;5&#x3D;&#x3D;.方法论 — 状态DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D-%E2%80%94-%E7%8A%B6%E6%80%81DP"><span class="toc-number">1.5.22.</span> <span class="toc-text">打家劫舍 — 状态DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DII-%E2%80%94-%E7%8E%AF%E5%BD%A2DP%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%A4%E6%AC%A1%E7%BA%BF%E6%80%A7DP"><span class="toc-number">1.5.23.</span> <span class="toc-text">打家劫舍II — 环形DP转换为两次线性DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8DIII-%E2%80%94-%E6%A0%91%E5%BD%A2DP%E5%85%A5%E9%97%A8"><span class="toc-number">1.5.24.</span> <span class="toc-text">打家劫舍III — 树形DP入门</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-%E4%B9%B0%E5%8D%96%E4%B8%80%E6%AC%A1"><span class="toc-number">1.5.25.</span> <span class="toc-text">买卖股票的最佳时机(买卖一次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAII-%E5%A4%9A%E6%AC%A1%E4%B9%B0%E5%8D%96%E4%BD%86%E6%8C%81%E6%9C%89%E4%B8%80%E5%8F%AA"><span class="toc-number">1.5.26.</span> <span class="toc-text">买卖股票的最佳时机II(多次买卖但持有一只)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIII-%E6%9C%80%E5%A4%9A%E4%B9%B0%E5%8D%96%E4%B8%A4%E6%AC%A1"><span class="toc-number">1.5.27.</span> <span class="toc-text">买卖股票的最佳时机III(最多买卖两次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAIV-%E6%9C%80%E5%A4%9A%E4%B9%B0%E5%8D%96-k-%E6%AC%A1"><span class="toc-number">1.5.28.</span> <span class="toc-text">买卖股票的最佳时机IV(最多买卖 k 次)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E5%86%B7%E5%86%BB%E6%9C%9F"><span class="toc-number">1.5.29.</span> <span class="toc-text">买卖股票的最佳时机含冷冻期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%E5%90%AB%E6%89%8B%E7%BB%AD%E8%B4%B9"><span class="toc-number">1.5.30.</span> <span class="toc-text">买卖股票的最佳时机含手续费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E5%BA%8F%E5%88%97%E9%80%92%E5%A2%9E%E7%9A%84%E6%9C%80%E5%B0%8F%E4%BA%A4%E6%8D%A2%E6%AC%A1%E6%95%B0"><span class="toc-number">1.5.31.</span> <span class="toc-text">使序列递增的最小交换次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BF%BB%E8%BD%AC%E5%88%B0%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E"><span class="toc-number">1.5.32.</span> <span class="toc-text">43.将字符串翻转到单调递增</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E7%BA%BF%E6%80%A7DP"><span class="toc-number">1.5.33.</span> <span class="toc-text">&#x3D;&#x3D;6&#x3D;&#x3D;.方法论 — 线性DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%8D%E8%BF%9E%E7%BB%AD"><span class="toc-number">1.5.34.</span> <span class="toc-text">最长上升子序列(子序列不连续)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C-%E2%80%93-%E6%B1%82%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%92%8C"><span class="toc-number">1.5.35.</span> <span class="toc-text">最大子数组和 – 求最大连续和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%88%E8%B0%88%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7"><span class="toc-number">1.5.36.</span> <span class="toc-text">谈谈无后效性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.37.</span> <span class="toc-text">乘积最大子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%BD%A2%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="toc-number">1.5.38.</span> <span class="toc-text">环形子数组的最大和</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E5%8F%8C%E5%BA%8F%E5%88%97DP"><span class="toc-number">1.5.39.</span> <span class="toc-text">&#x3D;&#x3D;7&#x3D;&#x3D;.方法论 — 双序列DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E9%87%8D%E5%A4%8D%E5%AD%90%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.40.</span> <span class="toc-text">最长重复子数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.5.41.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E7%9B%B8%E4%BA%A4%E7%9A%84%E7%BA%BF"><span class="toc-number">1.5.42.</span> <span class="toc-text">不相交的线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.5.43.</span> <span class="toc-text">判断子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%A9%B7%E4%B8%BE%E8%A7%86%E8%A7%92"><span class="toc-number">1.5.44.</span> <span class="toc-text">不同的子序列_&#x3D;&#x3D;动态规划的两种穷举视角&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="toc-number">1.5.45.</span> <span class="toc-text">38.两个字符的删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-number">1.5.46.</span> <span class="toc-text">39.编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E5%8C%BA%E9%97%B4DP"><span class="toc-number">1.5.47.</span> <span class="toc-text">&#x3D;&#x3D;8&#x3D;&#x3D;.方法论 — 区间DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%BF%83%E6%89%A9%E5%B1%95%E6%B3%95"><span class="toc-number">1.5.48.</span> <span class="toc-text">回文子串_可以使用中心扩展法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2"><span class="toc-number">1.5.49.</span> <span class="toc-text">最长回文子串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97-%E2%80%94-%E7%B1%BB%E4%BC%BC%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">1.5.50.</span> <span class="toc-text">最长回文子序列 — 类似最长公共子序列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97II"><span class="toc-number">1.6.</span> <span class="toc-text">44.不同的子序列II</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E6%95%B0%E4%BD%8DDP-%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.7.</span> <span class="toc-text">45.&#x3D;&#x3D;数位DP&#x3D;&#x3D;_详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E6%95%B0%E4%BD%8DDP%E7%9A%84%E5%BA%94%E7%94%A8-%E6%95%B0%E5%AD%971%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">46.数位DP的应用-数字1的个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E6%97%8B%E8%BD%AC%E6%95%B0%E5%AD%97"><span class="toc-number">1.9.</span> <span class="toc-text">47.旋转数字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E4%B8%8D%E5%90%AB%E8%BF%9E%E7%BB%AD1%E7%9A%84%E9%9D%9E%E8%B4%9F%E6%95%B4%E6%95%B0"><span class="toc-number">1.10.</span> <span class="toc-text">48.不含连续1的非负整数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%BA%8F%E5%88%97DP-%E8%A7%84%E5%88%92%E5%85%BC%E8%81%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.11.</span> <span class="toc-text">49.序列DP_规划兼职工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA"><span class="toc-number">1.12.</span> <span class="toc-text">50.多米诺和托米诺平铺</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E9%94%99%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.13.</span> <span class="toc-text">交错字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%A4%87%E5%BF%98%E5%BD%95%E5%88%B0%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.14.</span> <span class="toc-text">51.&#x3D;&#x3D;备忘录到动态规划&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E4%B8%8B%E9%99%8D%E8%B7%AF%E5%BE%84%E5%92%8C"><span class="toc-number">1.15.</span> <span class="toc-text">最小下降路径和 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD%E2%80%94%E4%B8%A4%E6%9E%9A%E9%B8%A1%E8%9B%8B"><span class="toc-number">1.16.</span> <span class="toc-text">52.鸡蛋掉落—两枚鸡蛋</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.16.1.</span> <span class="toc-text">正则表达式匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.17.</span> <span class="toc-text">5.回溯算法专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.17.1.</span> <span class="toc-text">1.回溯算法介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88-%E5%AD%90%E9%9B%86-%E4%B8%8E%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.17.2.</span> <span class="toc-text">组合(子集)与排列问题总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BB%84%E5%90%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.3.</span> <span class="toc-text">2.&#x3D;&#x3D;组合问题&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88"><span class="toc-number">1.17.4.</span> <span class="toc-text">组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CIII-%E2%80%94-%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E9%80%89"><span class="toc-number">1.17.5.</span> <span class="toc-text">组合总和III — 元素无重复不可重复选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88"><span class="toc-number">1.17.6.</span> <span class="toc-text">电话号码的字母组合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C-%E2%80%94-%E5%85%83%E7%B4%A0%E6%97%A0%E9%87%8D%E5%A4%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E9%80%89"><span class="toc-number">1.17.7.</span> <span class="toc-text">组合总和 — 元素无重复可重复选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8CII-%E2%80%94-%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E9%80%89"><span class="toc-number">1.17.8.</span> <span class="toc-text">组合总和II — 元素重复不可重复选</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%87%E5%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.17.9.</span> <span class="toc-text">3.&#x3D;&#x3D;切割问题&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2"><span class="toc-number">1.17.10.</span> <span class="toc-text">分割回文串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%8E%9FIP%E5%9C%B0%E5%9D%80"><span class="toc-number">1.17.11.</span> <span class="toc-text">复原IP地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98-%E2%80%94-%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%97%B6%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BD%93%E5%81%9A%E4%B8%80%E7%BB%84%E8%A7%A3"><span class="toc-number">1.17.12.</span> <span class="toc-text">4.&#x3D;&#x3D;子集问题&#x3D;&#x3D; — 迭代函数中添加一个元素时就可以当做一组解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86"><span class="toc-number">1.17.13.</span> <span class="toc-text">子集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E9%9B%86II"><span class="toc-number">1.17.14.</span> <span class="toc-text">子集II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%80%92%E5%87%8F%E5%AD%90%E5%BA%8F%E5%88%97-%E2%80%94-%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8F%AF%E6%8E%92%E5%BA%8F%EF%BC%8C%E6%A0%91%E5%B1%82%E5%8E%BB%E9%87%8D%E5%9C%A8%E8%BF%AD%E4%BB%A3%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8used%E6%95%B0%E7%BB%84"><span class="toc-number">1.17.15.</span> <span class="toc-text">非递减子序列 — 数组不可排序，树层去重在迭代函数内部使用used数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98-%E2%80%94-N%E4%B8%AA%E6%95%B0%E6%8C%89%E4%B8%80%E5%AE%9A%E8%A7%84%E5%88%99%E5%85%A8%E6%8E%92%E5%88%97%EF%BC%8C%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E6%8E%92%E5%88%97%E6%96%B9%E5%BC%8F"><span class="toc-number">1.17.16.</span> <span class="toc-text">5.&#x3D;&#x3D;排列问题&#x3D;&#x3D; — N个数按一定规则全排列，有多少种排列方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97"><span class="toc-number">1.17.17.</span> <span class="toc-text">全排列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E6%8E%92%E5%88%97II-%E2%80%94-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%87%8D%E5%A4%8D%E7%9A%84%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%EF%BC%8C%E6%A0%91%E6%9E%9D%E6%A0%91%E5%B1%82%E9%83%BD%E8%A6%81%E5%8E%BB%E9%87%8D"><span class="toc-number">1.17.18.</span> <span class="toc-text">全排列II — 数组元素重复的排列问题，树枝树层都要去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E8%A1%8C%E7%A8%8B"><span class="toc-number">1.17.19.</span> <span class="toc-text">重新安排行程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.18.</span> <span class="toc-text">6.贪心算法专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2"><span class="toc-number">1.18.1.</span> <span class="toc-text">分发饼干</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97"><span class="toc-number">1.18.2.</span> <span class="toc-text">摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83%E8%A7%A3%E6%B3%95"><span class="toc-number">1.18.2.1.</span> <span class="toc-text">贪心解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81dp%E8%A7%A3%E6%B3%95"><span class="toc-number">1.18.2.2.</span> <span class="toc-text">状态dp解法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.19.</span> <span class="toc-text">7.栈与队列专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-1"><span class="toc-number">1.19.1.</span> <span class="toc-text">方法论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.19.1.1.</span> <span class="toc-text">单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">1.19.1.2.</span> <span class="toc-text">优先队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88-1"><span class="toc-number">1.19.2.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#739-%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-%E2%80%94-%E5%9F%BA%E6%9C%AC%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">1.19.2.1.</span> <span class="toc-text">739.每日温度 — 基本单调栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#901-%E8%82%A1%E7%A5%A8%E4%BB%B7%E6%A0%BC%E8%B7%A8%E5%BA%A6"><span class="toc-number">1.19.2.2.</span> <span class="toc-text">901.股票价格跨度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1124-%E8%A1%A8%E7%8E%B0%E8%89%AF%E5%A5%BD%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%AE%B5%E2%80%94-%E5%8D%95%E8%B0%83%E9%80%92%E5%87%8F%E6%A0%88%E6%B1%82%E6%9C%80%E9%95%BF"><span class="toc-number">1.19.2.3.</span> <span class="toc-text">1124.表现良好的最长时间段— &#x3D;&#x3D;单调递减栈求最长&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#862-%E5%92%8C%E8%87%B3%E5%B0%91%E4%B8%BA-k-%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84-%E2%80%94-%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E9%98%9F%E5%88%97-%E6%B1%82%E6%9C%80%E7%9F%AD"><span class="toc-number">1.19.2.4.</span> <span class="toc-text">862.和至少为 k 最短子数组 — &#x3D;&#x3D;单调递增队列&#x3D;&#x3D;求最短</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#402-%E7%A7%BB%E6%8E%89K%E4%BD%8D%E6%95%B0%E5%AD%97"><span class="toc-number">1.19.2.5.</span> <span class="toc-text">402.移掉K位数字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#316-%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-number">1.19.2.6.</span> <span class="toc-text">316.去除重复字母</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#42-%E6%8E%A5%E9%9B%A8%E6%B0%B4"><span class="toc-number">1.19.2.7.</span> <span class="toc-text">42.接雨水</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC-%E2%80%94-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">1.19.2.8.</span> <span class="toc-text">239.滑动窗口最大值 — 单调队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97-1"><span class="toc-number">1.19.3.</span> <span class="toc-text">优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#347-%E5%89%8D-k-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="toc-number">1.19.3.1.</span> <span class="toc-text">347.前 k 个高频元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E6%8B%AC%E5%8F%B7%E5%BA%94%E7%94%A8"><span class="toc-number">1.19.4.</span> <span class="toc-text">栈的括号应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7"><span class="toc-number">1.19.4.1.</span> <span class="toc-text">32.最长有效括号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.20.</span> <span class="toc-text">8.图论专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%90%86%E8%AE%BA"><span class="toc-number">1.20.1.</span> <span class="toc-text">图理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-BFS-%E2%80%94-%E8%A7%A3%E5%86%B3%E4%B8%A4%E4%B8%AA%E7%82%B9%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.20.2.</span> <span class="toc-text">方法论 — BFS — 解决两个点之间的最短路径问题。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE-%E2%80%94-%E6%9F%93%E8%89%B2%E6%B3%95"><span class="toc-number">1.20.3.</span> <span class="toc-text">判断二分图 — 染色法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%93-%E7%BD%91%E6%A0%BC%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9A%84-DFS-%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.20.4.</span> <span class="toc-text">方法论 – 网格类问题的 DFS 遍历方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F"><span class="toc-number">1.20.5.</span> <span class="toc-text">岛屿数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E7%9A%84%E6%A1%A5"><span class="toc-number">1.20.6.</span> <span class="toc-text">最短的桥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A8-%E2%80%94-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.20.7.</span> <span class="toc-text">课程表 — 拓扑排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E8%AE%BA-%E2%80%94-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.20.8.</span> <span class="toc-text">方法论 — 并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BC%8F%E6%96%B9%E7%A8%8B%E7%9A%84%E5%8F%AF%E6%BB%A1%E8%B6%B3%E6%80%A7"><span class="toc-number">1.20.9.</span> <span class="toc-text">等式方程的可满足性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%97%E4%BD%99%E8%BF%9E%E6%8E%A5-%E2%80%93-%E5%B9%B6%E6%9F%A5%E9%9B%86%E6%89%BE%E5%A4%9A%E4%BD%99%E8%BE%B9"><span class="toc-number">1.20.10.</span> <span class="toc-text">冗余连接 – 并查集找多余边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kruskal%E7%AE%97%E6%B3%95%E4%B8%8E%E5%B9%B6%E6%9F%A5%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.20.11.</span> <span class="toc-text">kruskal算法与并查集的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%8E%E6%88%90%E6%9C%AC%E8%81%94%E9%80%9A%E6%89%80%E6%9C%89%E5%9F%8E%E5%B8%82-%E2%80%94-%E5%B9%B6%E6%9F%A5%E9%9B%86%E5%AE%9E%E7%8E%B0kruskal%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.20.12.</span> <span class="toc-text">最低成本联通所有城市 — &#x3D;&#x3D;并查集实现kruskal算法解决最小生成树问题&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8-%E2%80%94-kruskal"><span class="toc-number">1.20.13.</span> <span class="toc-text">连接所有点的最小费用  — &#x3D;&#x3D;kruskal&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E6%B1%82%E5%80%BC"><span class="toc-number">1.20.14.</span> <span class="toc-text">除法求值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#01%E7%9F%A9%E9%98%B5-%E2%80%94-BFS"><span class="toc-number">1.20.15.</span> <span class="toc-text">01矩阵 — &#x3D;&#x3D;BFS&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E6%89%80-%E2%80%94-%E5%8F%8C%E5%90%91BFS-%E5%B7%B2%E7%9F%A5%E8%B5%B7%E7%82%B9%E4%B8%8E%E7%BB%88%E7%82%B9"><span class="toc-number">1.20.16.</span> <span class="toc-text">打开转盘所 — 双向BFS(已知起点与终点)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95-%E2%80%94-%E6%B1%82%E5%B8%A6%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E4%B8%80%E7%82%B9%E5%88%B0%E5%85%B6%E4%BB%96%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.20.17.</span> <span class="toc-text">&#x3D;&#x3D;Dijkstra算法&#x3D;&#x3D; — 求带权有向图中一点到其他所有点的最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%BF%9F%E6%97%B6%E9%97%B4%E2%80%94Dijkstra"><span class="toc-number">1.20.18.</span> <span class="toc-text">网络延迟时间—Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.20.19.</span> <span class="toc-text">概率最大的路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floyd%E7%AE%97%E6%B3%95-%E5%A4%9A%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E9%97%AE%E9%A2%98"><span class="toc-number">1.20.20.</span> <span class="toc-text">&#x3D;&#x3D;floyd算法&#x3D;&#x3D; - 多源最短路问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E6%8B%9F%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.21.</span> <span class="toc-text">9.设计模拟专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9B%B8%E5%85%B3%E6%A8%A1%E6%8B%9F"><span class="toc-number">1.21.1.</span> <span class="toc-text">1.二维数组相关模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II-%E9%A1%BA%E6%97%B6%E9%92%88%E5%A1%AB%E5%85%85%E7%9F%A9%E9%98%B5"><span class="toc-number">1.21.1.1.</span> <span class="toc-text">59.螺旋矩阵II_&#x3D;&#x3D;顺时针填充矩阵&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#48-%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">1.21.1.2.</span> <span class="toc-text">48.旋转图像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.21.2.</span> <span class="toc-text">内存淘汰算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#LRU-%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.21.2.1.</span> <span class="toc-text">LRU 最近最久未使用淘汰算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LFU-%E6%9C%80%E8%BF%91%E6%9C%80%E5%B0%91%E4%BD%BF%E7%94%A8%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95"><span class="toc-number">1.21.2.2.</span> <span class="toc-text">LFU 最近最少使用淘汰算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.22.</span> <span class="toc-text">10.零散专题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Pow-x-n-%E2%80%94-%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.22.1.</span> <span class="toc-text">Pow(x, n) — 快速幂</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%9B%E7%B4%A0%E6%95%B0-%E2%80%94-%E5%9F%83%E5%8F%8A%E7%AD%9B"><span class="toc-number">1.22.2.</span> <span class="toc-text">筛素数 — 埃及筛</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.23.</span> <span class="toc-text">11.排序算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F-%E2%80%94-%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.23.1.</span> <span class="toc-text">1.快速排序 — 不稳定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-%E5%85%88%E5%88%86%E5%89%B2%E5%90%8E%E5%90%88%E5%B9%B6-%E2%80%94-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.23.2.</span> <span class="toc-text">2.归并排序(先分割后合并) — 稳定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">1.23.2.1.</span> <span class="toc-text">数组排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E5%BD%92%E5%B9%B6"><span class="toc-number">1.23.2.2.</span> <span class="toc-text">链表归并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A0%86%E6%8E%92%E5%BA%8F-%E2%80%93-%E4%B8%8D%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.23.3.</span> <span class="toc-text">3.堆排序 – 不稳定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#n2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.23.4.</span> <span class="toc-text">n2排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.23.4.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E2%80%94-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.23.4.2.</span> <span class="toc-text">插入排序 — 稳定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E2%80%94-%E7%A8%B3%E5%AE%9A"><span class="toc-number">1.23.4.3.</span> <span class="toc-text">冒泡排序 — 稳定</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/29/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93/" title="Untitled">Untitled</a><time datetime="2024-04-29T07:17:39.047Z" title="Created 2024-04-29 15:17:39">2024-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/29/Leetcode-%E5%9B%BE%E8%AE%BA%E4%B8%93%E9%A2%98-1/" title="Leetc-图论专题-1">Leetc-图论专题-1</a><time datetime="2024-04-29T07:10:54.625Z" title="Created 2024-04-29 15:10:54">2024-04-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/28/hexo-theme-butterfly%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2-2/" title="hexo-theme-butterfly部署博客-2">hexo-theme-butterfly部署博客-2</a><time datetime="2024-04-28T03:17:20.415Z" title="Created 2024-04-28 11:17:20">2024-04-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/27/hexo-theme-butterfly%E9%83%A8%E7%BD%B2%E5%8D%9A%E5%AE%A2-1/" title="hexo-theme-butterfly部署博客-1">hexo-theme-butterfly部署博客-1</a><time datetime="2024-04-27T07:44:26.975Z" title="Created 2024-04-27 15:44:26">2024-04-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By milklatte</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="Toggle between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="9931113845" data-server="netease" data-type="playlist" data-fixed="true" data-autoplay="true" data-lrcType="-1"> </div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>